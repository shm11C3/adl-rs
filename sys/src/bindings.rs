/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
  storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
  #[inline]
  pub const fn new(storage: Storage) -> Self {
    Self { storage }
  }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
  Storage: AsRef<[u8]> + AsMut<[u8]>,
{
  #[inline]
  fn extract_bit(byte: u8, index: usize) -> bool {
    let bit_index = if cfg!(target_endian = "big") {
      7 - (index % 8)
    } else {
      index % 8
    };
    let mask = 1 << bit_index;
    byte & mask == mask
  }
  #[inline]
  pub fn get_bit(&self, index: usize) -> bool {
    debug_assert!(index / 8 < self.storage.as_ref().len());
    let byte_index = index / 8;
    let byte = self.storage.as_ref()[byte_index];
    Self::extract_bit(byte, index)
  }
  #[inline]
  pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
    debug_assert!(index / 8 < core::mem::size_of::<Storage>());
    let byte_index = index / 8;
    let byte =
      *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
    Self::extract_bit(byte, index)
  }
  #[inline]
  fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
    let bit_index = if cfg!(target_endian = "big") {
      7 - (index % 8)
    } else {
      index % 8
    };
    let mask = 1 << bit_index;
    if val {
      byte | mask
    } else {
      byte & !mask
    }
  }
  #[inline]
  pub fn set_bit(&mut self, index: usize, val: bool) {
    debug_assert!(index / 8 < self.storage.as_ref().len());
    let byte_index = index / 8;
    let byte = &mut self.storage.as_mut()[byte_index];
    *byte = Self::change_bit(*byte, index, val);
  }
  #[inline]
  pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
    debug_assert!(index / 8 < core::mem::size_of::<Storage>());
    let byte_index = index / 8;
    let byte =
      (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
    *byte = Self::change_bit(*byte, index, val);
  }
  #[inline]
  pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
    debug_assert!(bit_width <= 64);
    debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
    debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
    let mut val = 0;
    for i in 0..(bit_width as usize) {
      if self.get_bit(i + bit_offset) {
        let index = if cfg!(target_endian = "big") {
          bit_width as usize - 1 - i
        } else {
          i
        };
        val |= 1 << index;
      }
    }
    val
  }
  #[inline]
  pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
    debug_assert!(bit_width <= 64);
    debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
    debug_assert!(
      (bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>()
    );
    let mut val = 0;
    for i in 0..(bit_width as usize) {
      if Self::raw_get_bit(this, i + bit_offset) {
        let index = if cfg!(target_endian = "big") {
          bit_width as usize - 1 - i
        } else {
          i
        };
        val |= 1 << index;
      }
    }
    val
  }
  #[inline]
  pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
    debug_assert!(bit_width <= 64);
    debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
    debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
    for i in 0..(bit_width as usize) {
      let mask = 1 << i;
      let val_bit_is_set = val & mask == mask;
      let index = if cfg!(target_endian = "big") {
        bit_width as usize - 1 - i
      } else {
        i
      };
      self.set_bit(index + bit_offset, val_bit_is_set);
    }
  }
  #[inline]
  pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
    debug_assert!(bit_width <= 64);
    debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
    debug_assert!(
      (bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>()
    );
    for i in 0..(bit_width as usize) {
      let mask = 1 << i;
      let val_bit_is_set = val & mask == mask;
      let index = if cfg!(target_endian = "big") {
        bit_width as usize - 1 - i
      } else {
        i
      };
      Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
    }
  }
}
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const ADL_TRUE: u32 = 1;
pub const ADL_FALSE: u32 = 0;
pub const ADL_MAX_CHAR: u32 = 4096;
pub const ADL_MAX_PATH: u32 = 256;
pub const ADL_MAX_ADAPTERS: u32 = 250;
pub const ADL_MAX_DISPLAYS: u32 = 150;
pub const ADL_MAX_DEVICENAME: u32 = 32;
pub const ADL_ADAPTER_INDEX_ALL: i32 = -1;
pub const ADL_MAIN_API_OPTION_NONE: u32 = 0;
pub const ADL_MAX_RPC_ENDPOINT: u32 = 32;
pub const ADL_DDC_OPTION_SWITCHDDC2: u32 = 1;
pub const ADL_DDC_OPTION_RESTORECOMMAND: u32 = 2;
pub const ADL_DDC_OPTION_COMBOWRITEREAD: u32 = 16;
pub const ADL_DDC_OPTION_SENDTOIMMEDIATEDEVICE: u32 = 32;
pub const ADL_DL_I2C_ACTIONREAD: u32 = 1;
pub const ADL_DL_I2C_ACTIONWRITE: u32 = 2;
pub const ADL_DL_I2C_ACTIONREAD_REPEATEDSTART: u32 = 3;
pub const ADL_DL_I2C_ACTIONIS_PRESENT: u32 = 4;
pub const ADL_OK_WAIT: u32 = 4;
pub const ADL_OK_RESTART: u32 = 3;
pub const ADL_OK_MODE_CHANGE: u32 = 2;
pub const ADL_OK_WARNING: u32 = 1;
pub const ADL_OK: u32 = 0;
pub const ADL_ERR: i32 = -1;
pub const ADL_ERR_NOT_INIT: i32 = -2;
pub const ADL_ERR_INVALID_PARAM: i32 = -3;
pub const ADL_ERR_INVALID_PARAM_SIZE: i32 = -4;
pub const ADL_ERR_INVALID_ADL_IDX: i32 = -5;
pub const ADL_ERR_INVALID_CONTROLLER_IDX: i32 = -6;
pub const ADL_ERR_INVALID_DIPLAY_IDX: i32 = -7;
pub const ADL_ERR_NOT_SUPPORTED: i32 = -8;
pub const ADL_ERR_NULL_POINTER: i32 = -9;
pub const ADL_ERR_DISABLED_ADAPTER: i32 = -10;
pub const ADL_ERR_INVALID_CALLBACK: i32 = -11;
pub const ADL_ERR_RESOURCE_CONFLICT: i32 = -12;
pub const ADL_ERR_SET_INCOMPLETE: i32 = -20;
pub const ADL_ERR_NO_XDISPLAY: i32 = -21;
pub const ADL_ERR_CALL_TO_INCOMPATIABLE_DRIVER: i32 = -22;
pub const ADL_ERR_NO_ADMINISTRATOR_PRIVILEGES: i32 = -23;
pub const ADL_ERR_FEATURESYNC_NOT_STARTED: i32 = -24;
pub const ADL_ERR_INVALID_POWER_STATE: i32 = -25;
pub const ADL_ERR_SERVER_BUSY: i32 = -26;
pub const ADL_ERR_GPU_IN_USE: i32 = -27;
pub const ADL_ERR_RPC: i32 = -28;
pub const ADL_DT_MONITOR: u32 = 0;
pub const ADL_DT_TELEVISION: u32 = 1;
pub const ADL_DT_LCD_PANEL: u32 = 2;
pub const ADL_DT_DIGITAL_FLAT_PANEL: u32 = 3;
pub const ADL_DT_COMPONENT_VIDEO: u32 = 4;
pub const ADL_DT_PROJECTOR: u32 = 5;
pub const ADL_DOT_UNKNOWN: u32 = 0;
pub const ADL_DOT_COMPOSITE: u32 = 1;
pub const ADL_DOT_SVIDEO: u32 = 2;
pub const ADL_DOT_ANALOG: u32 = 3;
pub const ADL_DOT_DIGITAL: u32 = 4;
pub const ADL_DISPLAY_COLOR_BRIGHTNESS: u32 = 1;
pub const ADL_DISPLAY_COLOR_CONTRAST: u32 = 2;
pub const ADL_DISPLAY_COLOR_SATURATION: u32 = 4;
pub const ADL_DISPLAY_COLOR_HUE: u32 = 8;
pub const ADL_DISPLAY_COLOR_TEMPERATURE: u32 = 16;
pub const ADL_DISPLAY_COLOR_TEMPERATURE_SOURCE_EDID: u32 = 32;
pub const ADL_DISPLAY_COLOR_TEMPERATURE_SOURCE_USER: u32 = 64;
pub const ADL_DISPLAY_ADJUST_OVERSCAN: u32 = 1;
pub const ADL_DISPLAY_ADJUST_VERT_POS: u32 = 2;
pub const ADL_DISPLAY_ADJUST_HOR_POS: u32 = 4;
pub const ADL_DISPLAY_ADJUST_VERT_SIZE: u32 = 8;
pub const ADL_DISPLAY_ADJUST_HOR_SIZE: u32 = 16;
pub const ADL_DISPLAY_ADJUST_SIZEPOS: u32 = 30;
pub const ADL_DISPLAY_CUSTOMMODES: u32 = 32;
pub const ADL_DISPLAY_ADJUST_UNDERSCAN: u32 = 64;
pub const ADL_DISPLAY_CAPS_DOWNSCALE: u32 = 1;
pub const ADL_DISPLAY_CAPS_SHARPNESS: u32 = 1;
pub const ADL_DESKTOPCONFIG_UNKNOWN: u32 = 0;
pub const ADL_DESKTOPCONFIG_SINGLE: u32 = 1;
pub const ADL_DESKTOPCONFIG_CLONE: u32 = 4;
pub const ADL_DESKTOPCONFIG_BIGDESK_H: u32 = 16;
pub const ADL_DESKTOPCONFIG_BIGDESK_V: u32 = 32;
pub const ADL_DESKTOPCONFIG_BIGDESK_HR: u32 = 64;
pub const ADL_DESKTOPCONFIG_BIGDESK_VR: u32 = 128;
pub const ADL_DESKTOPCONFIG_RANDR12: u32 = 256;
pub const ADL_MAX_DISPLAY_NAME: u32 = 256;
pub const ADL_DISPLAYDDCINFOEX_FLAG_PROJECTORDEVICE: u32 = 1;
pub const ADL_DISPLAYDDCINFOEX_FLAG_EDIDEXTENSION: u32 = 2;
pub const ADL_DISPLAYDDCINFOEX_FLAG_DIGITALDEVICE: u32 = 4;
pub const ADL_DISPLAYDDCINFOEX_FLAG_HDMIAUDIODEVICE: u32 = 8;
pub const ADL_DISPLAYDDCINFOEX_FLAG_SUPPORTS_AI: u32 = 16;
pub const ADL_DISPLAYDDCINFOEX_FLAG_SUPPORT_xvYCC601: u32 = 32;
pub const ADL_DISPLAYDDCINFOEX_FLAG_SUPPORT_xvYCC709: u32 = 64;
pub const ADL_DISPLAY_CONTYPE_UNKNOWN: u32 = 0;
pub const ADL_DISPLAY_CONTYPE_VGA: u32 = 1;
pub const ADL_DISPLAY_CONTYPE_DVI_D: u32 = 2;
pub const ADL_DISPLAY_CONTYPE_DVI_I: u32 = 3;
pub const ADL_DISPLAY_CONTYPE_ATICVDONGLE_NTSC: u32 = 4;
pub const ADL_DISPLAY_CONTYPE_ATICVDONGLE_JPN: u32 = 5;
pub const ADL_DISPLAY_CONTYPE_ATICVDONGLE_NONI2C_JPN: u32 = 6;
pub const ADL_DISPLAY_CONTYPE_ATICVDONGLE_NONI2C_NTSC: u32 = 7;
pub const ADL_DISPLAY_CONTYPE_PROPRIETARY: u32 = 8;
pub const ADL_DISPLAY_CONTYPE_HDMI_TYPE_A: u32 = 10;
pub const ADL_DISPLAY_CONTYPE_HDMI_TYPE_B: u32 = 11;
pub const ADL_DISPLAY_CONTYPE_SVIDEO: u32 = 12;
pub const ADL_DISPLAY_CONTYPE_COMPOSITE: u32 = 13;
pub const ADL_DISPLAY_CONTYPE_RCA_3COMPONENT: u32 = 14;
pub const ADL_DISPLAY_CONTYPE_DISPLAYPORT: u32 = 15;
pub const ADL_DISPLAY_CONTYPE_EDP: u32 = 16;
pub const ADL_DISPLAY_CONTYPE_WIRELESSDISPLAY: u32 = 17;
pub const ADL_DISPLAY_CONTYPE_USB_TYPE_C: u32 = 18;
pub const ADL_TV_STANDARDS: u32 = 1;
pub const ADL_TV_SCART: u32 = 2;
pub const ADL_STANDARD_NTSC_M: u32 = 1;
pub const ADL_STANDARD_NTSC_JPN: u32 = 2;
pub const ADL_STANDARD_NTSC_N: u32 = 4;
pub const ADL_STANDARD_PAL_B: u32 = 8;
pub const ADL_STANDARD_PAL_COMB_N: u32 = 16;
pub const ADL_STANDARD_PAL_D: u32 = 32;
pub const ADL_STANDARD_PAL_G: u32 = 64;
pub const ADL_STANDARD_PAL_H: u32 = 128;
pub const ADL_STANDARD_PAL_I: u32 = 256;
pub const ADL_STANDARD_PAL_K: u32 = 512;
pub const ADL_STANDARD_PAL_K1: u32 = 1024;
pub const ADL_STANDARD_PAL_L: u32 = 2048;
pub const ADL_STANDARD_PAL_M: u32 = 4096;
pub const ADL_STANDARD_PAL_N: u32 = 8192;
pub const ADL_STANDARD_PAL_SECAM_D: u32 = 16384;
pub const ADL_STANDARD_PAL_SECAM_K: u32 = 32768;
pub const ADL_STANDARD_PAL_SECAM_K1: u32 = 65536;
pub const ADL_STANDARD_PAL_SECAM_L: u32 = 131072;
pub const ADL_CUSTOMIZEDMODEFLAG_MODESUPPORTED: u32 = 1;
pub const ADL_CUSTOMIZEDMODEFLAG_NOTDELETETABLE: u32 = 2;
pub const ADL_CUSTOMIZEDMODEFLAG_INSERTBYDRIVER: u32 = 4;
pub const ADL_CUSTOMIZEDMODEFLAG_INTERLACED: u32 = 8;
pub const ADL_CUSTOMIZEDMODEFLAG_BASEMODE: u32 = 16;
pub const ADL_DISPLAY_CV_DONGLE_D1: u32 = 1;
pub const ADL_DISPLAY_CV_DONGLE_D2: u32 = 2;
pub const ADL_DISPLAY_CV_DONGLE_D3: u32 = 4;
pub const ADL_DISPLAY_CV_DONGLE_D4: u32 = 8;
pub const ADL_DISPLAY_CV_DONGLE_D5: u32 = 16;
pub const ADL_DISPLAY_CV_DONGLE_480I: u32 = 1;
pub const ADL_DISPLAY_CV_DONGLE_480P: u32 = 2;
pub const ADL_DISPLAY_CV_DONGLE_540P: u32 = 4;
pub const ADL_DISPLAY_CV_DONGLE_720P: u32 = 8;
pub const ADL_DISPLAY_CV_DONGLE_1080I: u32 = 16;
pub const ADL_DISPLAY_CV_DONGLE_1080P: u32 = 32;
pub const ADL_DISPLAY_CV_DONGLE_16_9: u32 = 64;
pub const ADL_DISPLAY_CV_DONGLE_720P50: u32 = 128;
pub const ADL_DISPLAY_CV_DONGLE_1080I25: u32 = 256;
pub const ADL_DISPLAY_CV_DONGLE_576I25: u32 = 512;
pub const ADL_DISPLAY_CV_DONGLE_576P50: u32 = 1024;
pub const ADL_DISPLAY_CV_DONGLE_1080P24: u32 = 2048;
pub const ADL_DISPLAY_CV_DONGLE_1080P25: u32 = 4096;
pub const ADL_DISPLAY_CV_DONGLE_1080P30: u32 = 8192;
pub const ADL_DISPLAY_CV_DONGLE_1080P50: u32 = 16384;
pub const ADL_DISPLAY_FORMAT_FORCE_720P: u32 = 1;
pub const ADL_DISPLAY_FORMAT_FORCE_1080I: u32 = 2;
pub const ADL_DISPLAY_FORMAT_FORCE_1080P: u32 = 4;
pub const ADL_DISPLAY_FORMAT_FORCE_720P50: u32 = 8;
pub const ADL_DISPLAY_FORMAT_FORCE_1080I25: u32 = 16;
pub const ADL_DISPLAY_FORMAT_FORCE_576I25: u32 = 32;
pub const ADL_DISPLAY_FORMAT_FORCE_576P50: u32 = 64;
pub const ADL_DISPLAY_FORMAT_FORCE_1080P24: u32 = 128;
pub const ADL_DISPLAY_FORMAT_FORCE_1080P25: u32 = 256;
pub const ADL_DISPLAY_FORMAT_FORCE_1080P30: u32 = 512;
pub const ADL_DISPLAY_FORMAT_FORCE_1080P50: u32 = 1024;
pub const ADL_DISPLAY_FORMAT_CVDONGLEOVERIDE: u32 = 1;
pub const ADL_DISPLAY_FORMAT_CVMODEUNDERSCAN: u32 = 2;
pub const ADL_DISPLAY_FORMAT_FORCECONNECT_SUPPORTED: u32 = 4;
pub const ADL_DISPLAY_FORMAT_RESTRICT_FORMAT_SELECTION: u32 = 8;
pub const ADL_DISPLAY_FORMAT_SETASPECRATIO: u32 = 16;
pub const ADL_DISPLAY_FORMAT_FORCEMODES: u32 = 32;
pub const ADL_DISPLAY_FORMAT_LCDRTCCOEFF: u32 = 64;
pub const ADL_PM_PARAM_DONT_CHANGE: u32 = 0;
pub const ADL_BUSTYPE_PCI: u32 = 0;
pub const ADL_BUSTYPE_AGP: u32 = 1;
pub const ADL_BUSTYPE_PCIE: u32 = 2;
pub const ADL_BUSTYPE_PCIE_GEN2: u32 = 3;
pub const ADL_BUSTYPE_PCIE_GEN3: u32 = 4;
pub const ADL_BUSTYPE_PCIE_GEN4: u32 = 5;
pub const ADL_BUSTYPE_PCIE_GEN5: u32 = 6;
pub const ADL_STEREO_SUPPORTED: u32 = 4;
pub const ADL_STEREO_BLUE_LINE: u32 = 8;
pub const ADL_STEREO_OFF: u32 = 0;
pub const ADL_STEREO_ACTIVE: u32 = 2;
pub const ADL_STEREO_AUTO_HORIZONTAL: u32 = 1073741824;
pub const ADL_STEREO_AUTO_VERTICAL: u32 = 2147483648;
pub const ADL_STEREO_PASSIVE: u32 = 64;
pub const ADL_STEREO_PASSIVE_HORIZ: u32 = 128;
pub const ADL_STEREO_PASSIVE_VERT: u32 = 256;
pub const ADL_STEREO_AUTO_SAMSUNG: u32 = 2048;
pub const ADL_STEREO_AUTO_TSL: u32 = 4096;
pub const ADL_DEEPBITDEPTH_10BPP_SUPPORTED: u32 = 32;
pub const ADL_8BIT_GREYSCALE_SUPPORTED: u32 = 512;
pub const ADL_CUSTOM_TIMING_SUPPORTED: u32 = 1024;
pub const ADL_WORKSTATION_LOADBALANCING_SUPPORTED: u32 = 1;
pub const ADL_WORKSTATION_LOADBALANCING_AVAILABLE: u32 = 2;
pub const ADL_WORKSTATION_LOADBALANCING_DISABLED: u32 = 0;
pub const ADL_WORKSTATION_LOADBALANCING_ENABLED: u32 = 1;
pub const ADL_CONTEXT_SPEED_UNFORCED: u32 = 0;
pub const ADL_CONTEXT_SPEED_FORCEHIGH: u32 = 1;
pub const ADL_CONTEXT_SPEED_FORCELOW: u32 = 2;
pub const ADL_ADAPTER_SPEEDCAPS_SUPPORTED: u32 = 1;
pub const ADL_GLSYNC_PORT_UNKNOWN: u32 = 0;
pub const ADL_GLSYNC_PORT_BNC: u32 = 1;
pub const ADL_GLSYNC_PORT_RJ45PORT1: u32 = 2;
pub const ADL_GLSYNC_PORT_RJ45PORT2: u32 = 3;
pub const ADL_GLSYNC_CONFIGMASK_NONE: u32 = 0;
pub const ADL_GLSYNC_CONFIGMASK_SIGNALSOURCE: u32 = 1;
pub const ADL_GLSYNC_CONFIGMASK_SYNCFIELD: u32 = 2;
pub const ADL_GLSYNC_CONFIGMASK_SAMPLERATE: u32 = 4;
pub const ADL_GLSYNC_CONFIGMASK_SYNCDELAY: u32 = 8;
pub const ADL_GLSYNC_CONFIGMASK_TRIGGEREDGE: u32 = 16;
pub const ADL_GLSYNC_CONFIGMASK_SCANRATECOEFF: u32 = 32;
pub const ADL_GLSYNC_CONFIGMASK_FRAMELOCKCNTL: u32 = 64;
pub const ADL_GLSYNC_FRAMELOCKCNTL_NONE: u32 = 0;
pub const ADL_GLSYNC_FRAMELOCKCNTL_ENABLE: u32 = 1;
pub const ADL_GLSYNC_FRAMELOCKCNTL_DISABLE: u32 = 2;
pub const ADL_GLSYNC_FRAMELOCKCNTL_SWAP_COUNTER_RESET: u32 = 4;
pub const ADL_GLSYNC_FRAMELOCKCNTL_SWAP_COUNTER_ACK: u32 = 8;
pub const ADL_GLSYNC_FRAMELOCKCNTL_VERSION_KMD: u32 = 16;
pub const ADL_GLSYNC_FRAMELOCKCNTL_STATE_ENABLE: u32 = 1;
pub const ADL_GLSYNC_FRAMELOCKCNTL_STATE_KMD: u32 = 16;
pub const ADL_GLSYNC_COUNTER_SWAP: u32 = 1;
pub const ADL_GLSYNC_SIGNALSOURCE_UNDEFINED: u32 = 256;
pub const ADL_GLSYNC_SIGNALSOURCE_FREERUN: u32 = 257;
pub const ADL_GLSYNC_SIGNALSOURCE_BNCPORT: u32 = 258;
pub const ADL_GLSYNC_SIGNALSOURCE_RJ45PORT1: u32 = 259;
pub const ADL_GLSYNC_SIGNALSOURCE_RJ45PORT2: u32 = 260;
pub const ADL_GLSYNC_SIGNALTYPE_UNDEFINED: u32 = 0;
pub const ADL_GLSYNC_SIGNALTYPE_480I: u32 = 1;
pub const ADL_GLSYNC_SIGNALTYPE_576I: u32 = 2;
pub const ADL_GLSYNC_SIGNALTYPE_480P: u32 = 3;
pub const ADL_GLSYNC_SIGNALTYPE_576P: u32 = 4;
pub const ADL_GLSYNC_SIGNALTYPE_720P: u32 = 5;
pub const ADL_GLSYNC_SIGNALTYPE_1080P: u32 = 6;
pub const ADL_GLSYNC_SIGNALTYPE_1080I: u32 = 7;
pub const ADL_GLSYNC_SIGNALTYPE_SDI: u32 = 8;
pub const ADL_GLSYNC_SIGNALTYPE_TTL: u32 = 9;
pub const ADL_GLSYNC_SIGNALTYPE_ANALOG: u32 = 10;
pub const ADL_GLSYNC_SYNCFIELD_UNDEFINED: u32 = 0;
pub const ADL_GLSYNC_SYNCFIELD_BOTH: u32 = 1;
pub const ADL_GLSYNC_SYNCFIELD_1: u32 = 2;
pub const ADL_GLSYNC_TRIGGEREDGE_UNDEFINED: u32 = 0;
pub const ADL_GLSYNC_TRIGGEREDGE_RISING: u32 = 1;
pub const ADL_GLSYNC_TRIGGEREDGE_FALLING: u32 = 2;
pub const ADL_GLSYNC_TRIGGEREDGE_BOTH: u32 = 3;
pub const ADL_GLSYNC_SCANRATECOEFF_UNDEFINED: u32 = 0;
pub const ADL_GLSYNC_SCANRATECOEFF_x5: u32 = 1;
pub const ADL_GLSYNC_SCANRATECOEFF_x4: u32 = 2;
pub const ADL_GLSYNC_SCANRATECOEFF_x3: u32 = 3;
pub const ADL_GLSYNC_SCANRATECOEFF_x5_DIV_2: u32 = 4;
pub const ADL_GLSYNC_SCANRATECOEFF_x2: u32 = 5;
pub const ADL_GLSYNC_SCANRATECOEFF_x3_DIV_2: u32 = 6;
pub const ADL_GLSYNC_SCANRATECOEFF_x5_DIV_4: u32 = 7;
pub const ADL_GLSYNC_SCANRATECOEFF_x1: u32 = 8;
pub const ADL_GLSYNC_SCANRATECOEFF_x4_DIV_5: u32 = 9;
pub const ADL_GLSYNC_SCANRATECOEFF_x2_DIV_3: u32 = 10;
pub const ADL_GLSYNC_SCANRATECOEFF_x1_DIV_2: u32 = 11;
pub const ADL_GLSYNC_SCANRATECOEFF_x2_DIV_5: u32 = 12;
pub const ADL_GLSYNC_SCANRATECOEFF_x1_DIV_3: u32 = 13;
pub const ADL_GLSYNC_SCANRATECOEFF_x1_DIV_4: u32 = 14;
pub const ADL_GLSYNC_SCANRATECOEFF_x1_DIV_5: u32 = 15;
pub const ADL_GLSYNC_PORTSTATE_UNDEFINED: u32 = 0;
pub const ADL_GLSYNC_PORTSTATE_NOCABLE: u32 = 1;
pub const ADL_GLSYNC_PORTSTATE_IDLE: u32 = 2;
pub const ADL_GLSYNC_PORTSTATE_INPUT: u32 = 3;
pub const ADL_GLSYNC_PORTSTATE_OUTPUT: u32 = 4;
pub const ADL_GLSYNC_LEDTYPE_BNC: u32 = 0;
pub const ADL_GLSYNC_LEDTYPE_RJ45_LEFT: u32 = 0;
pub const ADL_GLSYNC_LEDTYPE_RJ45_RIGHT: u32 = 1;
pub const ADL_GLSYNC_LEDCOLOR_UNDEFINED: u32 = 0;
pub const ADL_GLSYNC_LEDCOLOR_NOLIGHT: u32 = 1;
pub const ADL_GLSYNC_LEDCOLOR_YELLOW: u32 = 2;
pub const ADL_GLSYNC_LEDCOLOR_RED: u32 = 3;
pub const ADL_GLSYNC_LEDCOLOR_GREEN: u32 = 4;
pub const ADL_GLSYNC_LEDCOLOR_FLASH_GREEN: u32 = 5;
pub const ADL_GLSYNC_PORTCNTL_NONE: u32 = 0;
pub const ADL_GLSYNC_PORTCNTL_OUTPUT: u32 = 1;
pub const ADL_GLSYNC_MODECNTL_NONE: u32 = 0;
pub const ADL_GLSYNC_MODECNTL_GENLOCK: u32 = 1;
pub const ADL_GLSYNC_MODECNTL_TIMINGSERVER: u32 = 2;
pub const ADL_GLSYNC_MODECNTL_STATUS_NONE: u32 = 0;
pub const ADL_GLSYNC_MODECNTL_STATUS_GENLOCK: u32 = 1;
pub const ADL_GLSYNC_MODECNTL_STATUS_SETMODE_REQUIRED: u32 = 2;
pub const ADL_GLSYNC_MODECNTL_STATUS_GENLOCK_ALLOWED: u32 = 4;
pub const ADL_MAX_GLSYNC_PORTS: u32 = 8;
pub const ADL_MAX_GLSYNC_PORT_LEDS: u32 = 8;
pub const ADL_XFIREX_STATE_NOINTERCONNECT: u32 = 1;
pub const ADL_XFIREX_STATE_DOWNGRADEPIPES: u32 = 2;
pub const ADL_XFIREX_STATE_DOWNGRADEMEM: u32 = 4;
pub const ADL_XFIREX_STATE_REVERSERECOMMENDED: u32 = 8;
pub const ADL_XFIREX_STATE_3DACTIVE: u32 = 16;
pub const ADL_XFIREX_STATE_MASTERONSLAVE: u32 = 32;
pub const ADL_XFIREX_STATE_NODISPLAYCONNECT: u32 = 64;
pub const ADL_XFIREX_STATE_NOPRIMARYVIEW: u32 = 128;
pub const ADL_XFIREX_STATE_DOWNGRADEVISMEM: u32 = 256;
pub const ADL_XFIREX_STATE_LESSTHAN8LANE_MASTER: u32 = 512;
pub const ADL_XFIREX_STATE_LESSTHAN8LANE_SLAVE: u32 = 1024;
pub const ADL_XFIREX_STATE_PEERTOPEERFAILED: u32 = 2048;
pub const ADL_XFIREX_STATE_MEMISDOWNGRADED: u32 = 65536;
pub const ADL_XFIREX_STATE_PIPESDOWNGRADED: u32 = 131072;
pub const ADL_XFIREX_STATE_XFIREXACTIVE: u32 = 262144;
pub const ADL_XFIREX_STATE_VISMEMISDOWNGRADED: u32 = 524288;
pub const ADL_XFIREX_STATE_INVALIDINTERCONNECTION: u32 = 1048576;
pub const ADL_XFIREX_STATE_NONP2PMODE: u32 = 2097152;
pub const ADL_XFIREX_STATE_DOWNGRADEMEMBANKS: u32 = 4194304;
pub const ADL_XFIREX_STATE_MEMBANKSDOWNGRADED: u32 = 8388608;
pub const ADL_XFIREX_STATE_DUALDISPLAYSALLOWED: u32 = 16777216;
pub const ADL_XFIREX_STATE_P2P_APERTURE_MAPPING: u32 = 33554432;
pub const ADL_XFIREX_STATE_P2PFLUSH_REQUIRED: u32 = 33554432;
pub const ADL_XFIREX_STATE_XSP_CONNECTED: u32 = 67108864;
pub const ADL_XFIREX_STATE_ENABLE_CF_REBOOT_REQUIRED: u32 = 134217728;
pub const ADL_XFIREX_STATE_DISABLE_CF_REBOOT_REQUIRED: u32 = 268435456;
pub const ADL_XFIREX_STATE_DRV_HANDLE_DOWNGRADE_KEY: u32 = 536870912;
pub const ADL_XFIREX_STATE_CF_RECONFIG_REQUIRED: u32 = 1073741824;
pub const ADL_XFIREX_STATE_ERRORGETTINGSTATUS: u32 = 2147483648;
pub const ADL_DISPLAY_PIXELFORMAT_UNKNOWN: u32 = 0;
pub const ADL_DISPLAY_PIXELFORMAT_RGB: u32 = 1;
pub const ADL_DISPLAY_PIXELFORMAT_YCRCB444: u32 = 2;
pub const ADL_DISPLAY_PIXELFORMAT_YCRCB422: u32 = 4;
pub const ADL_DISPLAY_PIXELFORMAT_RGB_LIMITED_RANGE: u32 = 8;
pub const ADL_DISPLAY_PIXELFORMAT_RGB_FULL_RANGE: u32 = 1;
pub const ADL_DISPLAY_PIXELFORMAT_YCRCB420: u32 = 16;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_UNKNOWN: u32 = 0;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_CV_NONI2C_JP: u32 = 1;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_CV_JPN: u32 = 2;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_CV_NA: u32 = 3;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_CV_NONI2C_NA: u32 = 4;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_VGA: u32 = 5;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_DVI_D: u32 = 6;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_DVI_I: u32 = 7;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_HDMI_TYPE_A: u32 = 8;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_HDMI_TYPE_B: u32 = 9;
pub const ADL_DL_DISPLAYCONFIG_CONTYPE_DISPLAYPORT: u32 = 10;
pub const ADL_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED: u32 = 1;
pub const ADL_DISPLAY_DISPLAYINFO_DISPLAYMAPPED: u32 = 2;
pub const ADL_DISPLAY_DISPLAYINFO_NONLOCAL: u32 = 4;
pub const ADL_DISPLAY_DISPLAYINFO_FORCIBLESUPPORTED: u32 = 8;
pub const ADL_DISPLAY_DISPLAYINFO_GENLOCKSUPPORTED: u32 = 16;
pub const ADL_DISPLAY_DISPLAYINFO_MULTIVPU_SUPPORTED: u32 = 32;
pub const ADL_DISPLAY_DISPLAYINFO_LDA_DISPLAY: u32 = 64;
pub const ADL_DISPLAY_DISPLAYINFO_MODETIMING_OVERRIDESSUPPORTED: u32 = 128;
pub const ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_SINGLE: u32 = 256;
pub const ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_CLONE: u32 = 512;
pub const ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_2VSTRETCH: u32 = 1024;
pub const ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_2HSTRETCH: u32 = 2048;
pub const ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_EXTENDED: u32 = 4096;
pub const ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_NSTRETCH1GPU: u32 = 65536;
pub const ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_NSTRETCHNGPU: u32 = 131072;
pub const ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_RESERVED2: u32 = 262144;
pub const ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_RESERVED3: u32 = 524288;
pub const ADL_DISPLAY_DISPLAYINFO_SHOWTYPE_PROJECTOR: u32 = 1048576;
pub const ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_NOTACTIVE: u32 = 1;
pub const ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_SINGLE: u32 = 2;
pub const ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_CLONE: u32 = 4;
pub const ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_NSTRETCH1GPU: u32 = 8;
pub const ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_NSTRETCHNGPU: u32 = 16;
pub const ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_2VSTRETCH: u32 = 32;
pub const ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_2HSTRETCH: u32 = 64;
pub const ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_EXTENDED: u32 = 128;
pub const ADL_ADAPTER_DISPLAYCAP_PREFERDISPLAY_SUPPORTED: u32 = 256;
pub const ADL_ADAPTER_DISPLAYCAP_BEZEL_SUPPORTED: u32 = 512;
pub const ADL_DISPLAY_DISPLAYMAP_MANNER_RESERVED: u32 = 1;
pub const ADL_DISPLAY_DISPLAYMAP_MANNER_NOTACTIVE: u32 = 2;
pub const ADL_DISPLAY_DISPLAYMAP_MANNER_SINGLE: u32 = 4;
pub const ADL_DISPLAY_DISPLAYMAP_MANNER_CLONE: u32 = 8;
pub const ADL_DISPLAY_DISPLAYMAP_MANNER_RESERVED1: u32 = 16;
pub const ADL_DISPLAY_DISPLAYMAP_MANNER_HSTRETCH: u32 = 32;
pub const ADL_DISPLAY_DISPLAYMAP_MANNER_VSTRETCH: u32 = 64;
pub const ADL_DISPLAY_DISPLAYMAP_MANNER_VLD: u32 = 128;
pub const ADL_DISPLAY_DISPLAYMAP_OPTION_GPUINFO: u32 = 1;
pub const ADL_DISPLAY_DISPLAYTARGET_PREFERRED: u32 = 1;
pub const ADL_DISPLAY_POSSIBLEMAPRESULT_VALID: u32 = 1;
pub const ADL_DISPLAY_POSSIBLEMAPRESULT_BEZELSUPPORTED: u32 = 2;
pub const ADL_DISPLAY_POSSIBLEMAPRESULT_OVERLAPSUPPORTED: u32 = 4;
pub const ADL_DISPLAY_MODE_COLOURFORMAT_565: u32 = 1;
pub const ADL_DISPLAY_MODE_COLOURFORMAT_8888: u32 = 2;
pub const ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_000: u32 = 4;
pub const ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_090: u32 = 8;
pub const ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_180: u32 = 16;
pub const ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_270: u32 = 32;
pub const ADL_DISPLAY_MODE_REFRESHRATE_ROUNDED: u32 = 64;
pub const ADL_DISPLAY_MODE_REFRESHRATE_ONLY: u32 = 128;
pub const ADL_DISPLAY_MODE_PROGRESSIVE_FLAG: u32 = 0;
pub const ADL_DISPLAY_MODE_INTERLACED_FLAG: u32 = 2;
pub const ADL_OSMODEINFOXPOS_DEFAULT: i32 = -640;
pub const ADL_OSMODEINFOYPOS_DEFAULT: u32 = 0;
pub const ADL_OSMODEINFOXRES_DEFAULT: u32 = 640;
pub const ADL_OSMODEINFOYRES_DEFAULT: u32 = 480;
pub const ADL_OSMODEINFOXRES_DEFAULT800: u32 = 800;
pub const ADL_OSMODEINFOYRES_DEFAULT600: u32 = 600;
pub const ADL_OSMODEINFOREFRESHRATE_DEFAULT: u32 = 60;
pub const ADL_OSMODEINFOCOLOURDEPTH_DEFAULT: u32 = 8;
pub const ADL_OSMODEINFOCOLOURDEPTH_DEFAULT16: u32 = 16;
pub const ADL_OSMODEINFOCOLOURDEPTH_DEFAULT24: u32 = 24;
pub const ADL_OSMODEINFOCOLOURDEPTH_DEFAULT32: u32 = 32;
pub const ADL_OSMODEINFOORIENTATION_DEFAULT: u32 = 0;
pub const ADL_OSMODEFLAG_DEFAULT: u32 = 0;
pub const ADL_I2C_MAJOR_API_REV: u32 = 1;
pub const ADL_I2C_MINOR_DEFAULT_API_REV: u32 = 0;
pub const ADL_I2C_MINOR_OEM_API_REV: u32 = 1;
pub const ADL_DL_I2C_LINE_OEM: u32 = 1;
pub const ADL_DL_I2C_LINE_OD_CONTROL: u32 = 2;
pub const ADL_DL_I2C_LINE_OEM2: u32 = 3;
pub const ADL_DL_I2C_LINE_OEM3: u32 = 4;
pub const ADL_DL_I2C_LINE_OEM4: u32 = 5;
pub const ADL_DL_I2C_LINE_OEM5: u32 = 6;
pub const ADL_DL_I2C_LINE_OEM6: u32 = 7;
pub const ADL_DL_I2C_LINE_GPIO: u32 = 8;
pub const ADL_DL_I2C_MAXDATASIZE: u32 = 24;
pub const ADL_DL_I2C_MAXWRITEDATASIZE: u32 = 12;
pub const ADL_DL_I2C_MAXADDRESSLENGTH: u32 = 6;
pub const ADL_DL_I2C_MAXOFFSETLENGTH: u32 = 4;
pub const ADL_DL_I2C_SPEED_50K: u32 = 50;
pub const ADL_DL_I2C_SPEED_100K: u32 = 100;
pub const ALD_DL_I2C_SPEED_400K: u32 = 400;
pub const ADL_DL_I2C_SPEED_1M: u32 = 1000;
pub const ADL_DL_I2C_SPEED_2M: u32 = 2300;
pub const ADL_DL_DISPLAYPROPERTY_TYPE_UNKNOWN: u32 = 0;
pub const ADL_DL_DISPLAYPROPERTY_TYPE_EXPANSIONMODE: u32 = 1;
pub const ADL_DL_DISPLAYPROPERTY_TYPE_USEUNDERSCANSCALING: u32 = 2;
pub const ADL_DL_DISPLAYPROPERTY_TYPE_ITCFLAGENABLE: u32 = 9;
pub const ADL_DL_DISPLAYPROPERTY_TYPE_DOWNSCALE: u32 = 11;
pub const ADL_DL_DISPLAYPROPERTY_TYPE_INTEGER_SCALING: u32 = 12;
pub const ADL_DL_DISPLAYCONTENT_TYPE_GRAPHICS: u32 = 1;
pub const ADL_DL_DISPLAYCONTENT_TYPE_PHOTO: u32 = 2;
pub const ADL_DL_DISPLAYCONTENT_TYPE_CINEMA: u32 = 4;
pub const ADL_DL_DISPLAYCONTENT_TYPE_GAME: u32 = 8;
pub const ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_CENTER: u32 = 0;
pub const ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_FULLSCREEN: u32 = 1;
pub const ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_ASPECTRATIO: u32 = 2;
pub const ADL_DL_DISPLAY_DITHER_DISABLED: u32 = 0;
pub const ADL_DL_DISPLAY_DITHER_DRIVER_DEFAULT: u32 = 1;
pub const ADL_DL_DISPLAY_DITHER_FM6: u32 = 2;
pub const ADL_DL_DISPLAY_DITHER_FM8: u32 = 3;
pub const ADL_DL_DISPLAY_DITHER_FM10: u32 = 4;
pub const ADL_DL_DISPLAY_DITHER_DITH6: u32 = 5;
pub const ADL_DL_DISPLAY_DITHER_DITH8: u32 = 6;
pub const ADL_DL_DISPLAY_DITHER_DITH10: u32 = 7;
pub const ADL_DL_DISPLAY_DITHER_DITH6_NO_FRAME_RAND: u32 = 8;
pub const ADL_DL_DISPLAY_DITHER_DITH8_NO_FRAME_RAND: u32 = 9;
pub const ADL_DL_DISPLAY_DITHER_DITH10_NO_FRAME_RAND: u32 = 10;
pub const ADL_DL_DISPLAY_DITHER_TRUN6: u32 = 11;
pub const ADL_DL_DISPLAY_DITHER_TRUN8: u32 = 12;
pub const ADL_DL_DISPLAY_DITHER_TRUN10: u32 = 13;
pub const ADL_DL_DISPLAY_DITHER_TRUN10_DITH8: u32 = 14;
pub const ADL_DL_DISPLAY_DITHER_TRUN10_DITH6: u32 = 15;
pub const ADL_DL_DISPLAY_DITHER_TRUN10_FM8: u32 = 16;
pub const ADL_DL_DISPLAY_DITHER_TRUN10_FM6: u32 = 17;
pub const ADL_DL_DISPLAY_DITHER_TRUN10_DITH8_FM6: u32 = 18;
pub const ADL_DL_DISPLAY_DITHER_DITH10_FM8: u32 = 19;
pub const ADL_DL_DISPLAY_DITHER_DITH10_FM6: u32 = 20;
pub const ADL_DL_DISPLAY_DITHER_TRUN8_DITH6: u32 = 21;
pub const ADL_DL_DISPLAY_DITHER_TRUN8_FM6: u32 = 22;
pub const ADL_DL_DISPLAY_DITHER_DITH8_FM6: u32 = 23;
pub const ADL_DL_DISPLAY_DITHER_LAST: u32 = 23;
pub const ADL_MAX_EDIDDATA_SIZE: u32 = 256;
pub const ADL_MAX_OVERRIDEEDID_SIZE: u32 = 512;
pub const ADL_MAX_EDID_EXTENSION_BLOCKS: u32 = 3;
pub const ADL_DL_CONTROLLER_OVERLAY_ALPHA: u32 = 0;
pub const ADL_DL_CONTROLLER_OVERLAY_ALPHAPERPIX: u32 = 1;
pub const ADL_DL_DISPLAY_DATA_PACKET__INFO_PACKET_RESET: u32 = 0;
pub const ADL_DL_DISPLAY_DATA_PACKET__INFO_PACKET_SET: u32 = 1;
pub const ADL_DL_DISPLAY_DATA_PACKET__INFO_PACKET_SCAN: u32 = 2;
pub const ADL_DL_DISPLAY_DATA_PACKET__TYPE__AVI: u32 = 1;
pub const ADL_DL_DISPLAY_DATA_PACKET__TYPE__GAMMUT: u32 = 2;
pub const ADL_DL_DISPLAY_DATA_PACKET__TYPE__VENDORINFO: u32 = 4;
pub const ADL_DL_DISPLAY_DATA_PACKET__TYPE__HDR: u32 = 8;
pub const ADL_DL_DISPLAY_DATA_PACKET__TYPE__SPD: u32 = 16;
pub const ADL_GAMUT_MATRIX_SD: u32 = 1;
pub const ADL_GAMUT_MATRIX_HD: u32 = 2;
pub const ADL_DL_CLOCKINFO_FLAG_FULLSCREEN3DONLY: u32 = 1;
pub const ADL_DL_CLOCKINFO_FLAG_ALWAYSFULLSCREEN3D: u32 = 2;
pub const ADL_DL_CLOCKINFO_FLAG_VPURECOVERYREDUCED: u32 = 4;
pub const ADL_DL_CLOCKINFO_FLAG_THERMALPROTECTION: u32 = 8;
pub const ADL_DL_POWERXPRESS_GPU_INTEGRATED: u32 = 1;
pub const ADL_DL_POWERXPRESS_GPU_DISCRETE: u32 = 2;
pub const ADL_DL_POWERXPRESS_SWITCH_RESULT_STARTED: u32 = 1;
pub const ADL_DL_POWERXPRESS_SWITCH_RESULT_DECLINED: u32 = 2;
pub const ADL_DL_POWERXPRESS_SWITCH_RESULT_ALREADY: u32 = 3;
pub const ADL_DL_POWERXPRESS_SWITCH_RESULT_DEFERRED: u32 = 5;
pub const ADL_DL_POWERXPRESS_VERSION_MAJOR: u32 = 2;
pub const ADL_DL_POWERXPRESS_VERSION_MINOR: u32 = 0;
pub const ADL_DL_POWERXPRESS_VERSION: u32 = 131072;
pub const ADL_DL_THERMAL_DOMAIN_OTHER: u32 = 0;
pub const ADL_DL_THERMAL_DOMAIN_GPU: u32 = 1;
pub const ADL_DL_THERMAL_FLAG_INTERRUPT: u32 = 1;
pub const ADL_DL_THERMAL_FLAG_FANCONTROL: u32 = 2;
pub const ADL_DL_FANCTRL_SUPPORTS_PERCENT_READ: u32 = 1;
pub const ADL_DL_FANCTRL_SUPPORTS_PERCENT_WRITE: u32 = 2;
pub const ADL_DL_FANCTRL_SUPPORTS_RPM_READ: u32 = 4;
pub const ADL_DL_FANCTRL_SUPPORTS_RPM_WRITE: u32 = 8;
pub const ADL_DL_FANCTRL_SPEED_TYPE_PERCENT: u32 = 1;
pub const ADL_DL_FANCTRL_SPEED_TYPE_RPM: u32 = 2;
pub const ADL_DL_FANCTRL_FLAG_USER_DEFINED_SPEED: u32 = 1;
pub const ADL_DL_MAX_MVPU_ADAPTERS: u32 = 4;
pub const MVPU_ADAPTER_0: u32 = 1;
pub const MVPU_ADAPTER_1: u32 = 2;
pub const MVPU_ADAPTER_2: u32 = 4;
pub const MVPU_ADAPTER_3: u32 = 8;
pub const ADL_DL_MAX_REGISTRY_PATH: u32 = 256;
pub const ADL_DL_MVPU_STATUS_OFF: u32 = 0;
pub const ADL_DL_MVPU_STATUS_ON: u32 = 1;
pub const ADL_ASIC_UNDEFINED: u32 = 0;
pub const ADL_ASIC_DISCRETE: u32 = 1;
pub const ADL_ASIC_INTEGRATED: u32 = 2;
pub const ADL_ASIC_WORKSTATION: u32 = 4;
pub const ADL_ASIC_FIREMV: u32 = 8;
pub const ADL_ASIC_XGP: u32 = 16;
pub const ADL_ASIC_FUSION: u32 = 32;
pub const ADL_ASIC_FIRESTREAM: u32 = 64;
pub const ADL_ASIC_EMBEDDED: u32 = 128;
pub const ADL_ASIC_FIREGL: u32 = 4;
pub const ADL_DL_TIMINGFLAG_DOUBLE_SCAN: u32 = 1;
pub const ADL_DL_TIMINGFLAG_INTERLACED: u32 = 2;
pub const ADL_DL_TIMINGFLAG_H_SYNC_POLARITY: u32 = 4;
pub const ADL_DL_TIMINGFLAG_V_SYNC_POLARITY: u32 = 8;
pub const ADL_DL_MODETIMING_STANDARD_CVT: u32 = 1;
pub const ADL_DL_MODETIMING_STANDARD_GTF: u32 = 2;
pub const ADL_DL_MODETIMING_STANDARD_DMT: u32 = 4;
pub const ADL_DL_MODETIMING_STANDARD_CUSTOM: u32 = 8;
pub const ADL_DL_MODETIMING_STANDARD_DRIVER_DEFAULT: u32 = 16;
pub const ADL_DL_MODETIMING_STANDARD_CVT_RB: u32 = 32;
pub const ADL_XSERVERINFO_XINERAMAACTIVE: u32 = 1;
pub const ADL_XSERVERINFO_RANDR12SUPPORTED: u32 = 2;
pub const ADL_CONTROLLERVECTOR_0: u32 = 1;
pub const ADL_CONTROLLERVECTOR_1: u32 = 2;
pub const ADL_DISPLAY_SLSGRID_ORIENTATION_000: u32 = 1;
pub const ADL_DISPLAY_SLSGRID_ORIENTATION_090: u32 = 2;
pub const ADL_DISPLAY_SLSGRID_ORIENTATION_180: u32 = 4;
pub const ADL_DISPLAY_SLSGRID_ORIENTATION_270: u32 = 8;
pub const ADL_DISPLAY_SLSGRID_CAP_OPTION_RELATIVETO_LANDSCAPE: u32 = 1;
pub const ADL_DISPLAY_SLSGRID_CAP_OPTION_RELATIVETO_CURRENTANGLE: u32 = 2;
pub const ADL_DISPLAY_SLSGRID_PORTAIT_MODE: u32 = 4;
pub const ADL_DISPLAY_SLSGRID_KEEPTARGETROTATION: u32 = 128;
pub const ADL_DISPLAY_SLSGRID_SAMEMODESLS_SUPPORT: u32 = 16;
pub const ADL_DISPLAY_SLSGRID_MIXMODESLS_SUPPORT: u32 = 32;
pub const ADL_DISPLAY_SLSGRID_DISPLAYROTATION_SUPPORT: u32 = 64;
pub const ADL_DISPLAY_SLSGRID_DESKTOPROTATION_SUPPORT: u32 = 128;
pub const ADL_DISPLAY_SLSMAP_SLSLAYOUTMODE_FIT: u32 = 256;
pub const ADL_DISPLAY_SLSMAP_SLSLAYOUTMODE_FILL: u32 = 512;
pub const ADL_DISPLAY_SLSMAP_SLSLAYOUTMODE_EXPAND: u32 = 1024;
pub const ADL_DISPLAY_SLSMAP_IS_SLS: u32 = 4096;
pub const ADL_DISPLAY_SLSMAP_IS_SLSBUILDER: u32 = 8192;
pub const ADL_DISPLAY_SLSMAP_IS_CLONEVT: u32 = 16384;
pub const ADL_DISPLAY_SLSMAPCONFIG_GET_OPTION_RELATIVETO_LANDSCAPE: u32 = 1;
pub const ADL_DISPLAY_SLSMAPCONFIG_GET_OPTION_RELATIVETO_CURRENTANGLE: u32 = 2;
pub const ADL_DISPLAY_SLSMAPCONFIG_CREATE_OPTION_RELATIVETO_LANDSCAPE: u32 = 1;
pub const ADL_DISPLAY_SLSMAPCONFIG_CREATE_OPTION_RELATIVETO_CURRENTANGLE: u32 = 2;
pub const ADL_DISPLAY_SLSMAPCONFIG_REARRANGE_OPTION_RELATIVETO_LANDSCAPE: u32 = 1;
pub const ADL_DISPLAY_SLSMAPCONFIG_REARRANGE_OPTION_RELATIVETO_CURRENTANGLE: u32 = 2;
pub const ADL_SLS_SAMEMODESLS_SUPPORT: u32 = 1;
pub const ADL_SLS_MIXMODESLS_SUPPORT: u32 = 2;
pub const ADL_SLS_DISPLAYROTATIONSLS_SUPPORT: u32 = 4;
pub const ADL_SLS_DESKTOPROTATIONSLS_SUPPORT: u32 = 8;
pub const ADL_SLS_TARGETS_INVALID: u32 = 1;
pub const ADL_SLS_MODES_INVALID: u32 = 2;
pub const ADL_SLS_ROTATIONS_INVALID: u32 = 4;
pub const ADL_SLS_POSITIONS_INVALID: u32 = 8;
pub const ADL_SLS_LAYOUTMODE_INVALID: u32 = 16;
pub const ADL_DISPLAY_SLSDISPLAYOFFSET_VALID: u32 = 2;
pub const ADL_DISPLAY_SLSGRID_RELATIVETO_LANDSCAPE: u32 = 16;
pub const ADL_DISPLAY_SLSGRID_RELATIVETO_CURRENTANGLE: u32 = 32;
pub const ADL_DISPLAY_SLSMAP_BEZELMODE: u32 = 16;
pub const ADL_DISPLAY_SLSMAP_DISPLAYARRANGED: u32 = 2;
pub const ADL_DISPLAY_SLSMAP_CURRENTCONFIG: u32 = 4;
pub const ADL_DISPLAY_SLSMAPINDEXLIST_OPTION_ACTIVE: u32 = 1;
pub const ADL_DISPLAY_BEZELOFFSET_STEPBYSTEPSET: u32 = 4;
pub const ADL_DISPLAY_BEZELOFFSET_COMMIT: u32 = 8;
pub const ADL_PX_CONFIGCAPS_SPLASHSCREEN_SUPPORT: u32 = 1;
pub const ADL_PX_CONFIGCAPS_CF_SUPPORT: u32 = 2;
pub const ADL_PX_CONFIGCAPS_MUXLESS: u32 = 4;
pub const ADL_PX_CONFIGCAPS_PROFILE_COMPLIANT: u32 = 8;
pub const ADL_PX_CONFIGCAPS_NON_AMD_DRIVEN_DISPLAYS: u32 = 16;
pub const ADL_PX_CONFIGCAPS_FIXED_SUPPORT: u32 = 32;
pub const ADL_PX_CONFIGCAPS_DYNAMIC_SUPPORT: u32 = 64;
pub const ADL_PX_CONFIGCAPS_HIDE_AUTO_SWITCH: u32 = 128;
pub const ADL_PX_SCHEMEMASK_FIXED: u32 = 1;
pub const ADL_PX_SCHEMEMASK_DYNAMIC: u32 = 2;
pub const ADL_APP_PROFILE_FILENAME_LENGTH: u32 = 256;
pub const ADL_APP_PROFILE_TIMESTAMP_LENGTH: u32 = 32;
pub const ADL_APP_PROFILE_VERSION_LENGTH: u32 = 32;
pub const ADL_APP_PROFILE_PROPERTY_LENGTH: u32 = 64;
pub const ADL_MAX_RAD_LINK_COUNT: u32 = 15;
pub const ADL_GAMUT_REFERENCE_SOURCE: u32 = 1;
pub const ADL_GAMUT_GAMUT_VIDEO_CONTENT: u32 = 2;
pub const ADL_CUSTOM_WHITE_POINT: u32 = 1;
pub const ADL_CUSTOM_GAMUT: u32 = 2;
pub const ADL_GAMUT_REMAP_ONLY: u32 = 4;
pub const ADL_GAMUT_SPACE_CCIR_709: u32 = 1;
pub const ADL_GAMUT_SPACE_CCIR_601: u32 = 2;
pub const ADL_GAMUT_SPACE_ADOBE_RGB: u32 = 4;
pub const ADL_GAMUT_SPACE_CIE_RGB: u32 = 8;
pub const ADL_GAMUT_SPACE_CUSTOM: u32 = 16;
pub const ADL_GAMUT_SPACE_CCIR_2020: u32 = 32;
pub const ADL_GAMUT_SPACE_APPCTRL: u32 = 64;
pub const ADL_WHITE_POINT_5000K: u32 = 1;
pub const ADL_WHITE_POINT_6500K: u32 = 2;
pub const ADL_WHITE_POINT_7500K: u32 = 4;
pub const ADL_WHITE_POINT_9300K: u32 = 8;
pub const ADL_WHITE_POINT_CUSTOM: u32 = 16;
pub const ADL_GAMUT_WHITEPOINT_DIVIDER: u32 = 10000;
pub const ADL_REGAMMA_COEFFICIENT_A0_DIVIDER: u32 = 10000000;
pub const ADL_REGAMMA_COEFFICIENT_A1A2A3_DIVIDER: u32 = 1000;
pub const ADL_EDID_REGAMMA_COEFFICIENTS: u32 = 1;
pub const ADL_USE_GAMMA_RAMP: u32 = 16;
pub const ADL_APPLY_DEGAMMA: u32 = 32;
pub const ADL_EDID_REGAMMA_PREDEFINED_SRGB: u32 = 2;
pub const ADL_EDID_REGAMMA_PREDEFINED_PQ: u32 = 4;
pub const ADL_EDID_REGAMMA_PREDEFINED_PQ_2084_INTERIM: u32 = 8;
pub const ADL_EDID_REGAMMA_PREDEFINED_36: u32 = 64;
pub const ADL_EDID_REGAMMA_PREDEFINED_BT709: u32 = 128;
pub const ADL_EDID_REGAMMA_PREDEFINED_APPCTRL: u32 = 256;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB656: u32 = 1;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB666: u32 = 2;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB888: u32 = 4;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB101010: u32 = 8;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB161616: u32 = 16;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB_RESERVED1: u32 = 32;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB_RESERVED2: u32 = 64;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB_RESERVED3: u32 = 128;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_XRGB_BIAS101010: u32 = 256;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR444_8BPCC: u32 = 512;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR444_10BPCC: u32 = 1024;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR444_12BPCC: u32 = 2048;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR422_8BPCC: u32 = 4096;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR422_10BPCC: u32 = 8192;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR422_12BPCC: u32 = 16384;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR420_8BPCC: u32 = 32768;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR420_10BPCC: u32 = 65536;
pub const ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR420_12BPCC: u32 = 131072;
pub const ADL_TF_sRGB: u32 = 1;
pub const ADL_TF_BT709: u32 = 2;
pub const ADL_TF_PQ2084: u32 = 4;
pub const ADL_TF_PQ2084_INTERIM: u32 = 8;
pub const ADL_TF_LINEAR_0_1: u32 = 16;
pub const ADL_TF_LINEAR_0_125: u32 = 32;
pub const ADL_TF_DOLBYVISION: u32 = 64;
pub const ADL_TF_GAMMA_22: u32 = 128;
pub const ADL_CS_sRGB: u32 = 1;
pub const ADL_CS_BT601: u32 = 2;
pub const ADL_CS_BT709: u32 = 4;
pub const ADL_CS_BT2020: u32 = 8;
pub const ADL_CS_ADOBE: u32 = 16;
pub const ADL_CS_P3: u32 = 32;
pub const ADL_CS_scRGB_MS_REF: u32 = 64;
pub const ADL_CS_DISPLAY_NATIVE: u32 = 128;
pub const ADL_CS_APP_CONTROL: u32 = 256;
pub const ADL_CS_DOLBYVISION: u32 = 512;
pub const ADL_HDR_CEA861_3: u32 = 1;
pub const ADL_HDR_DOLBYVISION: u32 = 2;
pub const ADL_HDR_FREESYNC_HDR: u32 = 4;
pub const ADL_HDR_FREESYNC_BACKLIGHT_SUPPORT: u32 = 1;
pub const ADL_HDR_FREESYNC_LOCAL_DIMMING: u32 = 2;
pub const ADL_SCA_LOCAL_DIMMING_DISABLE: u32 = 1;
pub const ADL_DEEPBITDEPTH_FORCEOFF: u32 = 0;
pub const ADL_DEEPBITDEPTH_10BPP_AUTO: u32 = 1;
pub const ADL_DEEPBITDEPTH_10BPP_FORCEON: u32 = 2;
pub const ADL_ADAPTER_CONFIGMEMORY_DBD: u32 = 1;
pub const ADL_ADAPTER_CONFIGMEMORY_ROTATE: u32 = 2;
pub const ADL_ADAPTER_CONFIGMEMORY_STEREO_PASSIVE: u32 = 4;
pub const ADL_ADAPTER_CONFIGMEMORY_STEREO_ACTIVE: u32 = 8;
pub const ADL_ADAPTER_CONFIGMEMORY_ENHANCEDVSYNC: u32 = 16;
pub const ADL_ADAPTER_CONFIGMEMORY_TEARFREEVSYNC: u32 = 16;
pub const ADL_MEMORYREQTYPE_VISIBLE: u32 = 1;
pub const ADL_MEMORYREQTYPE_INVISIBLE: u32 = 2;
pub const ADL_MEMORYREQTYPE_GPURESERVEDVISIBLE: u32 = 4;
pub const ADL_ADAPTER_TEAR_FREE_ON: u32 = 1;
pub const ADL_ADAPTER_TEAR_FREE_NOTENOUGHMEM: i32 = -1;
pub const ADL_ADAPTER_TEAR_FREE_OFF_ERR_QUADBUFFERSTEREO: i32 = -2;
pub const ADL_ADAPTER_TEAR_FREE_OFF_ERR_MGPUSLD: i32 = -3;
pub const ADL_ADAPTER_TEAR_FREE_OFF: u32 = 0;
pub const ADL_CROSSDISPLAY_PLATFORM: u32 = 1;
pub const ADL_CROSSDISPLAY_PLATFORM_LASSO: u32 = 2;
pub const ADL_CROSSDISPLAY_PLATFORM_DOCKSTATION: u32 = 4;
pub const ADL_CROSSDISPLAY_OPTION_NONE: u32 = 0;
pub const ADL_CROSSDISPLAY_OPTION_FORCESWITCH: u32 = 1;
pub const ADL_ADAPTERCONFIGSTATE_HEADLESS: u32 = 4;
pub const ADL_ADAPTERCONFIGSTATE_REQUISITE_RENDER: u32 = 1;
pub const ADL_ADAPTERCONFIGSTATE_ANCILLARY_RENDER: u32 = 2;
pub const ADL_ADAPTERCONFIGSTATE_SCATTERGATHER: u32 = 16;
pub const ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_POSITION: u32 = 1;
pub const ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_PANLOCK: u32 = 2;
pub const ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_SIZE: u32 = 8;
pub const ADL_MAX_AUDIO_SAMPLE_RATE_COUNT: u32 = 16;
pub const ADL_OD6_CAPABILITY_SCLK_CUSTOMIZATION: u32 = 1;
pub const ADL_OD6_CAPABILITY_MCLK_CUSTOMIZATION: u32 = 2;
pub const ADL_OD6_CAPABILITY_GPU_ACTIVITY_MONITOR: u32 = 4;
pub const ADL_OD6_CAPABILITY_POWER_CONTROL: u32 = 8;
pub const ADL_OD6_CAPABILITY_VOLTAGE_CONTROL: u32 = 16;
pub const ADL_OD6_CAPABILITY_PERCENT_ADJUSTMENT: u32 = 32;
pub const ADL_OD6_CAPABILITY_THERMAL_LIMIT_UNLOCK: u32 = 64;
pub const ADL_OD6_CAPABILITY_FANSPEED_IN_RPM: u32 = 128;
pub const ADL_OD6_SUPPORTEDSTATE_PERFORMANCE: u32 = 1;
pub const ADL_OD6_SUPPORTEDSTATE_POWER_SAVING: u32 = 2;
pub const ADL_OD6_GETSTATEINFO_DEFAULT_PERFORMANCE: u32 = 1;
pub const ADL_OD6_GETSTATEINFO_DEFAULT_POWER_SAVING: u32 = 2;
pub const ADL_OD6_GETSTATEINFO_CURRENT: u32 = 3;
pub const ADL_OD6_GETSTATEINFO_CUSTOM_PERFORMANCE: u32 = 4;
pub const ADL_OD6_GETSTATEINFO_CUSTOM_POWER_SAVING: u32 = 5;
pub const ADL_OD6_STATE_PERFORMANCE: u32 = 1;
pub const ADL_OD6_SETSTATE_PERFORMANCE: u32 = 1;
pub const ADL_OD6_SETSTATE_POWER_SAVING: u32 = 2;
pub const ADL_OD6_TCCAPS_THERMAL_CONTROLLER: u32 = 1;
pub const ADL_OD6_TCCAPS_FANSPEED_CONTROL: u32 = 2;
pub const ADL_OD6_TCCAPS_FANSPEED_PERCENT_READ: u32 = 256;
pub const ADL_OD6_TCCAPS_FANSPEED_PERCENT_WRITE: u32 = 512;
pub const ADL_OD6_TCCAPS_FANSPEED_RPM_READ: u32 = 1024;
pub const ADL_OD6_TCCAPS_FANSPEED_RPM_WRITE: u32 = 2048;
pub const ADL_OD6_FANSPEED_TYPE_PERCENT: u32 = 1;
pub const ADL_OD6_FANSPEED_TYPE_RPM: u32 = 2;
pub const ADL_OD6_FANSPEED_USER_DEFINED: u32 = 256;
pub const ADL_ODN_EVENTCOUNTER_THERMAL: u32 = 0;
pub const ADL_ODN_EVENTCOUNTER_VPURECOVERY: u32 = 1;
pub const ADL_PMLOG_MAX_SENSORS: u32 = 256;
pub const ECC_MODE_OFF: u32 = 0;
pub const ECC_MODE_ON: u32 = 2;
pub const ECC_MODE_HBM: u32 = 3;
pub const ADL_BLAYOUT_VALID_NUMBER_OF_SLOTS: u32 = 1;
pub const ADL_BLAYOUT_VALID_SLOT_SIZES: u32 = 2;
pub const ADL_BLAYOUT_VALID_CONNECTOR_OFFSETS: u32 = 4;
pub const ADL_BLAYOUT_VALID_CONNECTOR_LENGTHS: u32 = 8;
pub const ADL_ADAPTER_MAX_SLOTS: u32 = 4;
pub const ADL_ADAPTER_MAX_CONNECTORS: u32 = 10;
pub const ADL_MAX_CONNECTION_TYPES: u32 = 32;
pub const ADL_MAX_RELATIVE_ADDRESS_LINK_COUNT: u32 = 15;
pub const ADL_MAX_DISPLAY_EDID_DATA_SIZE: u32 = 1024;
pub const ADL_MAX_ERROR_RECORDS_COUNT: u32 = 256;
pub const ADL_MAX_POWER_POLICY: u32 = 6;
pub const ADL_CONNECTION_TYPE_VGA: u32 = 0;
pub const ADL_CONNECTION_TYPE_DVI: u32 = 1;
pub const ADL_CONNECTION_TYPE_DVI_SL: u32 = 2;
pub const ADL_CONNECTION_TYPE_HDMI: u32 = 3;
pub const ADL_CONNECTION_TYPE_DISPLAY_PORT: u32 = 4;
pub const ADL_CONNECTION_TYPE_ACTIVE_DONGLE_DP_DVI_SL: u32 = 5;
pub const ADL_CONNECTION_TYPE_ACTIVE_DONGLE_DP_DVI_DL: u32 = 6;
pub const ADL_CONNECTION_TYPE_ACTIVE_DONGLE_DP_HDMI: u32 = 7;
pub const ADL_CONNECTION_TYPE_ACTIVE_DONGLE_DP_VGA: u32 = 8;
pub const ADL_CONNECTION_TYPE_PASSIVE_DONGLE_DP_HDMI: u32 = 9;
pub const ADL_CONNECTION_TYPE_PASSIVE_DONGLE_DP_DVI: u32 = 10;
pub const ADL_CONNECTION_TYPE_MST: u32 = 11;
pub const ADL_CONNECTION_TYPE_ACTIVE_DONGLE: u32 = 12;
pub const ADL_CONNECTION_TYPE_VIRTUAL: u32 = 13;
pub const ADL_CONNECTION_PROPERTY_BITRATE: u32 = 1;
pub const ADL_CONNECTION_PROPERTY_NUMBER_OF_LANES: u32 = 2;
pub const ADL_CONNECTION_PROPERTY_3DCAPS: u32 = 4;
pub const ADL_CONNECTION_PROPERTY_OUTPUT_BANDWIDTH: u32 = 8;
pub const ADL_CONNECTION_PROPERTY_COLORDEPTH: u32 = 16;
pub const ADL_LANECOUNT_UNKNOWN: u32 = 0;
pub const ADL_LANECOUNT_ONE: u32 = 1;
pub const ADL_LANECOUNT_TWO: u32 = 2;
pub const ADL_LANECOUNT_FOUR: u32 = 4;
pub const ADL_LANECOUNT_EIGHT: u32 = 8;
pub const ADL_LANECOUNT_DEF: u32 = 4;
pub const ADL_LINK_BITRATE_UNKNOWN: u32 = 0;
pub const ADL_LINK_BITRATE_1_62_GHZ: u32 = 6;
pub const ADL_LINK_BITRATE_2_7_GHZ: u32 = 10;
pub const ADL_LINK_BITRATE_5_4_GHZ: u32 = 20;
pub const ADL_LINK_BITRATE_8_1_GHZ: u32 = 30;
pub const ADL_LINK_BITRATE_DEF: u32 = 10;
pub const ADL_CONNPROP_S3D_ALTERNATE_TO_FRAME_PACK: u32 = 1;
pub const ADL_COLORDEPTH_UNKNOWN: u32 = 0;
pub const ADL_COLORDEPTH_666: u32 = 1;
pub const ADL_COLORDEPTH_888: u32 = 2;
pub const ADL_COLORDEPTH_101010: u32 = 3;
pub const ADL_COLORDEPTH_121212: u32 = 4;
pub const ADL_COLORDEPTH_141414: u32 = 5;
pub const ADL_COLORDEPTH_161616: u32 = 6;
pub const ADL_COLOR_DEPTH_DEF: u32 = 2;
pub const ADL_EMUL_STATUS_REAL_DEVICE_CONNECTED: u32 = 1;
pub const ADL_EMUL_STATUS_EMULATED_DEVICE_PRESENT: u32 = 2;
pub const ADL_EMUL_STATUS_EMULATED_DEVICE_USED: u32 = 4;
pub const ADL_EMUL_STATUS_LAST_ACTIVE_DEVICE_USED: u32 = 8;
pub const ADL_EMUL_MODE_OFF: u32 = 0;
pub const ADL_EMUL_MODE_ON_CONNECTED: u32 = 1;
pub const ADL_EMUL_MODE_ON_DISCONNECTED: u32 = 2;
pub const ADL_EMUL_MODE_ALWAYS: u32 = 3;
pub const ADL_QUERY_REAL_DATA: u32 = 0;
pub const ADL_QUERY_EMULATED_DATA: u32 = 1;
pub const ADL_QUERY_CURRENT_DATA: u32 = 2;
pub const ADL_EDID_PERSISTANCE_DISABLED: u32 = 0;
pub const ADL_EDID_PERSISTANCE_ENABLED: u32 = 1;
pub const ADL_CONNECTOR_TYPE_UNKNOWN: u32 = 0;
pub const ADL_CONNECTOR_TYPE_VGA: u32 = 1;
pub const ADL_CONNECTOR_TYPE_DVI_D: u32 = 2;
pub const ADL_CONNECTOR_TYPE_DVI_I: u32 = 3;
pub const ADL_CONNECTOR_TYPE_ATICVDONGLE_NA: u32 = 4;
pub const ADL_CONNECTOR_TYPE_ATICVDONGLE_JP: u32 = 5;
pub const ADL_CONNECTOR_TYPE_ATICVDONGLE_NONI2C: u32 = 6;
pub const ADL_CONNECTOR_TYPE_ATICVDONGLE_NONI2C_D: u32 = 7;
pub const ADL_CONNECTOR_TYPE_HDMI_TYPE_A: u32 = 8;
pub const ADL_CONNECTOR_TYPE_HDMI_TYPE_B: u32 = 9;
pub const ADL_CONNECTOR_TYPE_DISPLAYPORT: u32 = 10;
pub const ADL_CONNECTOR_TYPE_EDP: u32 = 11;
pub const ADL_CONNECTOR_TYPE_MINI_DISPLAYPORT: u32 = 12;
pub const ADL_CONNECTOR_TYPE_VIRTUAL: u32 = 13;
pub const ADL_CONNECTOR_TYPE_USB_TYPE_C: u32 = 14;
pub const ADL_FREESYNC_USECASE_STATIC: u32 = 1;
pub const ADL_FREESYNC_USECASE_VIDEO: u32 = 2;
pub const ADL_FREESYNC_USECASE_GAMING: u32 = 4;
pub const ADL_FREESYNC_CAP_SUPPORTED: u32 = 1;
pub const ADL_FREESYNC_CAP_GPUSUPPORTED: u32 = 2;
pub const ADL_FREESYNC_CAP_DISPLAYSUPPORTED: u32 = 4;
pub const ADL_FREESYNC_CAP_CURRENTMODESUPPORTED: u32 = 8;
pub const ADL_FREESYNC_CAP_NOCFXORCFXSUPPORTED: u32 = 16;
pub const ADL_FREESYNC_CAP_NOGENLOCKORGENLOCKSUPPORTED: u32 = 32;
pub const ADL_FREESYNC_CAP_BORDERLESSWINDOWSUPPORTED: u32 = 64;
pub const ADL_FREESYNC_LABEL_UNSUPPORTED: u32 = 0;
pub const ADL_FREESYNC_LABEL_FREESYNC: u32 = 1;
pub const ADL_FREESYNC_LABEL_ADAPTIVE_SYNC: u32 = 2;
pub const ADL_FREESYNC_LABEL_VRR: u32 = 3;
pub const ADL_FREESYNC_LABEL_FREESYNC_PREMIUM: u32 = 4;
pub const ADL_FREESYNC_LABEL_FREESYNC_PREMIUM_PRO: u32 = 5;
pub const ADL_FREESYNC_POWEROPTIMIZATION_SUPPORTED_MASK: u32 = 1;
pub const ADL_FREESYNC_POWEROPTIMIZATION_ENABLED_MASK: u32 = 2;
pub const ADL_FREESYNC_POWEROPTIMIZATION_DEFAULT_VALUE_MASK: u32 = 4;
pub const ADL_MST_COMMANDLINE_PATH_MSG: u32 = 1;
pub const ADL_MST_COMMANDLINE_BROADCAST: u32 = 2;
pub const ADL_CROSSGPUDISPLAYCLONE_AMD_WITH_NONAMD: u32 = 1;
pub const ADL_CROSSGPUDISPLAYCLONE: u32 = 2;
pub const ADL_RADEON_LED_MAX_BRIGHTNESS: u32 = 2;
pub const ADL_RADEON_LED_MAX_SPEED: u32 = 4;
pub const ADL_RADEON_LED_MAX_RGB: u32 = 255;
pub const ADL_RADEON_LED_MAX_MORSE_CODE: u32 = 260;
pub const ADL_RADEON_LED_MAX_LED_ROW_ON_GRID: u32 = 7;
pub const ADL_RADEON_LED_MAX_LED_COLUMN_ON_GRID: u32 = 24;
pub const ADL_REG_DEVICE_FUNCTION_1: u32 = 1;
pub const ADL_FEATURE_NAME_LENGTH: u32 = 16;
pub const ADL_SDK_MAJOR_VERSION: u32 = 18;
pub const ADL_SDK_MINOR_VERSION: u32 = 0;
pub type wchar_t = ::std::os::raw::c_ushort;
#[doc = "< Default behavior. ADL will not enforce serialization of ADL API executions by multiple threads.  Multiple threads will be allowed to enter to ADL at the same time. Note that ADL library is not guaranteed to be thread-safe. Client that calls ADL_Main_Control_Create have to provide its own mechanism for ADL calls serialization."]
pub const ADLThreadingModel_ADL_THREADING_UNLOCKED: ADLThreadingModel = 0;
#[doc = "< ADL will enforce serialization of ADL API when called by multiple threads.  Only single thread will be allowed to enter ADL API at the time. This option makes ADL calls thread-safe."]
pub const ADLThreadingModel_ADL_THREADING_LOCKED: ADLThreadingModel = 1;
#[doc = "\n \\defgroup thread_model\n Used with \\ref ADL_Main_ControlX2_Create and \\ref ADL2_Main_ControlX2_Create to specify how ADL handles API calls when executed by multiple threads concurrently.\n \\brief Declares ADL threading behavior.\n @{"]
pub type ADLThreadingModel = ::std::os::raw::c_int;
pub const ADLPurposeCode_ADL_PURPOSECODE_NORMAL: ADLPurposeCode = 0;
pub const ADLPurposeCode_ADL_PURPOSECODE_HIDE_MODE_SWITCH: ADLPurposeCode = 1;
pub const ADLPurposeCode_ADL_PURPOSECODE_MODE_SWITCH: ADLPurposeCode = 2;
pub const ADLPurposeCode_ADL_PURPOSECODE_ATTATCH_DEVICE: ADLPurposeCode = 3;
pub const ADLPurposeCode_ADL_PURPOSECODE_DETACH_DEVICE: ADLPurposeCode = 4;
pub const ADLPurposeCode_ADL_PURPOSECODE_SETPRIMARY_DEVICE: ADLPurposeCode = 5;
pub const ADLPurposeCode_ADL_PURPOSECODE_GDI_ROTATION: ADLPurposeCode = 6;
pub const ADLPurposeCode_ADL_PURPOSECODE_ATI_ROTATION: ADLPurposeCode = 7;
pub type ADLPurposeCode = ::std::os::raw::c_int;
pub const ADLAngle_ADL_ANGLE_LANDSCAPE: ADLAngle = 0;
pub const ADLAngle_ADL_ANGLE_ROTATERIGHT: ADLAngle = 90;
pub const ADLAngle_ADL_ANGLE_ROTATE180: ADLAngle = 180;
pub const ADLAngle_ADL_ANGLE_ROTATELEFT: ADLAngle = 270;
pub type ADLAngle = ::std::os::raw::c_int;
pub const ADLOrientationDataType_ADL_ORIENTATIONTYPE_OSDATATYPE: ADLOrientationDataType =
  0;
pub const ADLOrientationDataType_ADL_ORIENTATIONTYPE_NONOSDATATYPE:
  ADLOrientationDataType = 1;
pub type ADLOrientationDataType = ::std::os::raw::c_int;
pub const ADLPanningMode_ADL_PANNINGMODE_NO_PANNING: ADLPanningMode = 0;
pub const ADLPanningMode_ADL_PANNINGMODE_AT_LEAST_ONE_NO_PANNING: ADLPanningMode = 1;
pub const ADLPanningMode_ADL_PANNINGMODE_ALLOW_PANNING: ADLPanningMode = 2;
pub type ADLPanningMode = ::std::os::raw::c_int;
pub const ADLLARGEDESKTOPTYPE_ADL_LARGEDESKTOPTYPE_NORMALDESKTOP: ADLLARGEDESKTOPTYPE = 0;
pub const ADLLARGEDESKTOPTYPE_ADL_LARGEDESKTOPTYPE_PSEUDOLARGEDESKTOP:
  ADLLARGEDESKTOPTYPE = 1;
pub const ADLLARGEDESKTOPTYPE_ADL_LARGEDESKTOPTYPE_VERYLARGEDESKTOP: ADLLARGEDESKTOPTYPE =
  2;
pub type ADLLARGEDESKTOPTYPE = ::std::os::raw::c_int;
pub const ADLPlatForm_GRAPHICS_PLATFORM_DESKTOP: ADLPlatForm = 0;
pub const ADLPlatForm_GRAPHICS_PLATFORM_MOBILE: ADLPlatForm = 1;
pub type ADLPlatForm = ::std::os::raw::c_int;
pub const ADLGraphicCoreGeneration_ADL_GRAPHIC_CORE_GENERATION_UNDEFINED:
  ADLGraphicCoreGeneration = 0;
pub const ADLGraphicCoreGeneration_ADL_GRAPHIC_CORE_GENERATION_PRE_GCN:
  ADLGraphicCoreGeneration = 1;
pub const ADLGraphicCoreGeneration_ADL_GRAPHIC_CORE_GENERATION_GCN:
  ADLGraphicCoreGeneration = 2;
pub const ADLGraphicCoreGeneration_ADL_GRAPHIC_CORE_GENERATION_RDNA:
  ADLGraphicCoreGeneration = 3;
pub type ADLGraphicCoreGeneration = ::std::os::raw::c_int;
pub const SLS_ImageCropType_Fit: SLS_ImageCropType = 1;
pub const SLS_ImageCropType_Fill: SLS_ImageCropType = 2;
pub const SLS_ImageCropType_Expand: SLS_ImageCropType = 3;
pub type SLS_ImageCropType = ::std::os::raw::c_int;
pub const DceSettingsType_DceSetting_HdmiLq: DceSettingsType = 0;
pub const DceSettingsType_DceSetting_DpSettings: DceSettingsType = 1;
pub const DceSettingsType_DceSetting_Protection: DceSettingsType = 2;
pub type DceSettingsType = ::std::os::raw::c_int;
pub const DpLinkRate_DPLinkRate_Unknown: DpLinkRate = 0;
pub const DpLinkRate_DPLinkRate_RBR: DpLinkRate = 1;
pub const DpLinkRate_DPLinkRate_2_16Gbps: DpLinkRate = 2;
pub const DpLinkRate_DPLinkRate_2_43Gbps: DpLinkRate = 3;
pub const DpLinkRate_DPLinkRate_HBR: DpLinkRate = 4;
pub const DpLinkRate_DPLinkRate_4_32Gbps: DpLinkRate = 5;
pub const DpLinkRate_DPLinkRate_HBR2: DpLinkRate = 6;
pub const DpLinkRate_DPLinkRate_HBR3: DpLinkRate = 7;
pub const DpLinkRate_DPLinkRate_UHBR10: DpLinkRate = 8;
pub const DpLinkRate_DPLinkRate_UHBR13D5: DpLinkRate = 9;
pub const DpLinkRate_DPLinkRate_UHBR20: DpLinkRate = 10;
pub type DpLinkRate = ::std::os::raw::c_int;
pub const ADLPXScheme_ADL_PX_SCHEME_INVALID: ADLPXScheme = 0;
pub const ADLPXScheme_ADL_PX_SCHEME_FIXED: ADLPXScheme = 1;
pub const ADLPXScheme_ADL_PX_SCHEME_DYNAMIC: ADLPXScheme = 2;
#[doc = " PX Schemes"]
pub type ADLPXScheme = ::std::os::raw::c_int;
pub const PXScheme_PX_SCHEME_INVALID: PXScheme = 0;
pub const PXScheme_PX_SCHEME_FIXED: PXScheme = 1;
pub const PXScheme_PX_SCHEME_DYNAMIC: PXScheme = 2;
#[doc = " Just keep the old definitions for compatibility, need to be removed later"]
pub type PXScheme = ::std::os::raw::c_int;
pub const ApplicationListType_ADL_PX40_MRU: ApplicationListType = 0;
pub const ApplicationListType_ADL_PX40_MISSED: ApplicationListType = 1;
pub const ApplicationListType_ADL_PX40_DISCRETE: ApplicationListType = 2;
pub const ApplicationListType_ADL_PX40_INTEGRATED: ApplicationListType = 3;
pub const ApplicationListType_ADL_MMD_PROFILED: ApplicationListType = 4;
pub const ApplicationListType_ADL_PX40_TOTAL: ApplicationListType = 5;
pub type ApplicationListType = ::std::os::raw::c_int;
pub const ADLProfilePropertyType_ADL_PROFILEPROPERTY_TYPE_BINARY: ADLProfilePropertyType =
  0;
pub const ADLProfilePropertyType_ADL_PROFILEPROPERTY_TYPE_BOOLEAN:
  ADLProfilePropertyType = 1;
pub const ADLProfilePropertyType_ADL_PROFILEPROPERTY_TYPE_DWORD: ADLProfilePropertyType =
  2;
pub const ADLProfilePropertyType_ADL_PROFILEPROPERTY_TYPE_QWORD: ADLProfilePropertyType =
  3;
pub const ADLProfilePropertyType_ADL_PROFILEPROPERTY_TYPE_ENUMERATED:
  ADLProfilePropertyType = 4;
pub const ADLProfilePropertyType_ADL_PROFILEPROPERTY_TYPE_STRING: ADLProfilePropertyType =
  5;
pub type ADLProfilePropertyType = ::std::os::raw::c_int;
pub const ADL_VIRTUALDISPLAY_TYPE_ADL_VIRTUALDISPLAY_NONE: ADL_VIRTUALDISPLAY_TYPE = 0;
pub const ADL_VIRTUALDISPLAY_TYPE_ADL_VIRTUALDISPLAY_XINPUT: ADL_VIRTUALDISPLAY_TYPE = 1;
pub const ADL_VIRTUALDISPLAY_TYPE_ADL_VIRTUALDISPLAY_REMOTEPLAY: ADL_VIRTUALDISPLAY_TYPE =
  2;
pub const ADL_VIRTUALDISPLAY_TYPE_ADL_VIRTUALDISPLAY_GENERIC: ADL_VIRTUALDISPLAY_TYPE =
  10;
pub type ADL_VIRTUALDISPLAY_TYPE = ::std::os::raw::c_int;
pub const ADLMultiChannelSplitStateFlag_ADLMultiChannelSplit_Unitialized:
  ADLMultiChannelSplitStateFlag = 0;
pub const ADLMultiChannelSplitStateFlag_ADLMultiChannelSplit_Disabled:
  ADLMultiChannelSplitStateFlag = 1;
pub const ADLMultiChannelSplitStateFlag_ADLMultiChannelSplit_Enabled:
  ADLMultiChannelSplitStateFlag = 2;
pub const ADLMultiChannelSplitStateFlag_ADLMultiChannelSplit_SaveProfile:
  ADLMultiChannelSplitStateFlag = 3;
pub type ADLMultiChannelSplitStateFlag = ::std::os::raw::c_int;
pub const ADLSampleRate_ADLSampleRate_32KHz: ADLSampleRate = 0;
pub const ADLSampleRate_ADLSampleRate_44P1KHz: ADLSampleRate = 1;
pub const ADLSampleRate_ADLSampleRate_48KHz: ADLSampleRate = 2;
pub const ADLSampleRate_ADLSampleRate_88P2KHz: ADLSampleRate = 3;
pub const ADLSampleRate_ADLSampleRate_96KHz: ADLSampleRate = 4;
pub const ADLSampleRate_ADLSampleRate_176P4KHz: ADLSampleRate = 5;
pub const ADLSampleRate_ADLSampleRate_192KHz: ADLSampleRate = 6;
pub const ADLSampleRate_ADLSampleRate_384KHz: ADLSampleRate = 7;
pub const ADLSampleRate_ADLSampleRate_768KHz: ADLSampleRate = 8;
pub const ADLSampleRate_ADLSampleRate_Undefined: ADLSampleRate = 9;
pub type ADLSampleRate = ::std::os::raw::c_int;
pub const ADLODNControlType_ODNControlType_Current: ADLODNControlType = 0;
pub const ADLODNControlType_ODNControlType_Default: ADLODNControlType = 1;
pub const ADLODNControlType_ODNControlType_Auto: ADLODNControlType = 2;
pub const ADLODNControlType_ODNControlType_Manual: ADLODNControlType = 3;
pub type ADLODNControlType = ::std::os::raw::c_int;
pub const ADLODNDPMMaskType_ADL_ODN_DPM_CLOCK: ADLODNDPMMaskType = 1;
pub const ADLODNDPMMaskType_ADL_ODN_DPM_VDDC: ADLODNDPMMaskType = 2;
pub const ADLODNDPMMaskType_ADL_ODN_DPM_MASK: ADLODNDPMMaskType = 4;
pub type ADLODNDPMMaskType = ::std::os::raw::c_int;
pub const ADLODNFeatureControl_ADL_ODN_SCLK_DPM: ADLODNFeatureControl = 1;
pub const ADLODNFeatureControl_ADL_ODN_MCLK_DPM: ADLODNFeatureControl = 2;
pub const ADLODNFeatureControl_ADL_ODN_SCLK_VDD: ADLODNFeatureControl = 4;
pub const ADLODNFeatureControl_ADL_ODN_MCLK_VDD: ADLODNFeatureControl = 8;
pub const ADLODNFeatureControl_ADL_ODN_FAN_SPEED_MIN: ADLODNFeatureControl = 16;
pub const ADLODNFeatureControl_ADL_ODN_FAN_SPEED_TARGET: ADLODNFeatureControl = 32;
pub const ADLODNFeatureControl_ADL_ODN_ACOUSTIC_LIMIT_SCLK: ADLODNFeatureControl = 64;
pub const ADLODNFeatureControl_ADL_ODN_TEMPERATURE_FAN_MAX: ADLODNFeatureControl = 128;
pub const ADLODNFeatureControl_ADL_ODN_TEMPERATURE_SYSTEM: ADLODNFeatureControl = 256;
pub const ADLODNFeatureControl_ADL_ODN_POWER_LIMIT: ADLODNFeatureControl = 512;
pub const ADLODNFeatureControl_ADL_ODN_SCLK_AUTO_LIMIT: ADLODNFeatureControl = 1024;
pub const ADLODNFeatureControl_ADL_ODN_MCLK_AUTO_LIMIT: ADLODNFeatureControl = 2048;
pub const ADLODNFeatureControl_ADL_ODN_SCLK_DPM_MASK_ENABLE: ADLODNFeatureControl = 4096;
pub const ADLODNFeatureControl_ADL_ODN_MCLK_DPM_MASK_ENABLE: ADLODNFeatureControl = 8192;
pub const ADLODNFeatureControl_ADL_ODN_MCLK_UNDERCLOCK_ENABLE: ADLODNFeatureControl =
  16384;
pub const ADLODNFeatureControl_ADL_ODN_SCLK_DPM_THROTTLE_NOTIFY: ADLODNFeatureControl =
  32768;
pub const ADLODNFeatureControl_ADL_ODN_POWER_UTILIZATION: ADLODNFeatureControl = 65536;
pub const ADLODNFeatureControl_ADL_ODN_PERF_TUNING_SLIDER: ADLODNFeatureControl = 131072;
pub const ADLODNFeatureControl_ADL_ODN_REMOVE_WATTMAN_PAGE: ADLODNFeatureControl =
  -2147483648;
pub type ADLODNFeatureControl = ::std::os::raw::c_int;
pub const ADLODNExtFeatureControl_ADL_ODN_EXT_FEATURE_MEMORY_TIMING_TUNE:
  ADLODNExtFeatureControl = 1;
pub const ADLODNExtFeatureControl_ADL_ODN_EXT_FEATURE_FAN_ZERO_RPM_CONTROL:
  ADLODNExtFeatureControl = 2;
pub const ADLODNExtFeatureControl_ADL_ODN_EXT_FEATURE_AUTO_UV_ENGINE:
  ADLODNExtFeatureControl = 4;
pub const ADLODNExtFeatureControl_ADL_ODN_EXT_FEATURE_AUTO_OC_ENGINE:
  ADLODNExtFeatureControl = 8;
pub const ADLODNExtFeatureControl_ADL_ODN_EXT_FEATURE_AUTO_OC_MEMORY:
  ADLODNExtFeatureControl = 16;
pub const ADLODNExtFeatureControl_ADL_ODN_EXT_FEATURE_FAN_CURVE: ADLODNExtFeatureControl =
  32;
pub type ADLODNExtFeatureControl = ::std::os::raw::c_int;
pub const ADLODNExtSettingId_ADL_ODN_PARAMETER_AC_TIMING: ADLODNExtSettingId = 0;
pub const ADLODNExtSettingId_ADL_ODN_PARAMETER_FAN_ZERO_RPM_CONTROL: ADLODNExtSettingId =
  1;
pub const ADLODNExtSettingId_ADL_ODN_PARAMETER_AUTO_UV_ENGINE: ADLODNExtSettingId = 2;
pub const ADLODNExtSettingId_ADL_ODN_PARAMETER_AUTO_OC_ENGINE: ADLODNExtSettingId = 3;
pub const ADLODNExtSettingId_ADL_ODN_PARAMETER_AUTO_OC_MEMORY: ADLODNExtSettingId = 4;
pub const ADLODNExtSettingId_ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_1:
  ADLODNExtSettingId = 5;
pub const ADLODNExtSettingId_ADL_ODN_PARAMETER_FAN_CURVE_SPEED_1: ADLODNExtSettingId = 6;
pub const ADLODNExtSettingId_ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_2:
  ADLODNExtSettingId = 7;
pub const ADLODNExtSettingId_ADL_ODN_PARAMETER_FAN_CURVE_SPEED_2: ADLODNExtSettingId = 8;
pub const ADLODNExtSettingId_ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_3:
  ADLODNExtSettingId = 9;
pub const ADLODNExtSettingId_ADL_ODN_PARAMETER_FAN_CURVE_SPEED_3: ADLODNExtSettingId = 10;
pub const ADLODNExtSettingId_ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_4:
  ADLODNExtSettingId = 11;
pub const ADLODNExtSettingId_ADL_ODN_PARAMETER_FAN_CURVE_SPEED_4: ADLODNExtSettingId = 12;
pub const ADLODNExtSettingId_ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_5:
  ADLODNExtSettingId = 13;
pub const ADLODNExtSettingId_ADL_ODN_PARAMETER_FAN_CURVE_SPEED_5: ADLODNExtSettingId = 14;
pub const ADLODNExtSettingId_ADL_ODN_POWERGAUGE: ADLODNExtSettingId = 15;
pub const ADLODNExtSettingId_ODN_COUNT: ADLODNExtSettingId = 16;
pub type ADLODNExtSettingId = ::std::os::raw::c_int;
pub const ADLOD8FeatureControl_ADL_OD8_GFXCLK_LIMITS: ADLOD8FeatureControl = 1;
pub const ADLOD8FeatureControl_ADL_OD8_GFXCLK_CURVE: ADLOD8FeatureControl = 2;
pub const ADLOD8FeatureControl_ADL_OD8_UCLK_MAX: ADLOD8FeatureControl = 4;
pub const ADLOD8FeatureControl_ADL_OD8_POWER_LIMIT: ADLOD8FeatureControl = 8;
pub const ADLOD8FeatureControl_ADL_OD8_ACOUSTIC_LIMIT_SCLK: ADLOD8FeatureControl = 16;
pub const ADLOD8FeatureControl_ADL_OD8_FAN_SPEED_MIN: ADLOD8FeatureControl = 32;
pub const ADLOD8FeatureControl_ADL_OD8_TEMPERATURE_FAN: ADLOD8FeatureControl = 64;
pub const ADLOD8FeatureControl_ADL_OD8_TEMPERATURE_SYSTEM: ADLOD8FeatureControl = 128;
pub const ADLOD8FeatureControl_ADL_OD8_MEMORY_TIMING_TUNE: ADLOD8FeatureControl = 256;
pub const ADLOD8FeatureControl_ADL_OD8_FAN_ZERO_RPM_CONTROL: ADLOD8FeatureControl = 512;
pub const ADLOD8FeatureControl_ADL_OD8_AUTO_UV_ENGINE: ADLOD8FeatureControl = 1024;
pub const ADLOD8FeatureControl_ADL_OD8_AUTO_OC_ENGINE: ADLOD8FeatureControl = 2048;
pub const ADLOD8FeatureControl_ADL_OD8_AUTO_OC_MEMORY: ADLOD8FeatureControl = 4096;
pub const ADLOD8FeatureControl_ADL_OD8_FAN_CURVE: ADLOD8FeatureControl = 8192;
pub const ADLOD8FeatureControl_ADL_OD8_WS_AUTO_FAN_ACOUSTIC_LIMIT: ADLOD8FeatureControl =
  16384;
pub const ADLOD8FeatureControl_ADL_OD8_GFXCLK_QUADRATIC_CURVE: ADLOD8FeatureControl =
  32768;
pub const ADLOD8FeatureControl_ADL_OD8_OPTIMIZED_GPU_POWER_MODE: ADLOD8FeatureControl =
  65536;
pub const ADLOD8FeatureControl_ADL_OD8_ODVOLTAGE_LIMIT: ADLOD8FeatureControl = 131072;
pub const ADLOD8FeatureControl_ADL_OD8_ADV_OC_LIMITS: ADLOD8FeatureControl = 262144;
pub const ADLOD8FeatureControl_ADL_OD8_PER_ZONE_GFX_VOLTAGE_OFFSET: ADLOD8FeatureControl =
  524288;
pub const ADLOD8FeatureControl_ADL_OD8_AUTO_CURVE_OPTIMIZER: ADLOD8FeatureControl =
  1048576;
pub const ADLOD8FeatureControl_ADL_OD8_GFX_VOLTAGE_LIMIT: ADLOD8FeatureControl = 2097152;
pub const ADLOD8FeatureControl_ADL_OD8_TDC_LIMIT: ADLOD8FeatureControl = 4194304;
pub const ADLOD8FeatureControl_ADL_OD8_FULL_CONTROL_MODE: ADLOD8FeatureControl = 8388608;
pub const ADLOD8FeatureControl_ADL_OD8_POWER_SAVING_FEATURE_CONTROL:
  ADLOD8FeatureControl = 16777216;
pub const ADLOD8FeatureControl_ADL_OD8_ACTIMING_PARAMETERS_TUNE: ADLOD8FeatureControl =
  33554432;
pub const ADLOD8FeatureControl_ADL_OD8_OVERDRIVE_INTERFACE: ADLOD8FeatureControl =
  67108864;
pub const ADLOD8FeatureControl_ADL_OD8_AUTO_UV_ENGINE_V2: ADLOD8FeatureControl =
  134217728;
pub const ADLOD8FeatureControl_ADL_OD8_POWER_GAUGE: ADLOD8FeatureControl = 268435456;
pub type ADLOD8FeatureControl = ::std::os::raw::c_int;
pub const ADLOD8SettingId_OD8_GFXCLK_FMAX: ADLOD8SettingId = 0;
pub const ADLOD8SettingId_OD8_GFXCLK_FMIN: ADLOD8SettingId = 1;
pub const ADLOD8SettingId_OD8_GFXCLK_FREQ1: ADLOD8SettingId = 2;
pub const ADLOD8SettingId_OD8_GFXCLK_VOLTAGE1: ADLOD8SettingId = 3;
pub const ADLOD8SettingId_OD8_GFXCLK_FREQ2: ADLOD8SettingId = 4;
pub const ADLOD8SettingId_OD8_GFXCLK_VOLTAGE2: ADLOD8SettingId = 5;
pub const ADLOD8SettingId_OD8_GFXCLK_FREQ3: ADLOD8SettingId = 6;
pub const ADLOD8SettingId_OD8_GFXCLK_VOLTAGE3: ADLOD8SettingId = 7;
pub const ADLOD8SettingId_OD8_UCLK_FMAX: ADLOD8SettingId = 8;
pub const ADLOD8SettingId_OD8_POWER_PERCENTAGE: ADLOD8SettingId = 9;
pub const ADLOD8SettingId_OD8_FAN_MIN_SPEED: ADLOD8SettingId = 10;
pub const ADLOD8SettingId_OD8_FAN_ACOUSTIC_LIMIT: ADLOD8SettingId = 11;
pub const ADLOD8SettingId_OD8_FAN_TARGET_TEMP: ADLOD8SettingId = 12;
pub const ADLOD8SettingId_OD8_OPERATING_TEMP_MAX: ADLOD8SettingId = 13;
pub const ADLOD8SettingId_OD8_AC_TIMING: ADLOD8SettingId = 14;
pub const ADLOD8SettingId_OD8_FAN_ZERORPM_CONTROL: ADLOD8SettingId = 15;
pub const ADLOD8SettingId_OD8_AUTO_UV_ENGINE_CONTROL: ADLOD8SettingId = 16;
pub const ADLOD8SettingId_OD8_AUTO_OC_ENGINE_CONTROL: ADLOD8SettingId = 17;
pub const ADLOD8SettingId_OD8_AUTO_OC_MEMORY_CONTROL: ADLOD8SettingId = 18;
pub const ADLOD8SettingId_OD8_FAN_CURVE_TEMPERATURE_1: ADLOD8SettingId = 19;
pub const ADLOD8SettingId_OD8_FAN_CURVE_SPEED_1: ADLOD8SettingId = 20;
pub const ADLOD8SettingId_OD8_FAN_CURVE_TEMPERATURE_2: ADLOD8SettingId = 21;
pub const ADLOD8SettingId_OD8_FAN_CURVE_SPEED_2: ADLOD8SettingId = 22;
pub const ADLOD8SettingId_OD8_FAN_CURVE_TEMPERATURE_3: ADLOD8SettingId = 23;
pub const ADLOD8SettingId_OD8_FAN_CURVE_SPEED_3: ADLOD8SettingId = 24;
pub const ADLOD8SettingId_OD8_FAN_CURVE_TEMPERATURE_4: ADLOD8SettingId = 25;
pub const ADLOD8SettingId_OD8_FAN_CURVE_SPEED_4: ADLOD8SettingId = 26;
pub const ADLOD8SettingId_OD8_FAN_CURVE_TEMPERATURE_5: ADLOD8SettingId = 27;
pub const ADLOD8SettingId_OD8_FAN_CURVE_SPEED_5: ADLOD8SettingId = 28;
pub const ADLOD8SettingId_OD8_WS_FAN_AUTO_FAN_ACOUSTIC_LIMIT: ADLOD8SettingId = 29;
pub const ADLOD8SettingId_OD8_GFXCLK_CURVE_COEFFICIENT_A: ADLOD8SettingId = 30;
pub const ADLOD8SettingId_OD8_GFXCLK_CURVE_COEFFICIENT_B: ADLOD8SettingId = 31;
pub const ADLOD8SettingId_OD8_GFXCLK_CURVE_COEFFICIENT_C: ADLOD8SettingId = 32;
pub const ADLOD8SettingId_OD8_GFXCLK_CURVE_VFT_FMIN: ADLOD8SettingId = 33;
pub const ADLOD8SettingId_OD8_UCLK_FMIN: ADLOD8SettingId = 34;
pub const ADLOD8SettingId_OD8_FAN_ZERO_RPM_STOP_TEMPERATURE: ADLOD8SettingId = 35;
pub const ADLOD8SettingId_OD8_OPTIMZED_POWER_MODE: ADLOD8SettingId = 36;
pub const ADLOD8SettingId_OD8_OD_VOLTAGE: ADLOD8SettingId = 37;
pub const ADLOD8SettingId_OD8_ADV_OC_LIMITS_SETTING: ADLOD8SettingId = 38;
pub const ADLOD8SettingId_OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_1: ADLOD8SettingId = 39;
pub const ADLOD8SettingId_OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_2: ADLOD8SettingId = 40;
pub const ADLOD8SettingId_OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_3: ADLOD8SettingId = 41;
pub const ADLOD8SettingId_OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_4: ADLOD8SettingId = 42;
pub const ADLOD8SettingId_OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_5: ADLOD8SettingId = 43;
pub const ADLOD8SettingId_OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_6: ADLOD8SettingId = 44;
pub const ADLOD8SettingId_OD8_AUTO_CURVE_OPTIMIZER_SETTING: ADLOD8SettingId = 45;
pub const ADLOD8SettingId_OD8_GFX_VOLTAGE_LIMIT_SETTING: ADLOD8SettingId = 46;
pub const ADLOD8SettingId_OD8_TDC_PERCENTAGE: ADLOD8SettingId = 47;
pub const ADLOD8SettingId_OD8_FULL_CONTROL_MODE_SETTING: ADLOD8SettingId = 48;
pub const ADLOD8SettingId_OD8_FULL_CONTROL_MODE_GFXCLK: ADLOD8SettingId = 49;
pub const ADLOD8SettingId_OD8_FULL_CONTROL_MODE_UCLK: ADLOD8SettingId = 50;
pub const ADLOD8SettingId_OD8_IDLE_POWER_SAVING_FEATURE_CONTROL: ADLOD8SettingId = 51;
pub const ADLOD8SettingId_OD8_RUNTIME_POWER_SAVING_FEATURE_CONTROL: ADLOD8SettingId = 52;
pub const ADLOD8SettingId_OD8_FULL_CONTROL_MODE_FEATURE_CONTROL: ADLOD8SettingId = 53;
pub const ADLOD8SettingId_OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_FREQ_ANCHOR_1: ADLOD8SettingId =
  54;
pub const ADLOD8SettingId_OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_FREQ_ANCHOR_2: ADLOD8SettingId =
  55;
pub const ADLOD8SettingId_OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_FREQ_ANCHOR_3: ADLOD8SettingId =
  56;
pub const ADLOD8SettingId_OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_FREQ_ANCHOR_4: ADLOD8SettingId =
  57;
pub const ADLOD8SettingId_OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_FREQ_ANCHOR_5: ADLOD8SettingId =
  58;
pub const ADLOD8SettingId_OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_FREQ_ANCHOR_6: ADLOD8SettingId =
  59;
pub const ADLOD8SettingId_OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_VOLTAGE_LIMIT: ADLOD8SettingId =
  60;
pub const ADLOD8SettingId_OD8_ACTIMING_PARAMETER_TRRDS: ADLOD8SettingId = 61;
pub const ADLOD8SettingId_OD8_ACTIMING_PARAMETER_TCL: ADLOD8SettingId = 62;
pub const ADLOD8SettingId_OD8_ACTIMING_PARAMETER_TCWL: ADLOD8SettingId = 63;
pub const ADLOD8SettingId_OD8_ACTIMING_PARAMETER_TRCDRD: ADLOD8SettingId = 64;
pub const ADLOD8SettingId_OD8_ACTIMING_PARAMETER_TRCDWR: ADLOD8SettingId = 65;
pub const ADLOD8SettingId_OD8_ACTIMING_PARAMETER_TRAS: ADLOD8SettingId = 66;
pub const ADLOD8SettingId_OD8_ACTIMING_PARAMETER_TRPAB: ADLOD8SettingId = 67;
pub const ADLOD8SettingId_OD8_ACTIMING_PARAMETER_TRFC: ADLOD8SettingId = 68;
pub const ADLOD8SettingId_OD8_ACTIMING_PARAMETER_TRFCPB: ADLOD8SettingId = 69;
pub const ADLOD8SettingId_OD8_ACTIMING_PARAMETER_TRREFD: ADLOD8SettingId = 70;
pub const ADLOD8SettingId_OD8_ACTIMING_PARAMETER_TREF: ADLOD8SettingId = 71;
pub const ADLOD8SettingId_OD8_ACTIMING_PARAMETER_TWR: ADLOD8SettingId = 72;
pub const ADLOD8SettingId_OD8_ACTIMING_PARAMETER_TWTRS: ADLOD8SettingId = 73;
pub const ADLOD8SettingId_OD8_OVERDRIVE_INTERFACE_ID: ADLOD8SettingId = 74;
pub const ADLOD8SettingId_OD8_AUTO_UV_ENGINE_V2_ID: ADLOD8SettingId = 75;
pub const ADLOD8SettingId_OD8_POWER_GAUGE: ADLOD8SettingId = 76;
pub const ADLOD8SettingId_OD8_COUNT: ADLOD8SettingId = 77;
pub type ADLOD8SettingId = ::std::os::raw::c_int;
pub const ADLSensorType_SENSOR_MAXTYPES: ADLSensorType = 0;
pub const ADLSensorType_PMLOG_CLK_GFXCLK: ADLSensorType = 1;
pub const ADLSensorType_PMLOG_CLK_MEMCLK: ADLSensorType = 2;
pub const ADLSensorType_PMLOG_CLK_SOCCLK: ADLSensorType = 3;
pub const ADLSensorType_PMLOG_CLK_UVDCLK1: ADLSensorType = 4;
pub const ADLSensorType_PMLOG_CLK_UVDCLK2: ADLSensorType = 5;
pub const ADLSensorType_PMLOG_CLK_VCECLK: ADLSensorType = 6;
pub const ADLSensorType_PMLOG_CLK_VCNCLK: ADLSensorType = 7;
pub const ADLSensorType_PMLOG_TEMPERATURE_EDGE: ADLSensorType = 8;
pub const ADLSensorType_PMLOG_TEMPERATURE_MEM: ADLSensorType = 9;
pub const ADLSensorType_PMLOG_TEMPERATURE_VRVDDC: ADLSensorType = 10;
pub const ADLSensorType_PMLOG_TEMPERATURE_VRMVDD: ADLSensorType = 11;
pub const ADLSensorType_PMLOG_TEMPERATURE_LIQUID: ADLSensorType = 12;
pub const ADLSensorType_PMLOG_TEMPERATURE_PLX: ADLSensorType = 13;
pub const ADLSensorType_PMLOG_FAN_RPM: ADLSensorType = 14;
pub const ADLSensorType_PMLOG_FAN_PERCENTAGE: ADLSensorType = 15;
pub const ADLSensorType_PMLOG_SOC_VOLTAGE: ADLSensorType = 16;
pub const ADLSensorType_PMLOG_SOC_POWER: ADLSensorType = 17;
pub const ADLSensorType_PMLOG_SOC_CURRENT: ADLSensorType = 18;
pub const ADLSensorType_PMLOG_INFO_ACTIVITY_GFX: ADLSensorType = 19;
pub const ADLSensorType_PMLOG_INFO_ACTIVITY_MEM: ADLSensorType = 20;
pub const ADLSensorType_PMLOG_GFX_VOLTAGE: ADLSensorType = 21;
pub const ADLSensorType_PMLOG_MEM_VOLTAGE: ADLSensorType = 22;
pub const ADLSensorType_PMLOG_ASIC_POWER: ADLSensorType = 23;
pub const ADLSensorType_PMLOG_TEMPERATURE_VRSOC: ADLSensorType = 24;
pub const ADLSensorType_PMLOG_TEMPERATURE_VRMVDD0: ADLSensorType = 25;
pub const ADLSensorType_PMLOG_TEMPERATURE_VRMVDD1: ADLSensorType = 26;
pub const ADLSensorType_PMLOG_TEMPERATURE_HOTSPOT: ADLSensorType = 27;
pub const ADLSensorType_PMLOG_TEMPERATURE_GFX: ADLSensorType = 28;
pub const ADLSensorType_PMLOG_TEMPERATURE_SOC: ADLSensorType = 29;
pub const ADLSensorType_PMLOG_GFX_POWER: ADLSensorType = 30;
pub const ADLSensorType_PMLOG_GFX_CURRENT: ADLSensorType = 31;
pub const ADLSensorType_PMLOG_TEMPERATURE_CPU: ADLSensorType = 32;
pub const ADLSensorType_PMLOG_CPU_POWER: ADLSensorType = 33;
pub const ADLSensorType_PMLOG_CLK_CPUCLK: ADLSensorType = 34;
pub const ADLSensorType_PMLOG_THROTTLER_STATUS: ADLSensorType = 35;
pub const ADLSensorType_PMLOG_CLK_VCN1CLK1: ADLSensorType = 36;
pub const ADLSensorType_PMLOG_CLK_VCN1CLK2: ADLSensorType = 37;
pub const ADLSensorType_PMLOG_SMART_POWERSHIFT_CPU: ADLSensorType = 38;
pub const ADLSensorType_PMLOG_SMART_POWERSHIFT_DGPU: ADLSensorType = 39;
pub const ADLSensorType_PMLOG_BUS_SPEED: ADLSensorType = 40;
pub const ADLSensorType_PMLOG_BUS_LANES: ADLSensorType = 41;
pub const ADLSensorType_PMLOG_TEMPERATURE_LIQUID0: ADLSensorType = 42;
pub const ADLSensorType_PMLOG_TEMPERATURE_LIQUID1: ADLSensorType = 43;
pub const ADLSensorType_PMLOG_CLK_FCLK: ADLSensorType = 44;
pub const ADLSensorType_PMLOG_THROTTLER_STATUS_CPU: ADLSensorType = 45;
pub const ADLSensorType_PMLOG_SSPAIRED_ASICPOWER: ADLSensorType = 46;
pub const ADLSensorType_PMLOG_SSTOTAL_POWERLIMIT: ADLSensorType = 47;
pub const ADLSensorType_PMLOG_SSAPU_POWERLIMIT: ADLSensorType = 48;
pub const ADLSensorType_PMLOG_SSDGPU_POWERLIMIT: ADLSensorType = 49;
pub const ADLSensorType_PMLOG_TEMPERATURE_HOTSPOT_GCD: ADLSensorType = 50;
pub const ADLSensorType_PMLOG_TEMPERATURE_HOTSPOT_MCD: ADLSensorType = 51;
pub const ADLSensorType_PMLOG_THROTTLE_PERCENTAGE_TEMP_GFX: ADLSensorType = 52;
pub const ADLSensorType_PMLOG_THROTTLE_PERCENTAGE_TEMP_MEM: ADLSensorType = 53;
pub const ADLSensorType_PMLOG_THROTTLE_PERCENTAGE_TEMP_VR: ADLSensorType = 54;
pub const ADLSensorType_PMLOG_THROTTLE_PERCENTAGE_POWER: ADLSensorType = 55;
pub const ADLSensorType_PMLOG_THROTTLE_PERCENTAGE_TDC: ADLSensorType = 56;
pub const ADLSensorType_PMLOG_THROTTLE_PERCENTAGE_VMAX: ADLSensorType = 57;
pub const ADLSensorType_PMLOG_BUS_CURR_MAX_SPEED: ADLSensorType = 58;
pub const ADLSensorType_PMLOG_RESERVED_1: ADLSensorType = 59;
pub const ADLSensorType_PMLOG_RESERVED_2: ADLSensorType = 60;
pub const ADLSensorType_PMLOG_RESERVED_3: ADLSensorType = 61;
pub const ADLSensorType_PMLOG_RESERVED_4: ADLSensorType = 62;
pub const ADLSensorType_PMLOG_RESERVED_5: ADLSensorType = 63;
pub const ADLSensorType_PMLOG_RESERVED_6: ADLSensorType = 64;
pub const ADLSensorType_PMLOG_RESERVED_7: ADLSensorType = 65;
pub const ADLSensorType_PMLOG_RESERVED_8: ADLSensorType = 66;
pub const ADLSensorType_PMLOG_RESERVED_9: ADLSensorType = 67;
pub const ADLSensorType_PMLOG_RESERVED_10: ADLSensorType = 68;
pub const ADLSensorType_PMLOG_RESERVED_11: ADLSensorType = 69;
pub const ADLSensorType_PMLOG_RESERVED_12: ADLSensorType = 70;
pub const ADLSensorType_PMLOG_RESERVED_13: ADLSensorType = 71;
pub const ADLSensorType_PMLOG_RESERVED_14: ADLSensorType = 72;
pub const ADLSensorType_PMLOG_BOARD_POWER: ADLSensorType = 73;
pub const ADLSensorType_PMLOG_MAX_SENSORS_REAL: ADLSensorType = 74;
#[doc = " \\deprecated Replaced with ADL_PMLOG_SENSORS"]
pub type ADLSensorType = ::std::os::raw::c_int;
pub const ADL_THROTTLE_NOTIFICATION_ADL_PMLOG_THROTTLE_POWER: ADL_THROTTLE_NOTIFICATION =
  1;
pub const ADL_THROTTLE_NOTIFICATION_ADL_PMLOG_THROTTLE_THERMAL:
  ADL_THROTTLE_NOTIFICATION = 2;
pub const ADL_THROTTLE_NOTIFICATION_ADL_PMLOG_THROTTLE_CURRENT:
  ADL_THROTTLE_NOTIFICATION = 4;
pub type ADL_THROTTLE_NOTIFICATION = ::std::os::raw::c_int;
pub const ADL_PMLOG_SENSORS_ADL_SENSOR_MAXTYPES: ADL_PMLOG_SENSORS = 0;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_CLK_GFXCLK: ADL_PMLOG_SENSORS = 1;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_CLK_MEMCLK: ADL_PMLOG_SENSORS = 2;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_CLK_SOCCLK: ADL_PMLOG_SENSORS = 3;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_CLK_UVDCLK1: ADL_PMLOG_SENSORS = 4;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_CLK_UVDCLK2: ADL_PMLOG_SENSORS = 5;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_CLK_VCECLK: ADL_PMLOG_SENSORS = 6;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_CLK_VCNCLK: ADL_PMLOG_SENSORS = 7;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_TEMPERATURE_EDGE: ADL_PMLOG_SENSORS = 8;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_TEMPERATURE_MEM: ADL_PMLOG_SENSORS = 9;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_TEMPERATURE_VRVDDC: ADL_PMLOG_SENSORS = 10;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_TEMPERATURE_VRMVDD: ADL_PMLOG_SENSORS = 11;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_TEMPERATURE_LIQUID: ADL_PMLOG_SENSORS = 12;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_TEMPERATURE_PLX: ADL_PMLOG_SENSORS = 13;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_FAN_RPM: ADL_PMLOG_SENSORS = 14;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_FAN_PERCENTAGE: ADL_PMLOG_SENSORS = 15;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_SOC_VOLTAGE: ADL_PMLOG_SENSORS = 16;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_SOC_POWER: ADL_PMLOG_SENSORS = 17;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_SOC_CURRENT: ADL_PMLOG_SENSORS = 18;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_INFO_ACTIVITY_GFX: ADL_PMLOG_SENSORS = 19;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_INFO_ACTIVITY_MEM: ADL_PMLOG_SENSORS = 20;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_GFX_VOLTAGE: ADL_PMLOG_SENSORS = 21;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_MEM_VOLTAGE: ADL_PMLOG_SENSORS = 22;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_ASIC_POWER: ADL_PMLOG_SENSORS = 23;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_TEMPERATURE_VRSOC: ADL_PMLOG_SENSORS = 24;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_TEMPERATURE_VRMVDD0: ADL_PMLOG_SENSORS = 25;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_TEMPERATURE_VRMVDD1: ADL_PMLOG_SENSORS = 26;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_TEMPERATURE_HOTSPOT: ADL_PMLOG_SENSORS = 27;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_TEMPERATURE_GFX: ADL_PMLOG_SENSORS = 28;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_TEMPERATURE_SOC: ADL_PMLOG_SENSORS = 29;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_GFX_POWER: ADL_PMLOG_SENSORS = 30;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_GFX_CURRENT: ADL_PMLOG_SENSORS = 31;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_TEMPERATURE_CPU: ADL_PMLOG_SENSORS = 32;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_CPU_POWER: ADL_PMLOG_SENSORS = 33;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_CLK_CPUCLK: ADL_PMLOG_SENSORS = 34;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_THROTTLER_STATUS: ADL_PMLOG_SENSORS = 35;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_CLK_VCN1CLK1: ADL_PMLOG_SENSORS = 36;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_CLK_VCN1CLK2: ADL_PMLOG_SENSORS = 37;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_SMART_POWERSHIFT_CPU: ADL_PMLOG_SENSORS = 38;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_SMART_POWERSHIFT_DGPU: ADL_PMLOG_SENSORS = 39;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_BUS_SPEED: ADL_PMLOG_SENSORS = 40;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_BUS_LANES: ADL_PMLOG_SENSORS = 41;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_TEMPERATURE_LIQUID0: ADL_PMLOG_SENSORS = 42;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_TEMPERATURE_LIQUID1: ADL_PMLOG_SENSORS = 43;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_CLK_FCLK: ADL_PMLOG_SENSORS = 44;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_THROTTLER_STATUS_CPU: ADL_PMLOG_SENSORS = 45;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_SSPAIRED_ASICPOWER: ADL_PMLOG_SENSORS = 46;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_SSTOTAL_POWERLIMIT: ADL_PMLOG_SENSORS = 47;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_SSAPU_POWERLIMIT: ADL_PMLOG_SENSORS = 48;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_SSDGPU_POWERLIMIT: ADL_PMLOG_SENSORS = 49;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_TEMPERATURE_HOTSPOT_GCD: ADL_PMLOG_SENSORS = 50;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_TEMPERATURE_HOTSPOT_MCD: ADL_PMLOG_SENSORS = 51;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_THROTTLE_PERCENTAGE_TEMP_GFX: ADL_PMLOG_SENSORS =
  52;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_THROTTLE_PERCENTAGE_TEMP_MEM: ADL_PMLOG_SENSORS =
  53;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_THROTTLE_PERCENTAGE_TEMP_VR: ADL_PMLOG_SENSORS = 54;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_THROTTLE_PERCENTAGE_POWER: ADL_PMLOG_SENSORS = 55;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_THROTTLE_PERCENTAGE_TDC: ADL_PMLOG_SENSORS = 56;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_THROTTLE_PERCENTAGE_VMAX: ADL_PMLOG_SENSORS = 57;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_BUS_CURR_MAX_SPEED: ADL_PMLOG_SENSORS = 58;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_RESERVED_1: ADL_PMLOG_SENSORS = 59;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_RESERVED_2: ADL_PMLOG_SENSORS = 60;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_RESERVED_3: ADL_PMLOG_SENSORS = 61;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_RESERVED_4: ADL_PMLOG_SENSORS = 62;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_RESERVED_5: ADL_PMLOG_SENSORS = 63;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_RESERVED_6: ADL_PMLOG_SENSORS = 64;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_RESERVED_7: ADL_PMLOG_SENSORS = 65;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_RESERVED_8: ADL_PMLOG_SENSORS = 66;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_RESERVED_9: ADL_PMLOG_SENSORS = 67;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_RESERVED_10: ADL_PMLOG_SENSORS = 68;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_RESERVED_11: ADL_PMLOG_SENSORS = 69;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_RESERVED_12: ADL_PMLOG_SENSORS = 70;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_CLK_NPUCLK: ADL_PMLOG_SENSORS = 71;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_NPU_BUSY_AVG: ADL_PMLOG_SENSORS = 72;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_BOARD_POWER: ADL_PMLOG_SENSORS = 73;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_TEMPERATURE_INTAKE: ADL_PMLOG_SENSORS = 74;
pub const ADL_PMLOG_SENSORS_ADL_PMLOG_MAX_SENSORS_REAL: ADL_PMLOG_SENSORS = 75;
pub type ADL_PMLOG_SENSORS = ::std::os::raw::c_int;
#[doc = " \\defgroup define_D3DKMT_HANDLE\n @{\n Handle can be used to create Device Handle when using CreateDevice()"]
pub type ADL_D3DKMT_HANDLE = ::std::os::raw::c_uint;
pub const ADL_RAS_ERROR_INJECTION_MODE_ADL_RAS_ERROR_INJECTION_MODE_SINGLE:
  ADL_RAS_ERROR_INJECTION_MODE = 1;
pub const ADL_RAS_ERROR_INJECTION_MODE_ADL_RAS_ERROR_INJECTION_MODE_MULTIPLE:
  ADL_RAS_ERROR_INJECTION_MODE = 2;
#[doc = " @}"]
pub type ADL_RAS_ERROR_INJECTION_MODE = ::std::os::raw::c_int;
pub const ADL_RAS_BLOCK_ID_ADL_RAS_BLOCK_ID_UMC: ADL_RAS_BLOCK_ID = 0;
pub const ADL_RAS_BLOCK_ID_ADL_RAS_BLOCK_ID_SDMA: ADL_RAS_BLOCK_ID = 1;
pub const ADL_RAS_BLOCK_ID_ADL_RAS_BLOCK_ID_GFX_HUB: ADL_RAS_BLOCK_ID = 2;
pub const ADL_RAS_BLOCK_ID_ADL_RAS_BLOCK_ID_MMHUB: ADL_RAS_BLOCK_ID = 3;
pub const ADL_RAS_BLOCK_ID_ADL_RAS_BLOCK_ID_ATHUB: ADL_RAS_BLOCK_ID = 4;
pub const ADL_RAS_BLOCK_ID_ADL_RAS_BLOCK_ID_PCIE_BIF: ADL_RAS_BLOCK_ID = 5;
pub const ADL_RAS_BLOCK_ID_ADL_RAS_BLOCK_ID_HDP: ADL_RAS_BLOCK_ID = 6;
pub const ADL_RAS_BLOCK_ID_ADL_RAS_BLOCK_ID_XGMI_WAFL: ADL_RAS_BLOCK_ID = 7;
pub const ADL_RAS_BLOCK_ID_ADL_RAS_BLOCK_ID_DF: ADL_RAS_BLOCK_ID = 8;
pub const ADL_RAS_BLOCK_ID_ADL_RAS_BLOCK_ID_SMN: ADL_RAS_BLOCK_ID = 9;
pub const ADL_RAS_BLOCK_ID_ADL_RAS_BLOCK_ID_SEM: ADL_RAS_BLOCK_ID = 10;
pub const ADL_RAS_BLOCK_ID_ADL_RAS_BLOCK_ID_MP0: ADL_RAS_BLOCK_ID = 11;
pub const ADL_RAS_BLOCK_ID_ADL_RAS_BLOCK_ID_MP1: ADL_RAS_BLOCK_ID = 12;
pub const ADL_RAS_BLOCK_ID_ADL_RAS_BLOCK_ID_FUSE: ADL_RAS_BLOCK_ID = 13;
pub type ADL_RAS_BLOCK_ID = ::std::os::raw::c_int;
pub const ADL_MEM_SUB_BLOCK_ID_ADL_RAS__UMC_HBM: ADL_MEM_SUB_BLOCK_ID = 0;
pub const ADL_MEM_SUB_BLOCK_ID_ADL_RAS__UMC_SRAM: ADL_MEM_SUB_BLOCK_ID = 1;
pub type ADL_MEM_SUB_BLOCK_ID = ::std::os::raw::c_int;
pub const _ADL_RAS_ERROR_TYPE_ADL_RAS_ERROR__NONE: _ADL_RAS_ERROR_TYPE = 0;
pub const _ADL_RAS_ERROR_TYPE_ADL_RAS_ERROR__PARITY: _ADL_RAS_ERROR_TYPE = 1;
pub const _ADL_RAS_ERROR_TYPE_ADL_RAS_ERROR__SINGLE_CORRECTABLE: _ADL_RAS_ERROR_TYPE = 2;
pub const _ADL_RAS_ERROR_TYPE_ADL_RAS_ERROR__PARITY_SINGLE_CORRECTABLE:
  _ADL_RAS_ERROR_TYPE = 3;
pub const _ADL_RAS_ERROR_TYPE_ADL_RAS_ERROR__MULTI_UNCORRECTABLE: _ADL_RAS_ERROR_TYPE = 4;
pub const _ADL_RAS_ERROR_TYPE_ADL_RAS_ERROR__PARITY_MULTI_UNCORRECTABLE:
  _ADL_RAS_ERROR_TYPE = 5;
pub const _ADL_RAS_ERROR_TYPE_ADL_RAS_ERROR__SINGLE_CORRECTABLE_MULTI_UNCORRECTABLE:
  _ADL_RAS_ERROR_TYPE = 6;
pub const _ADL_RAS_ERROR_TYPE_ADL_RAS_ERROR__PARITY_SINGLE_CORRECTABLE_MULTI_UNCORRECTABLE : _ADL_RAS_ERROR_TYPE = 7 ;
pub const _ADL_RAS_ERROR_TYPE_ADL_RAS_ERROR__POISON: _ADL_RAS_ERROR_TYPE = 8;
pub const _ADL_RAS_ERROR_TYPE_ADL_RAS_ERROR__PARITY_POISON: _ADL_RAS_ERROR_TYPE = 9;
pub const _ADL_RAS_ERROR_TYPE_ADL_RAS_ERROR__SINGLE_CORRECTABLE_POISON:
  _ADL_RAS_ERROR_TYPE = 10;
pub const _ADL_RAS_ERROR_TYPE_ADL_RAS_ERROR__PARITY_SINGLE_CORRECTABLE_POISON:
  _ADL_RAS_ERROR_TYPE = 11;
pub const _ADL_RAS_ERROR_TYPE_ADL_RAS_ERROR__MULTI_UNCORRECTABLE_POISON:
  _ADL_RAS_ERROR_TYPE = 12;
pub const _ADL_RAS_ERROR_TYPE_ADL_RAS_ERROR__PARITY_MULTI_UNCORRECTABLE_POISON:
  _ADL_RAS_ERROR_TYPE = 13;
pub const _ADL_RAS_ERROR_TYPE_ADL_RAS_ERROR__SINGLE_CORRECTABLE_MULTI_UNCORRECTABLE_POISON : _ADL_RAS_ERROR_TYPE = 14 ;
pub const _ADL_RAS_ERROR_TYPE_ADL_RAS_ERROR__PARITY_SINGLE_CORRECTABLE_MULTI_UNCORRECTABLE_POISON : _ADL_RAS_ERROR_TYPE = 15 ;
pub type _ADL_RAS_ERROR_TYPE = ::std::os::raw::c_int;
pub use self::_ADL_RAS_ERROR_TYPE as ADL_RAS_ERROR_TYPE;
pub const ADL_RAS_INJECTION_METHOD_ADL_RAS_ERROR__UMC_METH_COHERENT:
  ADL_RAS_INJECTION_METHOD = 0;
pub const ADL_RAS_INJECTION_METHOD_ADL_RAS_ERROR__UMC_METH_SINGLE_SHOT:
  ADL_RAS_INJECTION_METHOD = 1;
pub const ADL_RAS_INJECTION_METHOD_ADL_RAS_ERROR__UMC_METH_PERSISTENT:
  ADL_RAS_INJECTION_METHOD = 2;
pub const ADL_RAS_INJECTION_METHOD_ADL_RAS_ERROR__UMC_METH_PERSISTENT_DISABLE:
  ADL_RAS_INJECTION_METHOD = 3;
pub type ADL_RAS_INJECTION_METHOD = ::std::os::raw::c_int;
pub const ADL_DRIVER_EVENT_TYPE_ADL_EVENT_ID_AUTO_FEATURE_COMPLETED:
  ADL_DRIVER_EVENT_TYPE = 30;
pub const ADL_DRIVER_EVENT_TYPE_ADL_EVENT_ID_FEATURE_AVAILABILITY: ADL_DRIVER_EVENT_TYPE =
  31;
pub type ADL_DRIVER_EVENT_TYPE = ::std::os::raw::c_int;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_DVR: ADL_UIFEATURES_GROUP = 0;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_TURBOSYNC: ADL_UIFEATURES_GROUP = 1;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_FRAMEMETRICSMONITOR:
  ADL_UIFEATURES_GROUP = 2;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_FRTC: ADL_UIFEATURES_GROUP = 3;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_XVISION: ADL_UIFEATURES_GROUP = 4;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_BLOCKCHAIN: ADL_UIFEATURES_GROUP = 5;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_GAMEINTELLIGENCE:
  ADL_UIFEATURES_GROUP = 6;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_CHILL: ADL_UIFEATURES_GROUP = 7;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_DELAG: ADL_UIFEATURES_GROUP = 8;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_BOOST: ADL_UIFEATURES_GROUP = 9;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_USU: ADL_UIFEATURES_GROUP = 10;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_XGMI: ADL_UIFEATURES_GROUP = 11;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_PROVSR: ADL_UIFEATURES_GROUP = 12;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_SMA: ADL_UIFEATURES_GROUP = 13;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_CAMERA: ADL_UIFEATURES_GROUP = 14;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_FRTCPRO: ADL_UIFEATURES_GROUP = 15;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_DELAGNEXT: ADL_UIFEATURES_GROUP = 16;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_RTBOOST: ADL_UIFEATURES_GROUP = 17;
pub const ADL_UIFEATURES_GROUP_ADL_UIFEATURES_GROUP_UAI: ADL_UIFEATURES_GROUP = 18;
pub type ADL_UIFEATURES_GROUP = ::std::os::raw::c_int;
pub const ADL_RADEON_USB_LED_BAR_CONTROLS_RadeonLEDBarControl_OFF:
  ADL_RADEON_USB_LED_BAR_CONTROLS = 0;
pub const ADL_RADEON_USB_LED_BAR_CONTROLS_RadeonLEDBarControl_Static:
  ADL_RADEON_USB_LED_BAR_CONTROLS = 1;
pub const ADL_RADEON_USB_LED_BAR_CONTROLS_RadeonLEDBarControl_Rainbow:
  ADL_RADEON_USB_LED_BAR_CONTROLS = 2;
pub const ADL_RADEON_USB_LED_BAR_CONTROLS_RadeonLEDBarControl_Swirl:
  ADL_RADEON_USB_LED_BAR_CONTROLS = 3;
pub const ADL_RADEON_USB_LED_BAR_CONTROLS_RadeonLEDBarControl_Chase:
  ADL_RADEON_USB_LED_BAR_CONTROLS = 4;
pub const ADL_RADEON_USB_LED_BAR_CONTROLS_RadeonLEDBarControl_Bounce:
  ADL_RADEON_USB_LED_BAR_CONTROLS = 5;
pub const ADL_RADEON_USB_LED_BAR_CONTROLS_RadeonLEDBarControl_MorseCode:
  ADL_RADEON_USB_LED_BAR_CONTROLS = 6;
pub const ADL_RADEON_USB_LED_BAR_CONTROLS_RadeonLEDBarControl_ColorCycle:
  ADL_RADEON_USB_LED_BAR_CONTROLS = 7;
pub const ADL_RADEON_USB_LED_BAR_CONTROLS_RadeonLEDBarControl_Breathing:
  ADL_RADEON_USB_LED_BAR_CONTROLS = 8;
pub const ADL_RADEON_USB_LED_BAR_CONTROLS_RadeonLEDBarControl_CustomPattern:
  ADL_RADEON_USB_LED_BAR_CONTROLS = 9;
pub const ADL_RADEON_USB_LED_BAR_CONTROLS_RadeonLEDBarControl_MAX:
  ADL_RADEON_USB_LED_BAR_CONTROLS = 10;
#[doc = "\n\\brief\n\n\n\n\n \\nosubgrouping\n"]
pub type ADL_RADEON_USB_LED_BAR_CONTROLS = ::std::os::raw::c_int;
#[doc = "\n\\brief\n\n\n\n\n \\nosubgrouping\n"]
pub type RadeonLEDBARSupportedControl = ::std::os::raw::c_uint;
pub const ADL_RADEON_USB_LED_CONTROL_CONFIGS_RadeonLEDPattern_Speed:
  ADL_RADEON_USB_LED_CONTROL_CONFIGS = 0;
pub const ADL_RADEON_USB_LED_CONTROL_CONFIGS_RadeonLEDPattern_Brightness:
  ADL_RADEON_USB_LED_CONTROL_CONFIGS = 1;
pub const ADL_RADEON_USB_LED_CONTROL_CONFIGS_RadeonLEDPattern_Direction:
  ADL_RADEON_USB_LED_CONTROL_CONFIGS = 2;
pub const ADL_RADEON_USB_LED_CONTROL_CONFIGS_RadeonLEDPattern_Color:
  ADL_RADEON_USB_LED_CONTROL_CONFIGS = 3;
pub const ADL_RADEON_USB_LED_CONTROL_CONFIGS_RadeonLEDPattern_MAX:
  ADL_RADEON_USB_LED_CONTROL_CONFIGS = 4;
#[doc = "\n\\brief\n\n\n\n\n \\nosubgrouping\n"]
pub type ADL_RADEON_USB_LED_CONTROL_CONFIGS = ::std::os::raw::c_int;
#[doc = "\n\\brief\n\n\n\n\n \\nosubgrouping\n"]
pub type RadeonLEDBARSupportedConfig = ::std::os::raw::c_uint;
pub const ADL_USER_SETTINGS_ADL_USER_SETTINGS_ENHANCEDSYNC: ADL_USER_SETTINGS = 1;
pub const ADL_USER_SETTINGS_ADL_USER_SETTINGS_CHILL_PROFILE: ADL_USER_SETTINGS = 2;
pub const ADL_USER_SETTINGS_ADL_USER_SETTINGS_DELAG_PROFILE: ADL_USER_SETTINGS = 4;
pub const ADL_USER_SETTINGS_ADL_USER_SETTINGS_BOOST_PROFILE: ADL_USER_SETTINGS = 8;
pub const ADL_USER_SETTINGS_ADL_USER_SETTINGS_USU_PROFILE: ADL_USER_SETTINGS = 16;
pub const ADL_USER_SETTINGS_ADL_USER_SETTINGS_CVDC_PROFILE: ADL_USER_SETTINGS = 32;
pub const ADL_USER_SETTINGS_ADL_USER_SETTINGS_SCE_PROFILE: ADL_USER_SETTINGS = 64;
pub const ADL_USER_SETTINGS_ADL_USER_SETTINGS_PROVSR: ADL_USER_SETTINGS = 128;
pub const ADL_USER_SETTINGS_ADL_USER_SETTINGS_RTBOOST_PROFILE: ADL_USER_SETTINGS = 256;
pub const ADL_USER_SETTINGS_ADL_USER_SETTINGS_USU2_PROFILE: ADL_USER_SETTINGS = 512;
pub type ADL_USER_SETTINGS = ::std::os::raw::c_int;
pub const FRAME_TIMESTAMPS_SHARED_MEMORY_TYPE_FRAME_TIMESTAMPS_SHARED_MEMORY_TYPE_UNKNOWN : FRAME_TIMESTAMPS_SHARED_MEMORY_TYPE = 0 ;
pub const FRAME_TIMESTAMPS_SHARED_MEMORY_TYPE_FRAME_TIMESTAMPS_SHARED_MEMORY_TYPE_LEGACY : FRAME_TIMESTAMPS_SHARED_MEMORY_TYPE = 1 ;
pub const FRAME_TIMESTAMPS_SHARED_MEMORY_TYPE_FRAME_TIMESTAMPS_SHARED_MEMORY_TYPE_INDEXED : FRAME_TIMESTAMPS_SHARED_MEMORY_TYPE = 2 ;
pub type FRAME_TIMESTAMPS_SHARED_MEMORY_TYPE = ::std::os::raw::c_int;
#[doc = "\n\\brief Structure containing information about the graphics adapter.\n\n This structure is used to store various information about the graphics adapter.  This\n information can be returned to the user. Alternatively, it can be used to access various driver calls to set\n or fetch various settings upon the user's request.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AdapterInfo {
  #[doc = " Size of the structure."]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " The ADL index handle. One GPU may be associated with one or two index handles"]
  pub iAdapterIndex: ::std::os::raw::c_int,
  #[doc = " The unique device ID associated with this adapter."]
  pub strUDID: [::std::os::raw::c_char; 256usize],
  #[doc = " The BUS number associated with this adapter."]
  pub iBusNumber: ::std::os::raw::c_int,
  #[doc = " The driver number associated with this adapter."]
  pub iDeviceNumber: ::std::os::raw::c_int,
  #[doc = " The function number."]
  pub iFunctionNumber: ::std::os::raw::c_int,
  #[doc = " The vendor ID associated with this adapter."]
  pub iVendorID: ::std::os::raw::c_int,
  #[doc = " Adapter name."]
  pub strAdapterName: [::std::os::raw::c_char; 256usize],
  #[doc = " Display name. For example, \"\\\\\\\\Display0\" for Windows."]
  pub strDisplayName: [::std::os::raw::c_char; 256usize],
  #[doc = " Present or not; 1 if present and 0 if not present.It the logical adapter is present, the display name such as \\\\\\\\.\\\\Display1 can be found from OS"]
  pub iPresent: ::std::os::raw::c_int,
  #[doc = " Exist or not; 1 is exist and 0 is not present."]
  pub iExist: ::std::os::raw::c_int,
  #[doc = " Driver registry path."]
  pub strDriverPath: [::std::os::raw::c_char; 256usize],
  #[doc = " Driver registry path Ext for."]
  pub strDriverPathExt: [::std::os::raw::c_char; 256usize],
  #[doc = " PNP string from Windows."]
  pub strPNPString: [::std::os::raw::c_char; 256usize],
  #[doc = " It is generated from EnumDisplayDevices."]
  pub iOSDisplayIndex: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of AdapterInfo"][::std::mem::size_of::<AdapterInfo>() - 1572usize];
  ["Alignment of AdapterInfo"][::std::mem::align_of::<AdapterInfo>() - 4usize];
  ["Offset of field: AdapterInfo::iSize"]
    [::std::mem::offset_of!(AdapterInfo, iSize) - 0usize];
  ["Offset of field: AdapterInfo::iAdapterIndex"]
    [::std::mem::offset_of!(AdapterInfo, iAdapterIndex) - 4usize];
  ["Offset of field: AdapterInfo::strUDID"]
    [::std::mem::offset_of!(AdapterInfo, strUDID) - 8usize];
  ["Offset of field: AdapterInfo::iBusNumber"]
    [::std::mem::offset_of!(AdapterInfo, iBusNumber) - 264usize];
  ["Offset of field: AdapterInfo::iDeviceNumber"]
    [::std::mem::offset_of!(AdapterInfo, iDeviceNumber) - 268usize];
  ["Offset of field: AdapterInfo::iFunctionNumber"]
    [::std::mem::offset_of!(AdapterInfo, iFunctionNumber) - 272usize];
  ["Offset of field: AdapterInfo::iVendorID"]
    [::std::mem::offset_of!(AdapterInfo, iVendorID) - 276usize];
  ["Offset of field: AdapterInfo::strAdapterName"]
    [::std::mem::offset_of!(AdapterInfo, strAdapterName) - 280usize];
  ["Offset of field: AdapterInfo::strDisplayName"]
    [::std::mem::offset_of!(AdapterInfo, strDisplayName) - 536usize];
  ["Offset of field: AdapterInfo::iPresent"]
    [::std::mem::offset_of!(AdapterInfo, iPresent) - 792usize];
  ["Offset of field: AdapterInfo::iExist"]
    [::std::mem::offset_of!(AdapterInfo, iExist) - 796usize];
  ["Offset of field: AdapterInfo::strDriverPath"]
    [::std::mem::offset_of!(AdapterInfo, strDriverPath) - 800usize];
  ["Offset of field: AdapterInfo::strDriverPathExt"]
    [::std::mem::offset_of!(AdapterInfo, strDriverPathExt) - 1056usize];
  ["Offset of field: AdapterInfo::strPNPString"]
    [::std::mem::offset_of!(AdapterInfo, strPNPString) - 1312usize];
  ["Offset of field: AdapterInfo::iOSDisplayIndex"]
    [::std::mem::offset_of!(AdapterInfo, iOSDisplayIndex) - 1568usize];
};
#[doc = "\n\\brief Structure containing information about the graphics adapter.\n\n This structure is used to store various information about the graphics adapter.  This\n information can be returned to the user. Alternatively, it can be used to access various driver calls to set\n or fetch various settings upon the user's request.\n \\nosubgrouping\n"]
pub type LPAdapterInfo = *mut AdapterInfo;
#[doc = "\n\\brief Structure containing information about an controller mode\n\n This structure is used to store information of an controller mode\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLAdapterCaps {
  #[doc = " AdapterID for this adapter"]
  pub iAdapterID: ::std::os::raw::c_int,
  #[doc = " Number of controllers for this adapter"]
  pub iNumControllers: ::std::os::raw::c_int,
  #[doc = " Number of displays for this adapter"]
  pub iNumDisplays: ::std::os::raw::c_int,
  #[doc = " Number of overlays for this adapter"]
  pub iNumOverlays: ::std::os::raw::c_int,
  #[doc = " Number of GLSyncConnectors"]
  pub iNumOfGLSyncConnectors: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the adapter caps"]
  pub iCapsMask: ::std::os::raw::c_int,
  #[doc = " The bit identifies the adapter caps \\ref define_adapter_caps"]
  pub iCapsValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLAdapterCaps"][::std::mem::size_of::<ADLAdapterCaps>() - 28usize];
  ["Alignment of ADLAdapterCaps"][::std::mem::align_of::<ADLAdapterCaps>() - 4usize];
  ["Offset of field: ADLAdapterCaps::iAdapterID"]
    [::std::mem::offset_of!(ADLAdapterCaps, iAdapterID) - 0usize];
  ["Offset of field: ADLAdapterCaps::iNumControllers"]
    [::std::mem::offset_of!(ADLAdapterCaps, iNumControllers) - 4usize];
  ["Offset of field: ADLAdapterCaps::iNumDisplays"]
    [::std::mem::offset_of!(ADLAdapterCaps, iNumDisplays) - 8usize];
  ["Offset of field: ADLAdapterCaps::iNumOverlays"]
    [::std::mem::offset_of!(ADLAdapterCaps, iNumOverlays) - 12usize];
  ["Offset of field: ADLAdapterCaps::iNumOfGLSyncConnectors"]
    [::std::mem::offset_of!(ADLAdapterCaps, iNumOfGLSyncConnectors) - 16usize];
  ["Offset of field: ADLAdapterCaps::iCapsMask"]
    [::std::mem::offset_of!(ADLAdapterCaps, iCapsMask) - 20usize];
  ["Offset of field: ADLAdapterCaps::iCapsValue"]
    [::std::mem::offset_of!(ADLAdapterCaps, iCapsValue) - 24usize];
};
#[doc = "\n\\brief Structure containing additional information about the ASIC memory\n\n This structure is used to store additional information about the ASIC memory.  This\n information can be returned to the user.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLMemoryInfo2 {
  #[doc = " Memory size in bytes."]
  pub iMemorySize: ::std::os::raw::c_longlong,
  #[doc = " Memory type in string."]
  pub strMemoryType: [::std::os::raw::c_char; 256usize],
  #[doc = " Highest default performance level Memory bandwidth in Mbytes/s"]
  pub iMemoryBandwidth: ::std::os::raw::c_longlong,
  #[doc = " HyperMemory size in bytes."]
  pub iHyperMemorySize: ::std::os::raw::c_longlong,
  #[doc = " Invisible Memory size in bytes."]
  pub iInvisibleMemorySize: ::std::os::raw::c_longlong,
  #[doc = " Visible Memory size in bytes."]
  pub iVisibleMemorySize: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLMemoryInfo2"][::std::mem::size_of::<ADLMemoryInfo2>() - 296usize];
  ["Alignment of ADLMemoryInfo2"][::std::mem::align_of::<ADLMemoryInfo2>() - 8usize];
  ["Offset of field: ADLMemoryInfo2::iMemorySize"]
    [::std::mem::offset_of!(ADLMemoryInfo2, iMemorySize) - 0usize];
  ["Offset of field: ADLMemoryInfo2::strMemoryType"]
    [::std::mem::offset_of!(ADLMemoryInfo2, strMemoryType) - 8usize];
  ["Offset of field: ADLMemoryInfo2::iMemoryBandwidth"]
    [::std::mem::offset_of!(ADLMemoryInfo2, iMemoryBandwidth) - 264usize];
  ["Offset of field: ADLMemoryInfo2::iHyperMemorySize"]
    [::std::mem::offset_of!(ADLMemoryInfo2, iHyperMemorySize) - 272usize];
  ["Offset of field: ADLMemoryInfo2::iInvisibleMemorySize"]
    [::std::mem::offset_of!(ADLMemoryInfo2, iInvisibleMemorySize) - 280usize];
  ["Offset of field: ADLMemoryInfo2::iVisibleMemorySize"]
    [::std::mem::offset_of!(ADLMemoryInfo2, iVisibleMemorySize) - 288usize];
};
#[doc = "\n\\brief Structure containing additional information about the ASIC memory\n\n This structure is used to store additional information about the ASIC memory.  This\n information can be returned to the user.\n \\nosubgrouping\n"]
pub type LPADLMemoryInfo2 = *mut ADLMemoryInfo2;
#[doc = "\n\\brief Structure containing additional information about the ASIC memory\n\n This structure is used to store additional information about the ASIC memory.  This\n information can be returned to the user.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLMemoryInfo3 {
  #[doc = " Memory size in bytes."]
  pub iMemorySize: ::std::os::raw::c_longlong,
  #[doc = " Memory type in string."]
  pub strMemoryType: [::std::os::raw::c_char; 256usize],
  #[doc = " Highest default performance level Memory bandwidth in Mbytes/s"]
  pub iMemoryBandwidth: ::std::os::raw::c_longlong,
  #[doc = " HyperMemory size in bytes."]
  pub iHyperMemorySize: ::std::os::raw::c_longlong,
  #[doc = " Invisible Memory size in bytes."]
  pub iInvisibleMemorySize: ::std::os::raw::c_longlong,
  #[doc = " Visible Memory size in bytes."]
  pub iVisibleMemorySize: ::std::os::raw::c_longlong,
  #[doc = " Vram vendor ID"]
  pub iVramVendorRevId: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLMemoryInfo3"][::std::mem::size_of::<ADLMemoryInfo3>() - 304usize];
  ["Alignment of ADLMemoryInfo3"][::std::mem::align_of::<ADLMemoryInfo3>() - 8usize];
  ["Offset of field: ADLMemoryInfo3::iMemorySize"]
    [::std::mem::offset_of!(ADLMemoryInfo3, iMemorySize) - 0usize];
  ["Offset of field: ADLMemoryInfo3::strMemoryType"]
    [::std::mem::offset_of!(ADLMemoryInfo3, strMemoryType) - 8usize];
  ["Offset of field: ADLMemoryInfo3::iMemoryBandwidth"]
    [::std::mem::offset_of!(ADLMemoryInfo3, iMemoryBandwidth) - 264usize];
  ["Offset of field: ADLMemoryInfo3::iHyperMemorySize"]
    [::std::mem::offset_of!(ADLMemoryInfo3, iHyperMemorySize) - 272usize];
  ["Offset of field: ADLMemoryInfo3::iInvisibleMemorySize"]
    [::std::mem::offset_of!(ADLMemoryInfo3, iInvisibleMemorySize) - 280usize];
  ["Offset of field: ADLMemoryInfo3::iVisibleMemorySize"]
    [::std::mem::offset_of!(ADLMemoryInfo3, iVisibleMemorySize) - 288usize];
  ["Offset of field: ADLMemoryInfo3::iVramVendorRevId"]
    [::std::mem::offset_of!(ADLMemoryInfo3, iVramVendorRevId) - 296usize];
};
#[doc = "\n\\brief Structure containing additional information about the ASIC memory\n\n This structure is used to store additional information about the ASIC memory.  This\n information can be returned to the user.\n \\nosubgrouping\n"]
pub type LPADLMemoryInfo3 = *mut ADLMemoryInfo3;
#[doc = "\n\\brief Structure containing additional information about the ASIC memory\n\n This structure is used to store additional information about the ASIC memory.  This\n information can be returned to the user.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLMemoryInfoX4 {
  #[doc = " Memory size in bytes."]
  pub iMemorySize: ::std::os::raw::c_longlong,
  #[doc = " Memory type in string."]
  pub strMemoryType: [::std::os::raw::c_char; 256usize],
  #[doc = " Highest default performance level Memory bandwidth in Mbytes/s"]
  pub iMemoryBandwidth: ::std::os::raw::c_longlong,
  #[doc = " HyperMemory size in bytes."]
  pub iHyperMemorySize: ::std::os::raw::c_longlong,
  #[doc = " Invisible Memory size in bytes."]
  pub iInvisibleMemorySize: ::std::os::raw::c_longlong,
  #[doc = " Visible Memory size in bytes."]
  pub iVisibleMemorySize: ::std::os::raw::c_longlong,
  #[doc = " Vram vendor ID"]
  pub iVramVendorRevId: ::std::os::raw::c_longlong,
  #[doc = " Memory Bandiwidth that is calculated and finalized on the driver side, grab and go."]
  pub iMemoryBandwidthX2: ::std::os::raw::c_longlong,
  #[doc = " Memory Bit Rate that is calculated and finalized on the driver side, grab and go."]
  pub iMemoryBitRateX2: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLMemoryInfoX4"][::std::mem::size_of::<ADLMemoryInfoX4>() - 320usize];
  ["Alignment of ADLMemoryInfoX4"][::std::mem::align_of::<ADLMemoryInfoX4>() - 8usize];
  ["Offset of field: ADLMemoryInfoX4::iMemorySize"]
    [::std::mem::offset_of!(ADLMemoryInfoX4, iMemorySize) - 0usize];
  ["Offset of field: ADLMemoryInfoX4::strMemoryType"]
    [::std::mem::offset_of!(ADLMemoryInfoX4, strMemoryType) - 8usize];
  ["Offset of field: ADLMemoryInfoX4::iMemoryBandwidth"]
    [::std::mem::offset_of!(ADLMemoryInfoX4, iMemoryBandwidth) - 264usize];
  ["Offset of field: ADLMemoryInfoX4::iHyperMemorySize"]
    [::std::mem::offset_of!(ADLMemoryInfoX4, iHyperMemorySize) - 272usize];
  ["Offset of field: ADLMemoryInfoX4::iInvisibleMemorySize"]
    [::std::mem::offset_of!(ADLMemoryInfoX4, iInvisibleMemorySize) - 280usize];
  ["Offset of field: ADLMemoryInfoX4::iVisibleMemorySize"]
    [::std::mem::offset_of!(ADLMemoryInfoX4, iVisibleMemorySize) - 288usize];
  ["Offset of field: ADLMemoryInfoX4::iVramVendorRevId"]
    [::std::mem::offset_of!(ADLMemoryInfoX4, iVramVendorRevId) - 296usize];
  ["Offset of field: ADLMemoryInfoX4::iMemoryBandwidthX2"]
    [::std::mem::offset_of!(ADLMemoryInfoX4, iMemoryBandwidthX2) - 304usize];
  ["Offset of field: ADLMemoryInfoX4::iMemoryBitRateX2"]
    [::std::mem::offset_of!(ADLMemoryInfoX4, iMemoryBitRateX2) - 312usize];
};
#[doc = "\n\\brief Structure containing additional information about the ASIC memory\n\n This structure is used to store additional information about the ASIC memory.  This\n information can be returned to the user.\n \\nosubgrouping\n"]
pub type LPADLMemoryInfoX4 = *mut ADLMemoryInfoX4;
pub const ADLvRamVendors_ADLvRamVendor_Unsupported: ADLvRamVendors = 0;
pub const ADLvRamVendors_ADLvRamVendor_SAMSUNG: ADLvRamVendors = 1;
pub const ADLvRamVendors_ADLvRamVendor_INFINEON: ADLvRamVendors = 2;
pub const ADLvRamVendors_ADLvRamVendor_ELPIDA: ADLvRamVendors = 3;
pub const ADLvRamVendors_ADLvRamVendor_ETRON: ADLvRamVendors = 4;
pub const ADLvRamVendors_ADLvRamVendor_NANYA: ADLvRamVendors = 5;
pub const ADLvRamVendors_ADLvRamVendor_HYNIX: ADLvRamVendors = 6;
pub const ADLvRamVendors_ADLvRamVendor_MOSEL: ADLvRamVendors = 7;
pub const ADLvRamVendors_ADLvRamVendor_WINBOND: ADLvRamVendors = 8;
pub const ADLvRamVendors_ADLvRamVendor_ESMT: ADLvRamVendors = 9;
pub const ADLvRamVendors_ADLvRamVendor_MICRON: ADLvRamVendors = 15;
pub const ADLvRamVendors_ADLvRamVendor_Undefined: ADLvRamVendors = 16;
pub type ADLvRamVendors = ::std::os::raw::c_int;
#[doc = "\n\\brief Structure containing information about components of ASIC GCN architecture\n\n  Elements of GCN info are compute units, number of Tex (Texture filtering units)  , number of ROPs (render back-ends).\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLGcnInfo {
  pub CuCount: ::std::os::raw::c_int,
  pub TexCount: ::std::os::raw::c_int,
  pub RopCount: ::std::os::raw::c_int,
  pub ASICFamilyId: ::std::os::raw::c_int,
  pub ASICRevisionId: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLGcnInfo"][::std::mem::size_of::<ADLGcnInfo>() - 20usize];
  ["Alignment of ADLGcnInfo"][::std::mem::align_of::<ADLGcnInfo>() - 4usize];
  ["Offset of field: ADLGcnInfo::CuCount"]
    [::std::mem::offset_of!(ADLGcnInfo, CuCount) - 0usize];
  ["Offset of field: ADLGcnInfo::TexCount"]
    [::std::mem::offset_of!(ADLGcnInfo, TexCount) - 4usize];
  ["Offset of field: ADLGcnInfo::RopCount"]
    [::std::mem::offset_of!(ADLGcnInfo, RopCount) - 8usize];
  ["Offset of field: ADLGcnInfo::ASICFamilyId"]
    [::std::mem::offset_of!(ADLGcnInfo, ASICFamilyId) - 12usize];
  ["Offset of field: ADLGcnInfo::ASICRevisionId"]
    [::std::mem::offset_of!(ADLGcnInfo, ASICRevisionId) - 16usize];
};
#[doc = "\n\\brief Structure containing information related virtual segment config information.\n\n This structure is used to store information related virtual segment config\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLVirtualSegmentSettingsOutput {
  pub virtualSegmentSupported: ::std::os::raw::c_int,
  pub virtualSegmentDefault: ::std::os::raw::c_int,
  pub virtualSegmentCurrent: ::std::os::raw::c_int,
  pub iMinSizeInMB: ::std::os::raw::c_int,
  pub iMaxSizeInMB: ::std::os::raw::c_int,
  pub icurrentSizeInMB: ::std::os::raw::c_int,
  pub idefaultSizeInMB: ::std::os::raw::c_int,
  pub iMask: ::std::os::raw::c_int,
  pub iValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLVirtualSegmentSettingsOutput"]
    [::std::mem::size_of::<ADLVirtualSegmentSettingsOutput>() - 36usize];
  ["Alignment of ADLVirtualSegmentSettingsOutput"]
    [::std::mem::align_of::<ADLVirtualSegmentSettingsOutput>() - 4usize];
  ["Offset of field: ADLVirtualSegmentSettingsOutput::virtualSegmentSupported"][::std::mem::offset_of!(
    ADLVirtualSegmentSettingsOutput,
    virtualSegmentSupported
  )
    - 0usize];
  ["Offset of field: ADLVirtualSegmentSettingsOutput::virtualSegmentDefault"][::std::mem::offset_of!(
    ADLVirtualSegmentSettingsOutput,
    virtualSegmentDefault
  ) - 4usize];
  ["Offset of field: ADLVirtualSegmentSettingsOutput::virtualSegmentCurrent"][::std::mem::offset_of!(
    ADLVirtualSegmentSettingsOutput,
    virtualSegmentCurrent
  ) - 8usize];
  ["Offset of field: ADLVirtualSegmentSettingsOutput::iMinSizeInMB"]
    [::std::mem::offset_of!(ADLVirtualSegmentSettingsOutput, iMinSizeInMB) - 12usize];
  ["Offset of field: ADLVirtualSegmentSettingsOutput::iMaxSizeInMB"]
    [::std::mem::offset_of!(ADLVirtualSegmentSettingsOutput, iMaxSizeInMB) - 16usize];
  ["Offset of field: ADLVirtualSegmentSettingsOutput::icurrentSizeInMB"]
    [::std::mem::offset_of!(ADLVirtualSegmentSettingsOutput, icurrentSizeInMB) - 20usize];
  ["Offset of field: ADLVirtualSegmentSettingsOutput::idefaultSizeInMB"]
    [::std::mem::offset_of!(ADLVirtualSegmentSettingsOutput, idefaultSizeInMB) - 24usize];
  ["Offset of field: ADLVirtualSegmentSettingsOutput::iMask"]
    [::std::mem::offset_of!(ADLVirtualSegmentSettingsOutput, iMask) - 28usize];
  ["Offset of field: ADLVirtualSegmentSettingsOutput::iValue"]
    [::std::mem::offset_of!(ADLVirtualSegmentSettingsOutput, iValue) - 32usize];
};
#[doc = "\n \\brief Structure containing information about the Chipset.\n\n This structure is used to store various information about the Chipset.  This\n information can be returned to the user.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLChipSetInfo {
  #[doc = "< Bus type."]
  pub iBusType: ::std::os::raw::c_int,
  pub iBusSpeedType: ::std::os::raw::c_int,
  #[doc = "< Number of PCIE lanes."]
  pub iMaxPCIELaneWidth: ::std::os::raw::c_int,
  #[doc = "< Current PCIE Lane Width"]
  pub iCurrentPCIELaneWidth: ::std::os::raw::c_int,
  #[doc = "< Bit mask or AGP transfer speed."]
  pub iSupportedAGPSpeeds: ::std::os::raw::c_int,
  #[doc = "< Current AGP speed"]
  pub iCurrentAGPSpeed: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLChipSetInfo"][::std::mem::size_of::<ADLChipSetInfo>() - 24usize];
  ["Alignment of ADLChipSetInfo"][::std::mem::align_of::<ADLChipSetInfo>() - 4usize];
  ["Offset of field: ADLChipSetInfo::iBusType"]
    [::std::mem::offset_of!(ADLChipSetInfo, iBusType) - 0usize];
  ["Offset of field: ADLChipSetInfo::iBusSpeedType"]
    [::std::mem::offset_of!(ADLChipSetInfo, iBusSpeedType) - 4usize];
  ["Offset of field: ADLChipSetInfo::iMaxPCIELaneWidth"]
    [::std::mem::offset_of!(ADLChipSetInfo, iMaxPCIELaneWidth) - 8usize];
  ["Offset of field: ADLChipSetInfo::iCurrentPCIELaneWidth"]
    [::std::mem::offset_of!(ADLChipSetInfo, iCurrentPCIELaneWidth) - 12usize];
  ["Offset of field: ADLChipSetInfo::iSupportedAGPSpeeds"]
    [::std::mem::offset_of!(ADLChipSetInfo, iSupportedAGPSpeeds) - 16usize];
  ["Offset of field: ADLChipSetInfo::iCurrentAGPSpeed"]
    [::std::mem::offset_of!(ADLChipSetInfo, iCurrentAGPSpeed) - 20usize];
};
#[doc = "\n \\brief Structure containing information about the Chipset.\n\n This structure is used to store various information about the Chipset.  This\n information can be returned to the user.\n \\nosubgrouping\n"]
pub type LPADLChipSetInfo = *mut ADLChipSetInfo;
#[doc = "\n\\brief Structure containing information about the ASIC memory.\n\n This structure is used to store various information about the ASIC memory.  This\n information can be returned to the user.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLMemoryInfo {
  #[doc = " Memory size in bytes."]
  pub iMemorySize: ::std::os::raw::c_longlong,
  #[doc = " Memory type in string."]
  pub strMemoryType: [::std::os::raw::c_char; 256usize],
  #[doc = " Memory bandwidth in Mbytes/s."]
  pub iMemoryBandwidth: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLMemoryInfo"][::std::mem::size_of::<ADLMemoryInfo>() - 272usize];
  ["Alignment of ADLMemoryInfo"][::std::mem::align_of::<ADLMemoryInfo>() - 8usize];
  ["Offset of field: ADLMemoryInfo::iMemorySize"]
    [::std::mem::offset_of!(ADLMemoryInfo, iMemorySize) - 0usize];
  ["Offset of field: ADLMemoryInfo::strMemoryType"]
    [::std::mem::offset_of!(ADLMemoryInfo, strMemoryType) - 8usize];
  ["Offset of field: ADLMemoryInfo::iMemoryBandwidth"]
    [::std::mem::offset_of!(ADLMemoryInfo, iMemoryBandwidth) - 264usize];
};
#[doc = "\n\\brief Structure containing information about the ASIC memory.\n\n This structure is used to store various information about the ASIC memory.  This\n information can be returned to the user.\n \\nosubgrouping\n"]
pub type LPADLMemoryInfo = *mut ADLMemoryInfo;
#[doc = "\n\\brief Structure containing information about memory required by type\n\n This structure is returned by ADL_Adapter_ConfigMemory_Get, which given a desktop and display configuration\n will return the Memory used.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLMemoryRequired {
  pub iMemoryReq: ::std::os::raw::c_longlong,
  #[doc = " Memory in bytes required"]
  pub iType: ::std::os::raw::c_int,
  #[doc = " Type of Memory \\ref define_adl_validmemoryrequiredfields"]
  pub iDisplayFeatureValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLMemoryRequired"][::std::mem::size_of::<ADLMemoryRequired>() - 16usize];
  ["Alignment of ADLMemoryRequired"]
    [::std::mem::align_of::<ADLMemoryRequired>() - 8usize];
  ["Offset of field: ADLMemoryRequired::iMemoryReq"]
    [::std::mem::offset_of!(ADLMemoryRequired, iMemoryReq) - 0usize];
  ["Offset of field: ADLMemoryRequired::iType"]
    [::std::mem::offset_of!(ADLMemoryRequired, iType) - 8usize];
  ["Offset of field: ADLMemoryRequired::iDisplayFeatureValue"]
    [::std::mem::offset_of!(ADLMemoryRequired, iDisplayFeatureValue) - 12usize];
};
#[doc = "\n\\brief Structure containing information about memory required by type\n\n This structure is returned by ADL_Adapter_ConfigMemory_Get, which given a desktop and display configuration\n will return the Memory used.\n \\nosubgrouping\n"]
pub type LPADLMemoryRequired = *mut ADLMemoryRequired;
#[doc = "\n\\brief Structure containing information about the features associated with a display\n\n This structure is a parameter to ADL_Adapter_ConfigMemory_Get, which given a desktop and display configuration\n will return the Memory used.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLMemoryDisplayFeatures {
  pub iDisplayIndex: ::std::os::raw::c_int,
  #[doc = " ADL Display index"]
  pub iDisplayFeatureValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLMemoryDisplayFeatures"]
    [::std::mem::size_of::<ADLMemoryDisplayFeatures>() - 8usize];
  ["Alignment of ADLMemoryDisplayFeatures"]
    [::std::mem::align_of::<ADLMemoryDisplayFeatures>() - 4usize];
  ["Offset of field: ADLMemoryDisplayFeatures::iDisplayIndex"]
    [::std::mem::offset_of!(ADLMemoryDisplayFeatures, iDisplayIndex) - 0usize];
  ["Offset of field: ADLMemoryDisplayFeatures::iDisplayFeatureValue"]
    [::std::mem::offset_of!(ADLMemoryDisplayFeatures, iDisplayFeatureValue) - 4usize];
};
#[doc = "\n\\brief Structure containing information about the features associated with a display\n\n This structure is a parameter to ADL_Adapter_ConfigMemory_Get, which given a desktop and display configuration\n will return the Memory used.\n \\nosubgrouping\n"]
pub type LPADLMemoryDisplayFeatures = *mut ADLMemoryDisplayFeatures;
#[doc = "\n\\brief Structure containing DDC information.\n\n This structure is used to store various DDC information that can be returned to the user.\n Note that all fields of type int are actually defined as unsigned int types within the driver.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDDCInfo {
  #[doc = " Size of the structure"]
  pub ulSize: ::std::os::raw::c_int,
  #[doc = " Indicates whether the attached display supports DDC. If this field is zero on return, no other DDC information fields will be used."]
  pub ulSupportsDDC: ::std::os::raw::c_int,
  #[doc = " Returns the manufacturer ID of the display device. Should be zeroed if this information is not available."]
  pub ulManufacturerID: ::std::os::raw::c_int,
  #[doc = " Returns the product ID of the display device. Should be zeroed if this information is not available."]
  pub ulProductID: ::std::os::raw::c_int,
  #[doc = " Returns the name of the display device. Should be zeroed if this information is not available."]
  pub cDisplayName: [::std::os::raw::c_char; 256usize],
  #[doc = " Returns the maximum Horizontal supported resolution. Should be zeroed if this information is not available."]
  pub ulMaxHResolution: ::std::os::raw::c_int,
  #[doc = " Returns the maximum Vertical supported resolution. Should be zeroed if this information is not available."]
  pub ulMaxVResolution: ::std::os::raw::c_int,
  #[doc = " Returns the maximum supported refresh rate. Should be zeroed if this information is not available."]
  pub ulMaxRefresh: ::std::os::raw::c_int,
  #[doc = " Returns the display device preferred timing mode's horizontal resolution."]
  pub ulPTMCx: ::std::os::raw::c_int,
  #[doc = " Returns the display device preferred timing mode's vertical resolution."]
  pub ulPTMCy: ::std::os::raw::c_int,
  #[doc = " Returns the display device preferred timing mode's refresh rate."]
  pub ulPTMRefreshRate: ::std::os::raw::c_int,
  #[doc = " Return EDID flags."]
  pub ulDDCInfoFlag: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDDCInfo"][::std::mem::size_of::<ADLDDCInfo>() - 300usize];
  ["Alignment of ADLDDCInfo"][::std::mem::align_of::<ADLDDCInfo>() - 4usize];
  ["Offset of field: ADLDDCInfo::ulSize"]
    [::std::mem::offset_of!(ADLDDCInfo, ulSize) - 0usize];
  ["Offset of field: ADLDDCInfo::ulSupportsDDC"]
    [::std::mem::offset_of!(ADLDDCInfo, ulSupportsDDC) - 4usize];
  ["Offset of field: ADLDDCInfo::ulManufacturerID"]
    [::std::mem::offset_of!(ADLDDCInfo, ulManufacturerID) - 8usize];
  ["Offset of field: ADLDDCInfo::ulProductID"]
    [::std::mem::offset_of!(ADLDDCInfo, ulProductID) - 12usize];
  ["Offset of field: ADLDDCInfo::cDisplayName"]
    [::std::mem::offset_of!(ADLDDCInfo, cDisplayName) - 16usize];
  ["Offset of field: ADLDDCInfo::ulMaxHResolution"]
    [::std::mem::offset_of!(ADLDDCInfo, ulMaxHResolution) - 272usize];
  ["Offset of field: ADLDDCInfo::ulMaxVResolution"]
    [::std::mem::offset_of!(ADLDDCInfo, ulMaxVResolution) - 276usize];
  ["Offset of field: ADLDDCInfo::ulMaxRefresh"]
    [::std::mem::offset_of!(ADLDDCInfo, ulMaxRefresh) - 280usize];
  ["Offset of field: ADLDDCInfo::ulPTMCx"]
    [::std::mem::offset_of!(ADLDDCInfo, ulPTMCx) - 284usize];
  ["Offset of field: ADLDDCInfo::ulPTMCy"]
    [::std::mem::offset_of!(ADLDDCInfo, ulPTMCy) - 288usize];
  ["Offset of field: ADLDDCInfo::ulPTMRefreshRate"]
    [::std::mem::offset_of!(ADLDDCInfo, ulPTMRefreshRate) - 292usize];
  ["Offset of field: ADLDDCInfo::ulDDCInfoFlag"]
    [::std::mem::offset_of!(ADLDDCInfo, ulDDCInfoFlag) - 296usize];
};
#[doc = "\n\\brief Structure containing DDC information.\n\n This structure is used to store various DDC information that can be returned to the user.\n Note that all fields of type int are actually defined as unsigned int types within the driver.\n \\nosubgrouping\n"]
pub type LPADLDDCInfo = *mut ADLDDCInfo;
#[doc = "\n\\brief Structure containing DDC information.\n\n This structure is used to store various DDC information that can be returned to the user.\n Note that all fields of type int are actually defined as unsigned int types within the driver.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDDCInfo2 {
  #[doc = " Size of the structure"]
  pub ulSize: ::std::os::raw::c_int,
  #[doc = " Indicates whether the attached display supports DDC. If this field is zero on return, no other DDC\n information fields will be used."]
  pub ulSupportsDDC: ::std::os::raw::c_int,
  #[doc = " Returns the manufacturer ID of the display device. Should be zeroed if this information is not available."]
  pub ulManufacturerID: ::std::os::raw::c_int,
  #[doc = " Returns the product ID of the display device. Should be zeroed if this information is not available."]
  pub ulProductID: ::std::os::raw::c_int,
  #[doc = " Returns the name of the display device. Should be zeroed if this information is not available."]
  pub cDisplayName: [::std::os::raw::c_char; 256usize],
  #[doc = " Returns the maximum Horizontal supported resolution. Should be zeroed if this information is not available."]
  pub ulMaxHResolution: ::std::os::raw::c_int,
  #[doc = " Returns the maximum Vertical supported resolution. Should be zeroed if this information is not available."]
  pub ulMaxVResolution: ::std::os::raw::c_int,
  #[doc = " Returns the maximum supported refresh rate. Should be zeroed if this information is not available."]
  pub ulMaxRefresh: ::std::os::raw::c_int,
  #[doc = " Returns the display device preferred timing mode's horizontal resolution."]
  pub ulPTMCx: ::std::os::raw::c_int,
  #[doc = " Returns the display device preferred timing mode's vertical resolution."]
  pub ulPTMCy: ::std::os::raw::c_int,
  #[doc = " Returns the display device preferred timing mode's refresh rate."]
  pub ulPTMRefreshRate: ::std::os::raw::c_int,
  #[doc = " Return EDID flags."]
  pub ulDDCInfoFlag: ::std::os::raw::c_int,
  #[doc = " Returns 1 if the display supported packed pixel, 0 otherwise"]
  pub bPackedPixelSupported: ::std::os::raw::c_int,
  #[doc = " Returns the Pixel formats the display supports \\ref define_ddcinfo_pixelformats"]
  pub iPanelPixelFormat: ::std::os::raw::c_int,
  #[doc = " Return EDID serial ID."]
  pub ulSerialID: ::std::os::raw::c_int,
  #[doc = " Return minimum monitor luminance data"]
  pub ulMinLuminanceData: ::std::os::raw::c_int,
  #[doc = " Return average monitor luminance data"]
  pub ulAvgLuminanceData: ::std::os::raw::c_int,
  #[doc = " Return maximum monitor luminance data"]
  pub ulMaxLuminanceData: ::std::os::raw::c_int,
  #[doc = " Bit vector of supported transfer functions \\ref define_source_content_TF"]
  pub iSupportedTransferFunction: ::std::os::raw::c_int,
  #[doc = " Bit vector of supported color spaces \\ref define_source_content_CS"]
  pub iSupportedColorSpace: ::std::os::raw::c_int,
  #[doc = " Display Red Chromaticity X coordinate multiplied by 10000"]
  pub iNativeDisplayChromaticityRedX: ::std::os::raw::c_int,
  #[doc = " Display Red Chromaticity Y coordinate multiplied by 10000"]
  pub iNativeDisplayChromaticityRedY: ::std::os::raw::c_int,
  #[doc = " Display Green Chromaticity X coordinate multiplied by 10000"]
  pub iNativeDisplayChromaticityGreenX: ::std::os::raw::c_int,
  #[doc = " Display Green Chromaticity Y coordinate multiplied by 10000"]
  pub iNativeDisplayChromaticityGreenY: ::std::os::raw::c_int,
  #[doc = " Display Blue Chromaticity X coordinate multiplied by 10000"]
  pub iNativeDisplayChromaticityBlueX: ::std::os::raw::c_int,
  #[doc = " Display Blue Chromaticity Y coordinate multiplied by 10000"]
  pub iNativeDisplayChromaticityBlueY: ::std::os::raw::c_int,
  #[doc = " Display White Point X coordinate multiplied by 10000"]
  pub iNativeDisplayChromaticityWhitePointX: ::std::os::raw::c_int,
  #[doc = " Display White Point Y coordinate multiplied by 10000"]
  pub iNativeDisplayChromaticityWhitePointY: ::std::os::raw::c_int,
  #[doc = " Display diffuse screen reflectance 0-1 (100%) in units of 0.01"]
  pub iDiffuseScreenReflectance: ::std::os::raw::c_int,
  #[doc = " Display specular screen reflectance 0-1 (100%) in units of 0.01"]
  pub iSpecularScreenReflectance: ::std::os::raw::c_int,
  #[doc = " Bit vector of supported color spaces \\ref define_HDR_support"]
  pub iSupportedHDR: ::std::os::raw::c_int,
  #[doc = " Bit vector for freesync flags"]
  pub iFreesyncFlags: ::std::os::raw::c_int,
  #[doc = " Return minimum monitor luminance without dimming data"]
  pub ulMinLuminanceNoDimmingData: ::std::os::raw::c_int,
  pub ulMaxBacklightMaxLuminanceData: ::std::os::raw::c_int,
  pub ulMinBacklightMaxLuminanceData: ::std::os::raw::c_int,
  pub ulMaxBacklightMinLuminanceData: ::std::os::raw::c_int,
  pub ulMinBacklightMinLuminanceData: ::std::os::raw::c_int,
  pub ulScreenWidth: ::std::os::raw::c_int,
  pub ulScreenHeight: ::std::os::raw::c_int,
  pub iReserved: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDDCInfo2"][::std::mem::size_of::<ADLDDCInfo2>() - 416usize];
  ["Alignment of ADLDDCInfo2"][::std::mem::align_of::<ADLDDCInfo2>() - 4usize];
  ["Offset of field: ADLDDCInfo2::ulSize"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulSize) - 0usize];
  ["Offset of field: ADLDDCInfo2::ulSupportsDDC"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulSupportsDDC) - 4usize];
  ["Offset of field: ADLDDCInfo2::ulManufacturerID"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulManufacturerID) - 8usize];
  ["Offset of field: ADLDDCInfo2::ulProductID"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulProductID) - 12usize];
  ["Offset of field: ADLDDCInfo2::cDisplayName"]
    [::std::mem::offset_of!(ADLDDCInfo2, cDisplayName) - 16usize];
  ["Offset of field: ADLDDCInfo2::ulMaxHResolution"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulMaxHResolution) - 272usize];
  ["Offset of field: ADLDDCInfo2::ulMaxVResolution"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulMaxVResolution) - 276usize];
  ["Offset of field: ADLDDCInfo2::ulMaxRefresh"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulMaxRefresh) - 280usize];
  ["Offset of field: ADLDDCInfo2::ulPTMCx"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulPTMCx) - 284usize];
  ["Offset of field: ADLDDCInfo2::ulPTMCy"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulPTMCy) - 288usize];
  ["Offset of field: ADLDDCInfo2::ulPTMRefreshRate"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulPTMRefreshRate) - 292usize];
  ["Offset of field: ADLDDCInfo2::ulDDCInfoFlag"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulDDCInfoFlag) - 296usize];
  ["Offset of field: ADLDDCInfo2::bPackedPixelSupported"]
    [::std::mem::offset_of!(ADLDDCInfo2, bPackedPixelSupported) - 300usize];
  ["Offset of field: ADLDDCInfo2::iPanelPixelFormat"]
    [::std::mem::offset_of!(ADLDDCInfo2, iPanelPixelFormat) - 304usize];
  ["Offset of field: ADLDDCInfo2::ulSerialID"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulSerialID) - 308usize];
  ["Offset of field: ADLDDCInfo2::ulMinLuminanceData"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulMinLuminanceData) - 312usize];
  ["Offset of field: ADLDDCInfo2::ulAvgLuminanceData"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulAvgLuminanceData) - 316usize];
  ["Offset of field: ADLDDCInfo2::ulMaxLuminanceData"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulMaxLuminanceData) - 320usize];
  ["Offset of field: ADLDDCInfo2::iSupportedTransferFunction"]
    [::std::mem::offset_of!(ADLDDCInfo2, iSupportedTransferFunction) - 324usize];
  ["Offset of field: ADLDDCInfo2::iSupportedColorSpace"]
    [::std::mem::offset_of!(ADLDDCInfo2, iSupportedColorSpace) - 328usize];
  ["Offset of field: ADLDDCInfo2::iNativeDisplayChromaticityRedX"]
    [::std::mem::offset_of!(ADLDDCInfo2, iNativeDisplayChromaticityRedX) - 332usize];
  ["Offset of field: ADLDDCInfo2::iNativeDisplayChromaticityRedY"]
    [::std::mem::offset_of!(ADLDDCInfo2, iNativeDisplayChromaticityRedY) - 336usize];
  ["Offset of field: ADLDDCInfo2::iNativeDisplayChromaticityGreenX"]
    [::std::mem::offset_of!(ADLDDCInfo2, iNativeDisplayChromaticityGreenX) - 340usize];
  ["Offset of field: ADLDDCInfo2::iNativeDisplayChromaticityGreenY"]
    [::std::mem::offset_of!(ADLDDCInfo2, iNativeDisplayChromaticityGreenY) - 344usize];
  ["Offset of field: ADLDDCInfo2::iNativeDisplayChromaticityBlueX"]
    [::std::mem::offset_of!(ADLDDCInfo2, iNativeDisplayChromaticityBlueX) - 348usize];
  ["Offset of field: ADLDDCInfo2::iNativeDisplayChromaticityBlueY"]
    [::std::mem::offset_of!(ADLDDCInfo2, iNativeDisplayChromaticityBlueY) - 352usize];
  ["Offset of field: ADLDDCInfo2::iNativeDisplayChromaticityWhitePointX"][::std::mem::offset_of!(
    ADLDDCInfo2,
    iNativeDisplayChromaticityWhitePointX
  ) - 356usize];
  ["Offset of field: ADLDDCInfo2::iNativeDisplayChromaticityWhitePointY"][::std::mem::offset_of!(
    ADLDDCInfo2,
    iNativeDisplayChromaticityWhitePointY
  ) - 360usize];
  ["Offset of field: ADLDDCInfo2::iDiffuseScreenReflectance"]
    [::std::mem::offset_of!(ADLDDCInfo2, iDiffuseScreenReflectance) - 364usize];
  ["Offset of field: ADLDDCInfo2::iSpecularScreenReflectance"]
    [::std::mem::offset_of!(ADLDDCInfo2, iSpecularScreenReflectance) - 368usize];
  ["Offset of field: ADLDDCInfo2::iSupportedHDR"]
    [::std::mem::offset_of!(ADLDDCInfo2, iSupportedHDR) - 372usize];
  ["Offset of field: ADLDDCInfo2::iFreesyncFlags"]
    [::std::mem::offset_of!(ADLDDCInfo2, iFreesyncFlags) - 376usize];
  ["Offset of field: ADLDDCInfo2::ulMinLuminanceNoDimmingData"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulMinLuminanceNoDimmingData) - 380usize];
  ["Offset of field: ADLDDCInfo2::ulMaxBacklightMaxLuminanceData"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulMaxBacklightMaxLuminanceData) - 384usize];
  ["Offset of field: ADLDDCInfo2::ulMinBacklightMaxLuminanceData"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulMinBacklightMaxLuminanceData) - 388usize];
  ["Offset of field: ADLDDCInfo2::ulMaxBacklightMinLuminanceData"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulMaxBacklightMinLuminanceData) - 392usize];
  ["Offset of field: ADLDDCInfo2::ulMinBacklightMinLuminanceData"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulMinBacklightMinLuminanceData) - 396usize];
  ["Offset of field: ADLDDCInfo2::ulScreenWidth"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulScreenWidth) - 400usize];
  ["Offset of field: ADLDDCInfo2::ulScreenHeight"]
    [::std::mem::offset_of!(ADLDDCInfo2, ulScreenHeight) - 404usize];
  ["Offset of field: ADLDDCInfo2::iReserved"]
    [::std::mem::offset_of!(ADLDDCInfo2, iReserved) - 408usize];
};
#[doc = "\n\\brief Structure containing DDC information.\n\n This structure is used to store various DDC information that can be returned to the user.\n Note that all fields of type int are actually defined as unsigned int types within the driver.\n \\nosubgrouping\n"]
pub type LPADLDDCInfo2 = *mut ADLDDCInfo2;
#[doc = "\n\\brief Structure containing information controller Gamma settings.\n\n This structure is used to store the red, green and blue color channel information for the.\n controller gamma setting. This information is returned by ADL, and it can also be used to\n set the controller gamma setting.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLGamma {
  #[doc = " Red color channel gamma value."]
  pub fRed: f32,
  #[doc = " Green color channel gamma value."]
  pub fGreen: f32,
  #[doc = " Blue color channel gamma value."]
  pub fBlue: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLGamma"][::std::mem::size_of::<ADLGamma>() - 12usize];
  ["Alignment of ADLGamma"][::std::mem::align_of::<ADLGamma>() - 4usize];
  ["Offset of field: ADLGamma::fRed"][::std::mem::offset_of!(ADLGamma, fRed) - 0usize];
  ["Offset of field: ADLGamma::fGreen"]
    [::std::mem::offset_of!(ADLGamma, fGreen) - 4usize];
  ["Offset of field: ADLGamma::fBlue"][::std::mem::offset_of!(ADLGamma, fBlue) - 8usize];
};
#[doc = "\n\\brief Structure containing information controller Gamma settings.\n\n This structure is used to store the red, green and blue color channel information for the.\n controller gamma setting. This information is returned by ADL, and it can also be used to\n set the controller gamma setting.\n \\nosubgrouping\n"]
pub type LPADLGamma = *mut ADLGamma;
#[doc = "\n\\brief Structure containing information about component video custom modes.\n\n This structure is used to store the component video custom mode.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLCustomMode {
  #[doc = " Custom mode flags.  They are returned by the ADL driver."]
  pub iFlags: ::std::os::raw::c_int,
  #[doc = " Custom mode width."]
  pub iModeWidth: ::std::os::raw::c_int,
  #[doc = " Custom mode height."]
  pub iModeHeight: ::std::os::raw::c_int,
  #[doc = " Custom mode base width."]
  pub iBaseModeWidth: ::std::os::raw::c_int,
  #[doc = " Custom mode base height."]
  pub iBaseModeHeight: ::std::os::raw::c_int,
  #[doc = " Custom mode refresh rate."]
  pub iRefreshRate: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLCustomMode"][::std::mem::size_of::<ADLCustomMode>() - 24usize];
  ["Alignment of ADLCustomMode"][::std::mem::align_of::<ADLCustomMode>() - 4usize];
  ["Offset of field: ADLCustomMode::iFlags"]
    [::std::mem::offset_of!(ADLCustomMode, iFlags) - 0usize];
  ["Offset of field: ADLCustomMode::iModeWidth"]
    [::std::mem::offset_of!(ADLCustomMode, iModeWidth) - 4usize];
  ["Offset of field: ADLCustomMode::iModeHeight"]
    [::std::mem::offset_of!(ADLCustomMode, iModeHeight) - 8usize];
  ["Offset of field: ADLCustomMode::iBaseModeWidth"]
    [::std::mem::offset_of!(ADLCustomMode, iBaseModeWidth) - 12usize];
  ["Offset of field: ADLCustomMode::iBaseModeHeight"]
    [::std::mem::offset_of!(ADLCustomMode, iBaseModeHeight) - 16usize];
  ["Offset of field: ADLCustomMode::iRefreshRate"]
    [::std::mem::offset_of!(ADLCustomMode, iRefreshRate) - 20usize];
};
#[doc = "\n\\brief Structure containing information about component video custom modes.\n\n This structure is used to store the component video custom mode.\n \\nosubgrouping\n"]
pub type LPADLCustomMode = *mut ADLCustomMode;
#[doc = "\n\\brief Structure containing Clock information for OD5 calls.\n\n This structure is used to retrieve clock information for OD5 calls.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLGetClocksOUT {
  pub ulHighCoreClock: ::std::os::raw::c_long,
  pub ulHighMemoryClock: ::std::os::raw::c_long,
  pub ulHighVddc: ::std::os::raw::c_long,
  pub ulCoreMin: ::std::os::raw::c_long,
  pub ulCoreMax: ::std::os::raw::c_long,
  pub ulMemoryMin: ::std::os::raw::c_long,
  pub ulMemoryMax: ::std::os::raw::c_long,
  pub ulActivityPercent: ::std::os::raw::c_long,
  pub ulCurrentCoreClock: ::std::os::raw::c_long,
  pub ulCurrentMemoryClock: ::std::os::raw::c_long,
  pub ulReserved: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLGetClocksOUT"][::std::mem::size_of::<ADLGetClocksOUT>() - 44usize];
  ["Alignment of ADLGetClocksOUT"][::std::mem::align_of::<ADLGetClocksOUT>() - 4usize];
  ["Offset of field: ADLGetClocksOUT::ulHighCoreClock"]
    [::std::mem::offset_of!(ADLGetClocksOUT, ulHighCoreClock) - 0usize];
  ["Offset of field: ADLGetClocksOUT::ulHighMemoryClock"]
    [::std::mem::offset_of!(ADLGetClocksOUT, ulHighMemoryClock) - 4usize];
  ["Offset of field: ADLGetClocksOUT::ulHighVddc"]
    [::std::mem::offset_of!(ADLGetClocksOUT, ulHighVddc) - 8usize];
  ["Offset of field: ADLGetClocksOUT::ulCoreMin"]
    [::std::mem::offset_of!(ADLGetClocksOUT, ulCoreMin) - 12usize];
  ["Offset of field: ADLGetClocksOUT::ulCoreMax"]
    [::std::mem::offset_of!(ADLGetClocksOUT, ulCoreMax) - 16usize];
  ["Offset of field: ADLGetClocksOUT::ulMemoryMin"]
    [::std::mem::offset_of!(ADLGetClocksOUT, ulMemoryMin) - 20usize];
  ["Offset of field: ADLGetClocksOUT::ulMemoryMax"]
    [::std::mem::offset_of!(ADLGetClocksOUT, ulMemoryMax) - 24usize];
  ["Offset of field: ADLGetClocksOUT::ulActivityPercent"]
    [::std::mem::offset_of!(ADLGetClocksOUT, ulActivityPercent) - 28usize];
  ["Offset of field: ADLGetClocksOUT::ulCurrentCoreClock"]
    [::std::mem::offset_of!(ADLGetClocksOUT, ulCurrentCoreClock) - 32usize];
  ["Offset of field: ADLGetClocksOUT::ulCurrentMemoryClock"]
    [::std::mem::offset_of!(ADLGetClocksOUT, ulCurrentMemoryClock) - 36usize];
  ["Offset of field: ADLGetClocksOUT::ulReserved"]
    [::std::mem::offset_of!(ADLGetClocksOUT, ulReserved) - 40usize];
};
#[doc = "\n\\brief Structure containing HDTV information for display calls.\n\n This structure is used to retrieve HDTV information information for display calls.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDisplayConfig {
  #[doc = " Size of the structure"]
  pub ulSize: ::std::os::raw::c_long,
  #[doc = " HDTV connector type."]
  pub ulConnectorType: ::std::os::raw::c_long,
  #[doc = " HDTV capabilities."]
  pub ulDeviceData: ::std::os::raw::c_long,
  #[doc = " Overridden HDTV capabilities."]
  pub ulOverridedDeviceData: ::std::os::raw::c_long,
  #[doc = " Reserved field"]
  pub ulReserved: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDisplayConfig"][::std::mem::size_of::<ADLDisplayConfig>() - 20usize];
  ["Alignment of ADLDisplayConfig"][::std::mem::align_of::<ADLDisplayConfig>() - 4usize];
  ["Offset of field: ADLDisplayConfig::ulSize"]
    [::std::mem::offset_of!(ADLDisplayConfig, ulSize) - 0usize];
  ["Offset of field: ADLDisplayConfig::ulConnectorType"]
    [::std::mem::offset_of!(ADLDisplayConfig, ulConnectorType) - 4usize];
  ["Offset of field: ADLDisplayConfig::ulDeviceData"]
    [::std::mem::offset_of!(ADLDisplayConfig, ulDeviceData) - 8usize];
  ["Offset of field: ADLDisplayConfig::ulOverridedDeviceData"]
    [::std::mem::offset_of!(ADLDisplayConfig, ulOverridedDeviceData) - 12usize];
  ["Offset of field: ADLDisplayConfig::ulReserved"]
    [::std::mem::offset_of!(ADLDisplayConfig, ulReserved) - 16usize];
};
#[doc = "\n\\brief Structure containing information about the display device.\n\n This structure is used to store display device information\n such as display index, type, name, connection status, mapped adapter and controller indexes,\n whether or not multiple VPUs are supported, local display connections or not (through Lasso), etc.\n This information can be returned to the user. Alternatively, it can be used to access various driver calls to set\n or fetch various display device related settings upon the user's request.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDisplayID {
  #[doc = " The logical display index belonging to this adapter."]
  pub iDisplayLogicalIndex: ::std::os::raw::c_int,
  #[doc = "\\brief The physical display index.\n For example, display index 2 from adapter 2 can be used by current adapter 1.\\n\n So current adapter may enumerate this adapter as logical display 7 but the physical display\n index is still 2."]
  pub iDisplayPhysicalIndex: ::std::os::raw::c_int,
  #[doc = " The persistent logical adapter index for the display."]
  pub iDisplayLogicalAdapterIndex: ::std::os::raw::c_int,
  #[doc = "\\brief The persistent physical adapter index for the display.\n It can be the current adapter or a non-local adapter. \\n\n If this adapter index is different than the current adapter,\n the Display Non Local flag is set inside DisplayInfoValue."]
  pub iDisplayPhysicalAdapterIndex: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDisplayID"][::std::mem::size_of::<ADLDisplayID>() - 16usize];
  ["Alignment of ADLDisplayID"][::std::mem::align_of::<ADLDisplayID>() - 4usize];
  ["Offset of field: ADLDisplayID::iDisplayLogicalIndex"]
    [::std::mem::offset_of!(ADLDisplayID, iDisplayLogicalIndex) - 0usize];
  ["Offset of field: ADLDisplayID::iDisplayPhysicalIndex"]
    [::std::mem::offset_of!(ADLDisplayID, iDisplayPhysicalIndex) - 4usize];
  ["Offset of field: ADLDisplayID::iDisplayLogicalAdapterIndex"]
    [::std::mem::offset_of!(ADLDisplayID, iDisplayLogicalAdapterIndex) - 8usize];
  ["Offset of field: ADLDisplayID::iDisplayPhysicalAdapterIndex"]
    [::std::mem::offset_of!(ADLDisplayID, iDisplayPhysicalAdapterIndex) - 12usize];
};
#[doc = "\n\\brief Structure containing information about the display device.\n\n This structure is used to store display device information\n such as display index, type, name, connection status, mapped adapter and controller indexes,\n whether or not multiple VPUs are supported, local display connections or not (through Lasso), etc.\n This information can be returned to the user. Alternatively, it can be used to access various driver calls to set\n or fetch various display device related settings upon the user's request.\n \\nosubgrouping\n"]
pub type LPADLDisplayID = *mut ADLDisplayID;
#[doc = "\n\\brief Structure containing information about the display device.\n\n This structure is used to store various information about the display device.  This\n information can be returned to the user, or used to access various driver calls to set\n or fetch various display-device-related settings upon the user's request\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDisplayInfo {
  #[doc = " The DisplayID structure"]
  pub displayID: ADLDisplayID,
  #[doc = "\\deprecated The controller index to which the display is mapped.\\n Will not be used in the future\\n"]
  pub iDisplayControllerIndex: ::std::os::raw::c_int,
  #[doc = " The display's EDID name."]
  pub strDisplayName: [::std::os::raw::c_char; 256usize],
  #[doc = " The display's manufacturer name."]
  pub strDisplayManufacturerName: [::std::os::raw::c_char; 256usize],
  #[doc = " The Display type. For example: CRT, TV, CV, DFP."]
  pub iDisplayType: ::std::os::raw::c_int,
  #[doc = " The display output type. For example: HDMI, SVIDEO, COMPONMNET VIDEO."]
  pub iDisplayOutputType: ::std::os::raw::c_int,
  #[doc = " The connector type for the device."]
  pub iDisplayConnector: ::std::os::raw::c_int,
  #[doc = "\\brief The bit mask identifies the number of bits ADLDisplayInfo is currently using. \\n\n It will be the sum all the bit definitions in ADL_DISPLAY_DISPLAYINFO_xxx."]
  pub iDisplayInfoMask: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the display status. \\ref define_displayinfomask"]
  pub iDisplayInfoValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDisplayInfo"][::std::mem::size_of::<ADLDisplayInfo>() - 552usize];
  ["Alignment of ADLDisplayInfo"][::std::mem::align_of::<ADLDisplayInfo>() - 4usize];
  ["Offset of field: ADLDisplayInfo::displayID"]
    [::std::mem::offset_of!(ADLDisplayInfo, displayID) - 0usize];
  ["Offset of field: ADLDisplayInfo::iDisplayControllerIndex"]
    [::std::mem::offset_of!(ADLDisplayInfo, iDisplayControllerIndex) - 16usize];
  ["Offset of field: ADLDisplayInfo::strDisplayName"]
    [::std::mem::offset_of!(ADLDisplayInfo, strDisplayName) - 20usize];
  ["Offset of field: ADLDisplayInfo::strDisplayManufacturerName"]
    [::std::mem::offset_of!(ADLDisplayInfo, strDisplayManufacturerName) - 276usize];
  ["Offset of field: ADLDisplayInfo::iDisplayType"]
    [::std::mem::offset_of!(ADLDisplayInfo, iDisplayType) - 532usize];
  ["Offset of field: ADLDisplayInfo::iDisplayOutputType"]
    [::std::mem::offset_of!(ADLDisplayInfo, iDisplayOutputType) - 536usize];
  ["Offset of field: ADLDisplayInfo::iDisplayConnector"]
    [::std::mem::offset_of!(ADLDisplayInfo, iDisplayConnector) - 540usize];
  ["Offset of field: ADLDisplayInfo::iDisplayInfoMask"]
    [::std::mem::offset_of!(ADLDisplayInfo, iDisplayInfoMask) - 544usize];
  ["Offset of field: ADLDisplayInfo::iDisplayInfoValue"]
    [::std::mem::offset_of!(ADLDisplayInfo, iDisplayInfoValue) - 548usize];
};
#[doc = "\n\\brief Structure containing information about the display device.\n\n This structure is used to store various information about the display device.  This\n information can be returned to the user, or used to access various driver calls to set\n or fetch various display-device-related settings upon the user's request\n \\nosubgrouping\n"]
pub type LPADLDisplayInfo = *mut ADLDisplayInfo;
#[doc = "\n\\brief Structure containing information about the display port MST device.\n\n This structure is used to store various MST information about the display port device.  This\n information can be returned to the user, or used to access various driver calls to\n fetch various display-device-related settings upon the user's request\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDisplayDPMSTInfo {
  #[doc = " The ADLDisplayID structure"]
  pub displayID: ADLDisplayID,
  #[doc = " total bandwidth available on the DP connector"]
  pub iTotalAvailableBandwidthInMpbs: ::std::os::raw::c_int,
  #[doc = " bandwidth allocated to this display"]
  pub iAllocatedBandwidthInMbps: ::std::os::raw::c_int,
  #[doc = " string identifier for the display"]
  pub strGlobalUniqueIdentifier: [::std::os::raw::c_char; 256usize],
  #[doc = " The link count of relative address, rad[0] upto rad[linkCount] are valid"]
  pub radLinkCount: ::std::os::raw::c_int,
  #[doc = " The physical connector ID, used to identify the physical DP port"]
  pub iPhysicalConnectorID: ::std::os::raw::c_int,
  #[doc = " Relative address, address scheme starts from source side"]
  pub rad: [::std::os::raw::c_char; 15usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDisplayDPMSTInfo"]
    [::std::mem::size_of::<ADLDisplayDPMSTInfo>() - 304usize];
  ["Alignment of ADLDisplayDPMSTInfo"]
    [::std::mem::align_of::<ADLDisplayDPMSTInfo>() - 4usize];
  ["Offset of field: ADLDisplayDPMSTInfo::displayID"]
    [::std::mem::offset_of!(ADLDisplayDPMSTInfo, displayID) - 0usize];
  ["Offset of field: ADLDisplayDPMSTInfo::iTotalAvailableBandwidthInMpbs"][::std::mem::offset_of!(
    ADLDisplayDPMSTInfo,
    iTotalAvailableBandwidthInMpbs
  ) - 16usize];
  ["Offset of field: ADLDisplayDPMSTInfo::iAllocatedBandwidthInMbps"]
    [::std::mem::offset_of!(ADLDisplayDPMSTInfo, iAllocatedBandwidthInMbps) - 20usize];
  ["Offset of field: ADLDisplayDPMSTInfo::strGlobalUniqueIdentifier"]
    [::std::mem::offset_of!(ADLDisplayDPMSTInfo, strGlobalUniqueIdentifier) - 24usize];
  ["Offset of field: ADLDisplayDPMSTInfo::radLinkCount"]
    [::std::mem::offset_of!(ADLDisplayDPMSTInfo, radLinkCount) - 280usize];
  ["Offset of field: ADLDisplayDPMSTInfo::iPhysicalConnectorID"]
    [::std::mem::offset_of!(ADLDisplayDPMSTInfo, iPhysicalConnectorID) - 284usize];
  ["Offset of field: ADLDisplayDPMSTInfo::rad"]
    [::std::mem::offset_of!(ADLDisplayDPMSTInfo, rad) - 288usize];
};
#[doc = "\n\\brief Structure containing information about the display port MST device.\n\n This structure is used to store various MST information about the display port device.  This\n information can be returned to the user, or used to access various driver calls to\n fetch various display-device-related settings upon the user's request\n \\nosubgrouping\n"]
pub type LPADLDisplayDPMSTInfo = *mut ADLDisplayDPMSTInfo;
#[doc = "\n\\brief Structure containing the display mode definition used per controller.\n\n This structure is used to store the display mode definition used per controller.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDisplayMode {
  #[doc = " Vertical resolution (in pixels)."]
  pub iPelsHeight: ::std::os::raw::c_int,
  #[doc = " Horizontal resolution (in pixels)."]
  pub iPelsWidth: ::std::os::raw::c_int,
  #[doc = " Color depth."]
  pub iBitsPerPel: ::std::os::raw::c_int,
  #[doc = " Refresh rate."]
  pub iDisplayFrequency: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDisplayMode"][::std::mem::size_of::<ADLDisplayMode>() - 16usize];
  ["Alignment of ADLDisplayMode"][::std::mem::align_of::<ADLDisplayMode>() - 4usize];
  ["Offset of field: ADLDisplayMode::iPelsHeight"]
    [::std::mem::offset_of!(ADLDisplayMode, iPelsHeight) - 0usize];
  ["Offset of field: ADLDisplayMode::iPelsWidth"]
    [::std::mem::offset_of!(ADLDisplayMode, iPelsWidth) - 4usize];
  ["Offset of field: ADLDisplayMode::iBitsPerPel"]
    [::std::mem::offset_of!(ADLDisplayMode, iBitsPerPel) - 8usize];
  ["Offset of field: ADLDisplayMode::iDisplayFrequency"]
    [::std::mem::offset_of!(ADLDisplayMode, iDisplayFrequency) - 12usize];
};
#[doc = "\n\\brief Structure containing detailed timing parameters.\n\n This structure is used to store the detailed timing parameters.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDetailedTiming {
  #[doc = " Size of the structure."]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " Timing flags. \\ref define_detailed_timing_flags"]
  pub sTimingFlags: ::std::os::raw::c_short,
  #[doc = " Total width (columns)."]
  pub sHTotal: ::std::os::raw::c_short,
  #[doc = " Displayed width."]
  pub sHDisplay: ::std::os::raw::c_short,
  #[doc = " Horizontal sync signal offset."]
  pub sHSyncStart: ::std::os::raw::c_short,
  #[doc = " Horizontal sync signal width."]
  pub sHSyncWidth: ::std::os::raw::c_short,
  #[doc = " Total height (rows)."]
  pub sVTotal: ::std::os::raw::c_short,
  #[doc = " Displayed height."]
  pub sVDisplay: ::std::os::raw::c_short,
  #[doc = " Vertical sync signal offset."]
  pub sVSyncStart: ::std::os::raw::c_short,
  #[doc = " Vertical sync signal width."]
  pub sVSyncWidth: ::std::os::raw::c_short,
  #[doc = " Pixel clock value."]
  pub sPixelClock: ::std::os::raw::c_short,
  #[doc = " Overscan right."]
  pub sHOverscanRight: ::std::os::raw::c_short,
  #[doc = " Overscan left."]
  pub sHOverscanLeft: ::std::os::raw::c_short,
  #[doc = " Overscan bottom."]
  pub sVOverscanBottom: ::std::os::raw::c_short,
  #[doc = " Overscan top."]
  pub sVOverscanTop: ::std::os::raw::c_short,
  pub sOverscan8B: ::std::os::raw::c_short,
  pub sOverscanGR: ::std::os::raw::c_short,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDetailedTiming"][::std::mem::size_of::<ADLDetailedTiming>() - 36usize];
  ["Alignment of ADLDetailedTiming"]
    [::std::mem::align_of::<ADLDetailedTiming>() - 4usize];
  ["Offset of field: ADLDetailedTiming::iSize"]
    [::std::mem::offset_of!(ADLDetailedTiming, iSize) - 0usize];
  ["Offset of field: ADLDetailedTiming::sTimingFlags"]
    [::std::mem::offset_of!(ADLDetailedTiming, sTimingFlags) - 4usize];
  ["Offset of field: ADLDetailedTiming::sHTotal"]
    [::std::mem::offset_of!(ADLDetailedTiming, sHTotal) - 6usize];
  ["Offset of field: ADLDetailedTiming::sHDisplay"]
    [::std::mem::offset_of!(ADLDetailedTiming, sHDisplay) - 8usize];
  ["Offset of field: ADLDetailedTiming::sHSyncStart"]
    [::std::mem::offset_of!(ADLDetailedTiming, sHSyncStart) - 10usize];
  ["Offset of field: ADLDetailedTiming::sHSyncWidth"]
    [::std::mem::offset_of!(ADLDetailedTiming, sHSyncWidth) - 12usize];
  ["Offset of field: ADLDetailedTiming::sVTotal"]
    [::std::mem::offset_of!(ADLDetailedTiming, sVTotal) - 14usize];
  ["Offset of field: ADLDetailedTiming::sVDisplay"]
    [::std::mem::offset_of!(ADLDetailedTiming, sVDisplay) - 16usize];
  ["Offset of field: ADLDetailedTiming::sVSyncStart"]
    [::std::mem::offset_of!(ADLDetailedTiming, sVSyncStart) - 18usize];
  ["Offset of field: ADLDetailedTiming::sVSyncWidth"]
    [::std::mem::offset_of!(ADLDetailedTiming, sVSyncWidth) - 20usize];
  ["Offset of field: ADLDetailedTiming::sPixelClock"]
    [::std::mem::offset_of!(ADLDetailedTiming, sPixelClock) - 22usize];
  ["Offset of field: ADLDetailedTiming::sHOverscanRight"]
    [::std::mem::offset_of!(ADLDetailedTiming, sHOverscanRight) - 24usize];
  ["Offset of field: ADLDetailedTiming::sHOverscanLeft"]
    [::std::mem::offset_of!(ADLDetailedTiming, sHOverscanLeft) - 26usize];
  ["Offset of field: ADLDetailedTiming::sVOverscanBottom"]
    [::std::mem::offset_of!(ADLDetailedTiming, sVOverscanBottom) - 28usize];
  ["Offset of field: ADLDetailedTiming::sVOverscanTop"]
    [::std::mem::offset_of!(ADLDetailedTiming, sVOverscanTop) - 30usize];
  ["Offset of field: ADLDetailedTiming::sOverscan8B"]
    [::std::mem::offset_of!(ADLDetailedTiming, sOverscan8B) - 32usize];
  ["Offset of field: ADLDetailedTiming::sOverscanGR"]
    [::std::mem::offset_of!(ADLDetailedTiming, sOverscanGR) - 34usize];
};
#[doc = "\n\\brief Structure containing display mode information.\n\n This structure is used to store the display mode information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDisplayModeInfo {
  #[doc = " Timing standard of the current mode. \\ref define_modetiming_standard"]
  pub iTimingStandard: ::std::os::raw::c_int,
  #[doc = " Applicable timing standards for the current mode."]
  pub iPossibleStandard: ::std::os::raw::c_int,
  #[doc = " Refresh rate factor."]
  pub iRefreshRate: ::std::os::raw::c_int,
  #[doc = " Num of pixels in a row."]
  pub iPelsWidth: ::std::os::raw::c_int,
  #[doc = " Num of pixels in a column."]
  pub iPelsHeight: ::std::os::raw::c_int,
  #[doc = " Detailed timing parameters."]
  pub sDetailedTiming: ADLDetailedTiming,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDisplayModeInfo"][::std::mem::size_of::<ADLDisplayModeInfo>() - 56usize];
  ["Alignment of ADLDisplayModeInfo"]
    [::std::mem::align_of::<ADLDisplayModeInfo>() - 4usize];
  ["Offset of field: ADLDisplayModeInfo::iTimingStandard"]
    [::std::mem::offset_of!(ADLDisplayModeInfo, iTimingStandard) - 0usize];
  ["Offset of field: ADLDisplayModeInfo::iPossibleStandard"]
    [::std::mem::offset_of!(ADLDisplayModeInfo, iPossibleStandard) - 4usize];
  ["Offset of field: ADLDisplayModeInfo::iRefreshRate"]
    [::std::mem::offset_of!(ADLDisplayModeInfo, iRefreshRate) - 8usize];
  ["Offset of field: ADLDisplayModeInfo::iPelsWidth"]
    [::std::mem::offset_of!(ADLDisplayModeInfo, iPelsWidth) - 12usize];
  ["Offset of field: ADLDisplayModeInfo::iPelsHeight"]
    [::std::mem::offset_of!(ADLDisplayModeInfo, iPelsHeight) - 16usize];
  ["Offset of field: ADLDisplayModeInfo::sDetailedTiming"]
    [::std::mem::offset_of!(ADLDisplayModeInfo, sDetailedTiming) - 20usize];
};
#[doc = "\n \\brief Structure containing information about display property.\n\n This structure is used to store the display property for the current adapter.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDisplayProperty {
  #[doc = " Must be set to sizeof the structure"]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " Must be set to \\ref ADL_DL_DISPLAYPROPERTY_TYPE_EXPANSIONMODE or \\ref ADL_DL_DISPLAYPROPERTY_TYPE_USEUNDERSCANSCALING"]
  pub iPropertyType: ::std::os::raw::c_int,
  #[doc = " Get or Set \\ref ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_CENTER or \\ref ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_FULLSCREEN or \\ref ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_ASPECTRATIO or \\ref ADL_DL_DISPLAYPROPERTY_TYPE_ITCFLAGENABLE"]
  pub iExpansionMode: ::std::os::raw::c_int,
  #[doc = " Display Property supported? 1: Supported, 0: Not supported"]
  pub iSupport: ::std::os::raw::c_int,
  #[doc = " Display Property current value"]
  pub iCurrent: ::std::os::raw::c_int,
  #[doc = " Display Property Default value"]
  pub iDefault: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDisplayProperty"][::std::mem::size_of::<ADLDisplayProperty>() - 24usize];
  ["Alignment of ADLDisplayProperty"]
    [::std::mem::align_of::<ADLDisplayProperty>() - 4usize];
  ["Offset of field: ADLDisplayProperty::iSize"]
    [::std::mem::offset_of!(ADLDisplayProperty, iSize) - 0usize];
  ["Offset of field: ADLDisplayProperty::iPropertyType"]
    [::std::mem::offset_of!(ADLDisplayProperty, iPropertyType) - 4usize];
  ["Offset of field: ADLDisplayProperty::iExpansionMode"]
    [::std::mem::offset_of!(ADLDisplayProperty, iExpansionMode) - 8usize];
  ["Offset of field: ADLDisplayProperty::iSupport"]
    [::std::mem::offset_of!(ADLDisplayProperty, iSupport) - 12usize];
  ["Offset of field: ADLDisplayProperty::iCurrent"]
    [::std::mem::offset_of!(ADLDisplayProperty, iCurrent) - 16usize];
  ["Offset of field: ADLDisplayProperty::iDefault"]
    [::std::mem::offset_of!(ADLDisplayProperty, iDefault) - 20usize];
};
#[doc = "\n\\brief Structure containing information about Clock.\n\n This structure is used to store the clock information for the current adapter\n such as core clock and memory clock info.\n\\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLClockInfo {
  #[doc = " Core clock in 10 KHz."]
  pub iCoreClock: ::std::os::raw::c_int,
  #[doc = " Memory clock in 10 KHz."]
  pub iMemoryClock: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLClockInfo"][::std::mem::size_of::<ADLClockInfo>() - 8usize];
  ["Alignment of ADLClockInfo"][::std::mem::align_of::<ADLClockInfo>() - 4usize];
  ["Offset of field: ADLClockInfo::iCoreClock"]
    [::std::mem::offset_of!(ADLClockInfo, iCoreClock) - 0usize];
  ["Offset of field: ADLClockInfo::iMemoryClock"]
    [::std::mem::offset_of!(ADLClockInfo, iMemoryClock) - 4usize];
};
#[doc = "\n\\brief Structure containing information about Clock.\n\n This structure is used to store the clock information for the current adapter\n such as core clock and memory clock info.\n\\nosubgrouping\n"]
pub type LPADLClockInfo = *mut ADLClockInfo;
#[doc = "\n\\brief Structure containing information about I2C.\n\n This structure is used to store the I2C information for the current adapter.\n This structure is used by the ADL_Display_WriteAndReadI2C() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLI2C {
  #[doc = " Size of the structure"]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " Numerical value representing hardware I2C."]
  pub iLine: ::std::os::raw::c_int,
  #[doc = " The 7-bit I2C slave device address, shifted one bit to the left."]
  pub iAddress: ::std::os::raw::c_int,
  #[doc = " The offset of the data from the address."]
  pub iOffset: ::std::os::raw::c_int,
  #[doc = " Read from or write to slave device. \\ref ADL_DL_I2C_ACTIONREAD or \\ref ADL_DL_I2C_ACTIONWRITE or \\ref ADL_DL_I2C_ACTIONREAD_REPEATEDSTART"]
  pub iAction: ::std::os::raw::c_int,
  #[doc = " I2C clock speed in KHz."]
  pub iSpeed: ::std::os::raw::c_int,
  #[doc = " A numerical value representing the number of bytes to be sent or received on the I2C bus."]
  pub iDataSize: ::std::os::raw::c_int,
  #[doc = " Address of the characters which are to be sent or received on the I2C bus."]
  pub pcData: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLI2C"][::std::mem::size_of::<ADLI2C>() - 40usize];
  ["Alignment of ADLI2C"][::std::mem::align_of::<ADLI2C>() - 8usize];
  ["Offset of field: ADLI2C::iSize"][::std::mem::offset_of!(ADLI2C, iSize) - 0usize];
  ["Offset of field: ADLI2C::iLine"][::std::mem::offset_of!(ADLI2C, iLine) - 4usize];
  ["Offset of field: ADLI2C::iAddress"]
    [::std::mem::offset_of!(ADLI2C, iAddress) - 8usize];
  ["Offset of field: ADLI2C::iOffset"][::std::mem::offset_of!(ADLI2C, iOffset) - 12usize];
  ["Offset of field: ADLI2C::iAction"][::std::mem::offset_of!(ADLI2C, iAction) - 16usize];
  ["Offset of field: ADLI2C::iSpeed"][::std::mem::offset_of!(ADLI2C, iSpeed) - 20usize];
  ["Offset of field: ADLI2C::iDataSize"]
    [::std::mem::offset_of!(ADLI2C, iDataSize) - 24usize];
  ["Offset of field: ADLI2C::pcData"][::std::mem::offset_of!(ADLI2C, pcData) - 32usize];
};
#[doc = "\n\\brief Structure containing information about EDID data.\n\n This structure is used to store the information about EDID data for the adapter.\n This structure is used by the ADL_Display_EdidData_Get() and ADL_Display_EdidData_Set() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDisplayEDIDData {
  #[doc = " Size of the structure"]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " Set to 0"]
  pub iFlag: ::std::os::raw::c_int,
  #[doc = " Size of cEDIDData. Set by ADL_Display_EdidData_Get() upon return"]
  pub iEDIDSize: ::std::os::raw::c_int,
  #[doc = " 0, 1 or 2. If set to 3 or above an error ADL_ERR_INVALID_PARAM is generated"]
  pub iBlockIndex: ::std::os::raw::c_int,
  #[doc = " EDID data"]
  pub cEDIDData: [::std::os::raw::c_char; 256usize],
  #[doc = " Reserved"]
  pub iReserved: [::std::os::raw::c_int; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDisplayEDIDData"][::std::mem::size_of::<ADLDisplayEDIDData>() - 288usize];
  ["Alignment of ADLDisplayEDIDData"]
    [::std::mem::align_of::<ADLDisplayEDIDData>() - 4usize];
  ["Offset of field: ADLDisplayEDIDData::iSize"]
    [::std::mem::offset_of!(ADLDisplayEDIDData, iSize) - 0usize];
  ["Offset of field: ADLDisplayEDIDData::iFlag"]
    [::std::mem::offset_of!(ADLDisplayEDIDData, iFlag) - 4usize];
  ["Offset of field: ADLDisplayEDIDData::iEDIDSize"]
    [::std::mem::offset_of!(ADLDisplayEDIDData, iEDIDSize) - 8usize];
  ["Offset of field: ADLDisplayEDIDData::iBlockIndex"]
    [::std::mem::offset_of!(ADLDisplayEDIDData, iBlockIndex) - 12usize];
  ["Offset of field: ADLDisplayEDIDData::cEDIDData"]
    [::std::mem::offset_of!(ADLDisplayEDIDData, cEDIDData) - 16usize];
  ["Offset of field: ADLDisplayEDIDData::iReserved"]
    [::std::mem::offset_of!(ADLDisplayEDIDData, iReserved) - 272usize];
};
#[doc = "\n\\brief Structure containing information about input of controller overlay adjustment.\n\n This structure is used to store the information about input of controller overlay adjustment for the adapter.\n This structure is used by the ADL_Display_ControllerOverlayAdjustmentCaps_Get, ADL_Display_ControllerOverlayAdjustmentData_Get, and\n ADL_Display_ControllerOverlayAdjustmentData_Set() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLControllerOverlayInput {
  #[doc = " Should be set to the sizeof the structure"]
  pub iSize: ::std::os::raw::c_int,
  #[doc = "\\ref ADL_DL_CONTROLLER_OVERLAY_ALPHA or \\ref ADL_DL_CONTROLLER_OVERLAY_ALPHAPERPIX"]
  pub iOverlayAdjust: ::std::os::raw::c_int,
  #[doc = " Data."]
  pub iValue: ::std::os::raw::c_int,
  #[doc = " Should be 0."]
  pub iReserved: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLControllerOverlayInput"]
    [::std::mem::size_of::<ADLControllerOverlayInput>() - 16usize];
  ["Alignment of ADLControllerOverlayInput"]
    [::std::mem::align_of::<ADLControllerOverlayInput>() - 4usize];
  ["Offset of field: ADLControllerOverlayInput::iSize"]
    [::std::mem::offset_of!(ADLControllerOverlayInput, iSize) - 0usize];
  ["Offset of field: ADLControllerOverlayInput::iOverlayAdjust"]
    [::std::mem::offset_of!(ADLControllerOverlayInput, iOverlayAdjust) - 4usize];
  ["Offset of field: ADLControllerOverlayInput::iValue"]
    [::std::mem::offset_of!(ADLControllerOverlayInput, iValue) - 8usize];
  ["Offset of field: ADLControllerOverlayInput::iReserved"]
    [::std::mem::offset_of!(ADLControllerOverlayInput, iReserved) - 12usize];
};
#[doc = "\n\\brief Structure containing information about overlay adjustment.\n\n This structure is used to store the information about overlay adjustment for the adapter.\n This structure is used by the ADLControllerOverlayInfo() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLAdjustmentinfo {
  #[doc = " Default value"]
  pub iDefault: ::std::os::raw::c_int,
  #[doc = " Minimum value"]
  pub iMin: ::std::os::raw::c_int,
  #[doc = " Maximum Value"]
  pub iMax: ::std::os::raw::c_int,
  #[doc = " Step value"]
  pub iStep: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLAdjustmentinfo"][::std::mem::size_of::<ADLAdjustmentinfo>() - 16usize];
  ["Alignment of ADLAdjustmentinfo"]
    [::std::mem::align_of::<ADLAdjustmentinfo>() - 4usize];
  ["Offset of field: ADLAdjustmentinfo::iDefault"]
    [::std::mem::offset_of!(ADLAdjustmentinfo, iDefault) - 0usize];
  ["Offset of field: ADLAdjustmentinfo::iMin"]
    [::std::mem::offset_of!(ADLAdjustmentinfo, iMin) - 4usize];
  ["Offset of field: ADLAdjustmentinfo::iMax"]
    [::std::mem::offset_of!(ADLAdjustmentinfo, iMax) - 8usize];
  ["Offset of field: ADLAdjustmentinfo::iStep"]
    [::std::mem::offset_of!(ADLAdjustmentinfo, iStep) - 12usize];
};
#[doc = "\n\\brief Structure containing information about controller overlay information.\n\n This structure is used to store information about controller overlay info for the adapter.\n This structure is used by the ADL_Display_ControllerOverlayAdjustmentCaps_Get() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLControllerOverlayInfo {
  #[doc = " Should be set to the sizeof the structure"]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " Data."]
  pub sOverlayInfo: ADLAdjustmentinfo,
  #[doc = " Should be 0."]
  pub iReserved: [::std::os::raw::c_int; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLControllerOverlayInfo"]
    [::std::mem::size_of::<ADLControllerOverlayInfo>() - 32usize];
  ["Alignment of ADLControllerOverlayInfo"]
    [::std::mem::align_of::<ADLControllerOverlayInfo>() - 4usize];
  ["Offset of field: ADLControllerOverlayInfo::iSize"]
    [::std::mem::offset_of!(ADLControllerOverlayInfo, iSize) - 0usize];
  ["Offset of field: ADLControllerOverlayInfo::sOverlayInfo"]
    [::std::mem::offset_of!(ADLControllerOverlayInfo, sOverlayInfo) - 4usize];
  ["Offset of field: ADLControllerOverlayInfo::iReserved"]
    [::std::mem::offset_of!(ADLControllerOverlayInfo, iReserved) - 20usize];
};
#[doc = "\n\\brief Structure containing GL-Sync module information.\n\n This structure is used to retrieve GL-Sync module information for\n Workstation Framelock/Genlock.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLGLSyncModuleID {
  #[doc = " Unique GL-Sync module ID."]
  pub iModuleID: ::std::os::raw::c_int,
  #[doc = " GL-Sync GPU port index (to be passed into ADLGLSyncGenlockConfig.lSignalSource and ADLGlSyncPortControl.lSignalSource)."]
  pub iGlSyncGPUPort: ::std::os::raw::c_int,
  #[doc = " GL-Sync module firmware version of Boot Sector."]
  pub iFWBootSectorVersion: ::std::os::raw::c_int,
  #[doc = " GL-Sync module firmware version of User Sector."]
  pub iFWUserSectorVersion: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLGLSyncModuleID"][::std::mem::size_of::<ADLGLSyncModuleID>() - 16usize];
  ["Alignment of ADLGLSyncModuleID"]
    [::std::mem::align_of::<ADLGLSyncModuleID>() - 4usize];
  ["Offset of field: ADLGLSyncModuleID::iModuleID"]
    [::std::mem::offset_of!(ADLGLSyncModuleID, iModuleID) - 0usize];
  ["Offset of field: ADLGLSyncModuleID::iGlSyncGPUPort"]
    [::std::mem::offset_of!(ADLGLSyncModuleID, iGlSyncGPUPort) - 4usize];
  ["Offset of field: ADLGLSyncModuleID::iFWBootSectorVersion"]
    [::std::mem::offset_of!(ADLGLSyncModuleID, iFWBootSectorVersion) - 8usize];
  ["Offset of field: ADLGLSyncModuleID::iFWUserSectorVersion"]
    [::std::mem::offset_of!(ADLGLSyncModuleID, iFWUserSectorVersion) - 12usize];
};
#[doc = "\n\\brief Structure containing GL-Sync module information.\n\n This structure is used to retrieve GL-Sync module information for\n Workstation Framelock/Genlock.\n \\nosubgrouping\n"]
pub type LPADLGLSyncModuleID = *mut ADLGLSyncModuleID;
#[doc = "\n\\brief Structure containing GL-Sync ports capabilities.\n\n This structure is used to retrieve hardware capabilities for the ports of the GL-Sync module\n for Workstation Framelock/Genlock (such as port type and number of associated LEDs).\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLGLSyncPortCaps {
  #[doc = " Port type. Bitfield of ADL_GLSYNC_PORTTYPE_*  \\ref define_glsync"]
  pub iPortType: ::std::os::raw::c_int,
  #[doc = " Number of LEDs associated for this port."]
  pub iNumOfLEDs: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLGLSyncPortCaps"][::std::mem::size_of::<ADLGLSyncPortCaps>() - 8usize];
  ["Alignment of ADLGLSyncPortCaps"]
    [::std::mem::align_of::<ADLGLSyncPortCaps>() - 4usize];
  ["Offset of field: ADLGLSyncPortCaps::iPortType"]
    [::std::mem::offset_of!(ADLGLSyncPortCaps, iPortType) - 0usize];
  ["Offset of field: ADLGLSyncPortCaps::iNumOfLEDs"]
    [::std::mem::offset_of!(ADLGLSyncPortCaps, iNumOfLEDs) - 4usize];
};
#[doc = "\n\\brief Structure containing GL-Sync ports capabilities.\n\n This structure is used to retrieve hardware capabilities for the ports of the GL-Sync module\n for Workstation Framelock/Genlock (such as port type and number of associated LEDs).\n \\nosubgrouping\n"]
pub type LPADLGLSyncPortCaps = *mut ADLGLSyncPortCaps;
#[doc = "\n\\brief Structure containing GL-Sync Genlock settings.\n\n This structure is used to get and set genlock settings for the GPU ports of the GL-Sync module\n for Workstation Framelock/Genlock.\\n\n \\see define_glsync\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLGLSyncGenlockConfig {
  #[doc = " Specifies what fields in this structure are valid \\ref define_glsync"]
  pub iValidMask: ::std::os::raw::c_int,
  #[doc = " Delay (ms) generating a sync signal."]
  pub iSyncDelay: ::std::os::raw::c_int,
  #[doc = " Vector of framelock control bits. Bitfield of ADL_GLSYNC_FRAMELOCKCNTL_* \\ref define_glsync"]
  pub iFramelockCntlVector: ::std::os::raw::c_int,
  #[doc = " Source of the sync signal. Either GL_Sync GPU Port index or ADL_GLSYNC_SIGNALSOURCE_* \\ref define_glsync"]
  pub iSignalSource: ::std::os::raw::c_int,
  #[doc = " Use sampled sync signal. A value of 0 specifies no sampling."]
  pub iSampleRate: ::std::os::raw::c_int,
  #[doc = " For interlaced sync signals, the value can be ADL_GLSYNC_SYNCFIELD_1 or *_BOTH \\ref define_glsync"]
  pub iSyncField: ::std::os::raw::c_int,
  #[doc = " The signal edge that should trigger synchronization. ADL_GLSYNC_TRIGGEREDGE_* \\ref define_glsync"]
  pub iTriggerEdge: ::std::os::raw::c_int,
  #[doc = " Scan rate multiplier applied to the sync signal. ADL_GLSYNC_SCANRATECOEFF_* \\ref define_glsync"]
  pub iScanRateCoeff: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLGLSyncGenlockConfig"]
    [::std::mem::size_of::<ADLGLSyncGenlockConfig>() - 32usize];
  ["Alignment of ADLGLSyncGenlockConfig"]
    [::std::mem::align_of::<ADLGLSyncGenlockConfig>() - 4usize];
  ["Offset of field: ADLGLSyncGenlockConfig::iValidMask"]
    [::std::mem::offset_of!(ADLGLSyncGenlockConfig, iValidMask) - 0usize];
  ["Offset of field: ADLGLSyncGenlockConfig::iSyncDelay"]
    [::std::mem::offset_of!(ADLGLSyncGenlockConfig, iSyncDelay) - 4usize];
  ["Offset of field: ADLGLSyncGenlockConfig::iFramelockCntlVector"]
    [::std::mem::offset_of!(ADLGLSyncGenlockConfig, iFramelockCntlVector) - 8usize];
  ["Offset of field: ADLGLSyncGenlockConfig::iSignalSource"]
    [::std::mem::offset_of!(ADLGLSyncGenlockConfig, iSignalSource) - 12usize];
  ["Offset of field: ADLGLSyncGenlockConfig::iSampleRate"]
    [::std::mem::offset_of!(ADLGLSyncGenlockConfig, iSampleRate) - 16usize];
  ["Offset of field: ADLGLSyncGenlockConfig::iSyncField"]
    [::std::mem::offset_of!(ADLGLSyncGenlockConfig, iSyncField) - 20usize];
  ["Offset of field: ADLGLSyncGenlockConfig::iTriggerEdge"]
    [::std::mem::offset_of!(ADLGLSyncGenlockConfig, iTriggerEdge) - 24usize];
  ["Offset of field: ADLGLSyncGenlockConfig::iScanRateCoeff"]
    [::std::mem::offset_of!(ADLGLSyncGenlockConfig, iScanRateCoeff) - 28usize];
};
#[doc = "\n\\brief Structure containing GL-Sync Genlock settings.\n\n This structure is used to get and set genlock settings for the GPU ports of the GL-Sync module\n for Workstation Framelock/Genlock.\\n\n \\see define_glsync\n \\nosubgrouping\n"]
pub type LPADLGLSyncGenlockConfig = *mut ADLGLSyncGenlockConfig;
#[doc = "\n\\brief Structure containing GL-Sync port information.\n\n This structure is used to get status of the GL-Sync ports (BNC or RJ45s)\n for Workstation Framelock/Genlock.\n \\see define_glsync\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLGlSyncPortInfo {
  #[doc = " Type of GL-Sync port (ADL_GLSYNC_PORT_*)."]
  pub iPortType: ::std::os::raw::c_int,
  #[doc = " The number of LEDs for this port. It's also filled within ADLGLSyncPortCaps."]
  pub iNumOfLEDs: ::std::os::raw::c_int,
  #[doc = " Port state ADL_GLSYNC_PORTSTATE_*  \\ref define_glsync"]
  pub iPortState: ::std::os::raw::c_int,
  #[doc = " Scanned frequency for this port (vertical refresh rate in milliHz; 60000 means 60 Hz)."]
  pub iFrequency: ::std::os::raw::c_int,
  #[doc = " Used for ADL_GLSYNC_PORT_BNC. It is ADL_GLSYNC_SIGNALTYPE_*   \\ref define_glsync"]
  pub iSignalType: ::std::os::raw::c_int,
  #[doc = " Used for ADL_GLSYNC_PORT_RJ45PORT*. It is GL_Sync GPU Port index or ADL_GLSYNC_SIGNALSOURCE_*.  \\ref define_glsync"]
  pub iSignalSource: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLGlSyncPortInfo"][::std::mem::size_of::<ADLGlSyncPortInfo>() - 24usize];
  ["Alignment of ADLGlSyncPortInfo"]
    [::std::mem::align_of::<ADLGlSyncPortInfo>() - 4usize];
  ["Offset of field: ADLGlSyncPortInfo::iPortType"]
    [::std::mem::offset_of!(ADLGlSyncPortInfo, iPortType) - 0usize];
  ["Offset of field: ADLGlSyncPortInfo::iNumOfLEDs"]
    [::std::mem::offset_of!(ADLGlSyncPortInfo, iNumOfLEDs) - 4usize];
  ["Offset of field: ADLGlSyncPortInfo::iPortState"]
    [::std::mem::offset_of!(ADLGlSyncPortInfo, iPortState) - 8usize];
  ["Offset of field: ADLGlSyncPortInfo::iFrequency"]
    [::std::mem::offset_of!(ADLGlSyncPortInfo, iFrequency) - 12usize];
  ["Offset of field: ADLGlSyncPortInfo::iSignalType"]
    [::std::mem::offset_of!(ADLGlSyncPortInfo, iSignalType) - 16usize];
  ["Offset of field: ADLGlSyncPortInfo::iSignalSource"]
    [::std::mem::offset_of!(ADLGlSyncPortInfo, iSignalSource) - 20usize];
};
#[doc = "\n\\brief Structure containing GL-Sync port information.\n\n This structure is used to get status of the GL-Sync ports (BNC or RJ45s)\n for Workstation Framelock/Genlock.\n \\see define_glsync\n \\nosubgrouping\n"]
pub type LPADLGlSyncPortInfo = *mut ADLGlSyncPortInfo;
#[doc = "\n\\brief Structure containing GL-Sync port control settings.\n\n This structure is used to configure the GL-Sync ports (RJ45s only)\n for Workstation Framelock/Genlock.\n \\see define_glsync\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLGlSyncPortControl {
  #[doc = " Port to control ADL_GLSYNC_PORT_RJ45PORT1 or ADL_GLSYNC_PORT_RJ45PORT2   \\ref define_glsync"]
  pub iPortType: ::std::os::raw::c_int,
  #[doc = " Port control data ADL_GLSYNC_PORTCNTL_*   \\ref define_glsync"]
  pub iControlVector: ::std::os::raw::c_int,
  #[doc = " Source of the sync signal. Either GL_Sync GPU Port index or ADL_GLSYNC_SIGNALSOURCE_*   \\ref define_glsync"]
  pub iSignalSource: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLGlSyncPortControl"]
    [::std::mem::size_of::<ADLGlSyncPortControl>() - 12usize];
  ["Alignment of ADLGlSyncPortControl"]
    [::std::mem::align_of::<ADLGlSyncPortControl>() - 4usize];
  ["Offset of field: ADLGlSyncPortControl::iPortType"]
    [::std::mem::offset_of!(ADLGlSyncPortControl, iPortType) - 0usize];
  ["Offset of field: ADLGlSyncPortControl::iControlVector"]
    [::std::mem::offset_of!(ADLGlSyncPortControl, iControlVector) - 4usize];
  ["Offset of field: ADLGlSyncPortControl::iSignalSource"]
    [::std::mem::offset_of!(ADLGlSyncPortControl, iSignalSource) - 8usize];
};
#[doc = "\n\\brief Structure containing GL-Sync mode of a display.\n\n This structure is used to get and set GL-Sync mode settings for a display connected to\n an adapter attached to a GL-Sync module for Workstation Framelock/Genlock.\n \\see define_glsync\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLGlSyncMode {
  #[doc = " Mode control vector. Bitfield of ADL_GLSYNC_MODECNTL_*   \\ref define_glsync"]
  pub iControlVector: ::std::os::raw::c_int,
  #[doc = " Mode status vector. Bitfield of ADL_GLSYNC_MODECNTL_STATUS_*   \\ref define_glsync"]
  pub iStatusVector: ::std::os::raw::c_int,
  #[doc = " Index of GL-Sync connector used to genlock the display/controller."]
  pub iGLSyncConnectorIndex: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLGlSyncMode"][::std::mem::size_of::<ADLGlSyncMode>() - 12usize];
  ["Alignment of ADLGlSyncMode"][::std::mem::align_of::<ADLGlSyncMode>() - 4usize];
  ["Offset of field: ADLGlSyncMode::iControlVector"]
    [::std::mem::offset_of!(ADLGlSyncMode, iControlVector) - 0usize];
  ["Offset of field: ADLGlSyncMode::iStatusVector"]
    [::std::mem::offset_of!(ADLGlSyncMode, iStatusVector) - 4usize];
  ["Offset of field: ADLGlSyncMode::iGLSyncConnectorIndex"]
    [::std::mem::offset_of!(ADLGlSyncMode, iGLSyncConnectorIndex) - 8usize];
};
#[doc = "\n\\brief Structure containing GL-Sync mode of a display.\n\n This structure is used to get and set GL-Sync mode settings for a display connected to\n an adapter attached to a GL-Sync module for Workstation Framelock/Genlock.\n \\see define_glsync\n \\nosubgrouping\n"]
pub type LPADLGlSyncMode = *mut ADLGlSyncMode;
#[doc = "\n\\brief Structure containing GL-Sync mode of a display.\n\n This structure is used to get and set GL-Sync mode settings for a display connected to\n an adapter attached to a GL-Sync module for Workstation Framelock/Genlock.\n \\see define_glsync\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLGlSyncMode2 {
  #[doc = " Mode control vector. Bitfield of ADL_GLSYNC_MODECNTL_*   \\ref define_glsync"]
  pub iControlVector: ::std::os::raw::c_int,
  #[doc = " Mode status vector. Bitfield of ADL_GLSYNC_MODECNTL_STATUS_*   \\ref define_glsync"]
  pub iStatusVector: ::std::os::raw::c_int,
  #[doc = " Index of GL-Sync connector used to genlock the display/controller."]
  pub iGLSyncConnectorIndex: ::std::os::raw::c_int,
  #[doc = " Index of the display to which this GLSync applies to."]
  pub iDisplayIndex: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLGlSyncMode2"][::std::mem::size_of::<ADLGlSyncMode2>() - 16usize];
  ["Alignment of ADLGlSyncMode2"][::std::mem::align_of::<ADLGlSyncMode2>() - 4usize];
  ["Offset of field: ADLGlSyncMode2::iControlVector"]
    [::std::mem::offset_of!(ADLGlSyncMode2, iControlVector) - 0usize];
  ["Offset of field: ADLGlSyncMode2::iStatusVector"]
    [::std::mem::offset_of!(ADLGlSyncMode2, iStatusVector) - 4usize];
  ["Offset of field: ADLGlSyncMode2::iGLSyncConnectorIndex"]
    [::std::mem::offset_of!(ADLGlSyncMode2, iGLSyncConnectorIndex) - 8usize];
  ["Offset of field: ADLGlSyncMode2::iDisplayIndex"]
    [::std::mem::offset_of!(ADLGlSyncMode2, iDisplayIndex) - 12usize];
};
#[doc = "\n\\brief Structure containing GL-Sync mode of a display.\n\n This structure is used to get and set GL-Sync mode settings for a display connected to\n an adapter attached to a GL-Sync module for Workstation Framelock/Genlock.\n \\see define_glsync\n \\nosubgrouping\n"]
pub type LPADLGlSyncMode2 = *mut ADLGlSyncMode2;
#[doc = "\n\\brief Structure containing the packet info of a display.\n\n This structure is used to get and set the packet information of a display.\n This structure is used by ADLDisplayDataPacket.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLInfoPacket {
  pub hb0: ::std::os::raw::c_char,
  pub hb1: ::std::os::raw::c_char,
  pub hb2: ::std::os::raw::c_char,
  #[doc = " sb0~sb27"]
  pub sb: [::std::os::raw::c_char; 28usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLInfoPacket"][::std::mem::size_of::<ADLInfoPacket>() - 31usize];
  ["Alignment of ADLInfoPacket"][::std::mem::align_of::<ADLInfoPacket>() - 1usize];
  ["Offset of field: ADLInfoPacket::hb0"]
    [::std::mem::offset_of!(ADLInfoPacket, hb0) - 0usize];
  ["Offset of field: ADLInfoPacket::hb1"]
    [::std::mem::offset_of!(ADLInfoPacket, hb1) - 1usize];
  ["Offset of field: ADLInfoPacket::hb2"]
    [::std::mem::offset_of!(ADLInfoPacket, hb2) - 2usize];
  ["Offset of field: ADLInfoPacket::sb"]
    [::std::mem::offset_of!(ADLInfoPacket, sb) - 3usize];
};
#[doc = "\n\\brief Structure containing the AVI packet info of a display.\n\n This structure is used to get and set AVI the packet info of a display.\n This structure is used by ADLDisplayDataPacket.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLAVIInfoPacket {
  #[doc = " byte 3, bit 7"]
  pub bPB3_ITC: ::std::os::raw::c_char,
  #[doc = " byte 5, bit [7:4]."]
  pub bPB5: ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLAVIInfoPacket"][::std::mem::size_of::<ADLAVIInfoPacket>() - 2usize];
  ["Alignment of ADLAVIInfoPacket"][::std::mem::align_of::<ADLAVIInfoPacket>() - 1usize];
  ["Offset of field: ADLAVIInfoPacket::bPB3_ITC"]
    [::std::mem::offset_of!(ADLAVIInfoPacket, bPB3_ITC) - 0usize];
  ["Offset of field: ADLAVIInfoPacket::bPB5"]
    [::std::mem::offset_of!(ADLAVIInfoPacket, bPB5) - 1usize];
};
#[doc = "\n\\brief Structure containing the Overdrive clock setting.\n\n This structure is used to get the Overdrive clock setting.\n This structure is used by ADLAdapterODClockInfo.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLODClockSetting {
  #[doc = " Deafult clock"]
  pub iDefaultClock: ::std::os::raw::c_int,
  #[doc = " Current clock"]
  pub iCurrentClock: ::std::os::raw::c_int,
  #[doc = " Maximum clcok"]
  pub iMaxClock: ::std::os::raw::c_int,
  #[doc = " Minimum clock"]
  pub iMinClock: ::std::os::raw::c_int,
  #[doc = " Requested clcock"]
  pub iRequestedClock: ::std::os::raw::c_int,
  #[doc = " Step"]
  pub iStepClock: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLODClockSetting"][::std::mem::size_of::<ADLODClockSetting>() - 24usize];
  ["Alignment of ADLODClockSetting"]
    [::std::mem::align_of::<ADLODClockSetting>() - 4usize];
  ["Offset of field: ADLODClockSetting::iDefaultClock"]
    [::std::mem::offset_of!(ADLODClockSetting, iDefaultClock) - 0usize];
  ["Offset of field: ADLODClockSetting::iCurrentClock"]
    [::std::mem::offset_of!(ADLODClockSetting, iCurrentClock) - 4usize];
  ["Offset of field: ADLODClockSetting::iMaxClock"]
    [::std::mem::offset_of!(ADLODClockSetting, iMaxClock) - 8usize];
  ["Offset of field: ADLODClockSetting::iMinClock"]
    [::std::mem::offset_of!(ADLODClockSetting, iMinClock) - 12usize];
  ["Offset of field: ADLODClockSetting::iRequestedClock"]
    [::std::mem::offset_of!(ADLODClockSetting, iRequestedClock) - 16usize];
  ["Offset of field: ADLODClockSetting::iStepClock"]
    [::std::mem::offset_of!(ADLODClockSetting, iStepClock) - 20usize];
};
#[doc = "\n\\brief Structure containing the Overdrive clock information.\n\n This structure is used to get the Overdrive clock information.\n This structure is used by the ADL_Display_ODClockInfo_Get() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLAdapterODClockInfo {
  #[doc = " Size of the structure"]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " Flag \\ref define_clockinfo_flags"]
  pub iFlags: ::std::os::raw::c_int,
  #[doc = " Memory Clock"]
  pub sMemoryClock: ADLODClockSetting,
  #[doc = " Engine Clock"]
  pub sEngineClock: ADLODClockSetting,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLAdapterODClockInfo"]
    [::std::mem::size_of::<ADLAdapterODClockInfo>() - 56usize];
  ["Alignment of ADLAdapterODClockInfo"]
    [::std::mem::align_of::<ADLAdapterODClockInfo>() - 4usize];
  ["Offset of field: ADLAdapterODClockInfo::iSize"]
    [::std::mem::offset_of!(ADLAdapterODClockInfo, iSize) - 0usize];
  ["Offset of field: ADLAdapterODClockInfo::iFlags"]
    [::std::mem::offset_of!(ADLAdapterODClockInfo, iFlags) - 4usize];
  ["Offset of field: ADLAdapterODClockInfo::sMemoryClock"]
    [::std::mem::offset_of!(ADLAdapterODClockInfo, sMemoryClock) - 8usize];
  ["Offset of field: ADLAdapterODClockInfo::sEngineClock"]
    [::std::mem::offset_of!(ADLAdapterODClockInfo, sEngineClock) - 32usize];
};
#[doc = "\n\\brief Structure containing the Overdrive clock configuration.\n\n This structure is used to set the Overdrive clock configuration.\n This structure is used by the ADL_Display_ODClockConfig_Set() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLAdapterODClockConfig {
  #[doc = " Size of the structure"]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " Flag \\ref define_clockinfo_flags"]
  pub iFlags: ::std::os::raw::c_int,
  #[doc = " Memory Clock"]
  pub iMemoryClock: ::std::os::raw::c_int,
  #[doc = " Engine Clock"]
  pub iEngineClock: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLAdapterODClockConfig"]
    [::std::mem::size_of::<ADLAdapterODClockConfig>() - 16usize];
  ["Alignment of ADLAdapterODClockConfig"]
    [::std::mem::align_of::<ADLAdapterODClockConfig>() - 4usize];
  ["Offset of field: ADLAdapterODClockConfig::iSize"]
    [::std::mem::offset_of!(ADLAdapterODClockConfig, iSize) - 0usize];
  ["Offset of field: ADLAdapterODClockConfig::iFlags"]
    [::std::mem::offset_of!(ADLAdapterODClockConfig, iFlags) - 4usize];
  ["Offset of field: ADLAdapterODClockConfig::iMemoryClock"]
    [::std::mem::offset_of!(ADLAdapterODClockConfig, iMemoryClock) - 8usize];
  ["Offset of field: ADLAdapterODClockConfig::iEngineClock"]
    [::std::mem::offset_of!(ADLAdapterODClockConfig, iEngineClock) - 12usize];
};
#[doc = "\n\\brief Structure containing information about current power management related activity.\n\n This structure is used to store information about current power management related activity.\n This structure (Overdrive 5 interfaces) is used by the ADL_PM_CurrentActivity_Get() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLPMActivity {
  #[doc = " Must be set to the size of the structure"]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " Current engine clock."]
  pub iEngineClock: ::std::os::raw::c_int,
  #[doc = " Current memory clock."]
  pub iMemoryClock: ::std::os::raw::c_int,
  #[doc = " Current core voltage."]
  pub iVddc: ::std::os::raw::c_int,
  #[doc = " GPU utilization."]
  pub iActivityPercent: ::std::os::raw::c_int,
  #[doc = " Performance level index."]
  pub iCurrentPerformanceLevel: ::std::os::raw::c_int,
  #[doc = " Current PCIE bus speed."]
  pub iCurrentBusSpeed: ::std::os::raw::c_int,
  #[doc = " Number of PCIE bus lanes."]
  pub iCurrentBusLanes: ::std::os::raw::c_int,
  #[doc = " Maximum number of PCIE bus lanes."]
  pub iMaximumBusLanes: ::std::os::raw::c_int,
  #[doc = " Reserved for future purposes."]
  pub iReserved: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLPMActivity"][::std::mem::size_of::<ADLPMActivity>() - 40usize];
  ["Alignment of ADLPMActivity"][::std::mem::align_of::<ADLPMActivity>() - 4usize];
  ["Offset of field: ADLPMActivity::iSize"]
    [::std::mem::offset_of!(ADLPMActivity, iSize) - 0usize];
  ["Offset of field: ADLPMActivity::iEngineClock"]
    [::std::mem::offset_of!(ADLPMActivity, iEngineClock) - 4usize];
  ["Offset of field: ADLPMActivity::iMemoryClock"]
    [::std::mem::offset_of!(ADLPMActivity, iMemoryClock) - 8usize];
  ["Offset of field: ADLPMActivity::iVddc"]
    [::std::mem::offset_of!(ADLPMActivity, iVddc) - 12usize];
  ["Offset of field: ADLPMActivity::iActivityPercent"]
    [::std::mem::offset_of!(ADLPMActivity, iActivityPercent) - 16usize];
  ["Offset of field: ADLPMActivity::iCurrentPerformanceLevel"]
    [::std::mem::offset_of!(ADLPMActivity, iCurrentPerformanceLevel) - 20usize];
  ["Offset of field: ADLPMActivity::iCurrentBusSpeed"]
    [::std::mem::offset_of!(ADLPMActivity, iCurrentBusSpeed) - 24usize];
  ["Offset of field: ADLPMActivity::iCurrentBusLanes"]
    [::std::mem::offset_of!(ADLPMActivity, iCurrentBusLanes) - 28usize];
  ["Offset of field: ADLPMActivity::iMaximumBusLanes"]
    [::std::mem::offset_of!(ADLPMActivity, iMaximumBusLanes) - 32usize];
  ["Offset of field: ADLPMActivity::iReserved"]
    [::std::mem::offset_of!(ADLPMActivity, iReserved) - 36usize];
};
#[doc = "\n\\brief Structure containing information about thermal controller.\n\n This structure is used to store information about thermal controller.\n This structure is used by ADL_PM_ThermalDevices_Enum.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLThermalControllerInfo {
  #[doc = " Must be set to the size of the structure"]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " Possible valies: \\ref ADL_DL_THERMAL_DOMAIN_OTHER or \\ref ADL_DL_THERMAL_DOMAIN_GPU."]
  pub iThermalDomain: ::std::os::raw::c_int,
  #[doc = "    GPU 0, 1, etc."]
  pub iDomainIndex: ::std::os::raw::c_int,
  #[doc = " Possible valies: \\ref ADL_DL_THERMAL_FLAG_INTERRUPT or \\ref ADL_DL_THERMAL_FLAG_FANCONTROL"]
  pub iFlags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLThermalControllerInfo"]
    [::std::mem::size_of::<ADLThermalControllerInfo>() - 16usize];
  ["Alignment of ADLThermalControllerInfo"]
    [::std::mem::align_of::<ADLThermalControllerInfo>() - 4usize];
  ["Offset of field: ADLThermalControllerInfo::iSize"]
    [::std::mem::offset_of!(ADLThermalControllerInfo, iSize) - 0usize];
  ["Offset of field: ADLThermalControllerInfo::iThermalDomain"]
    [::std::mem::offset_of!(ADLThermalControllerInfo, iThermalDomain) - 4usize];
  ["Offset of field: ADLThermalControllerInfo::iDomainIndex"]
    [::std::mem::offset_of!(ADLThermalControllerInfo, iDomainIndex) - 8usize];
  ["Offset of field: ADLThermalControllerInfo::iFlags"]
    [::std::mem::offset_of!(ADLThermalControllerInfo, iFlags) - 12usize];
};
#[doc = "\n\\brief Structure containing information about thermal controller temperature.\n\n This structure is used to store information about thermal controller temperature.\n This structure is used by the ADL_PM_Temperature_Get() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLTemperature {
  #[doc = " Must be set to the size of the structure"]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " Temperature in millidegrees Celsius."]
  pub iTemperature: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLTemperature"][::std::mem::size_of::<ADLTemperature>() - 8usize];
  ["Alignment of ADLTemperature"][::std::mem::align_of::<ADLTemperature>() - 4usize];
  ["Offset of field: ADLTemperature::iSize"]
    [::std::mem::offset_of!(ADLTemperature, iSize) - 0usize];
  ["Offset of field: ADLTemperature::iTemperature"]
    [::std::mem::offset_of!(ADLTemperature, iTemperature) - 4usize];
};
#[doc = "\n\\brief Structure containing information about thermal controller fan speed.\n\n This structure is used to store information about thermal controller fan speed.\n This structure is used by the ADL_PM_FanSpeedInfo_Get() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLFanSpeedInfo {
  #[doc = " Must be set to the size of the structure"]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " \\ref define_fanctrl"]
  pub iFlags: ::std::os::raw::c_int,
  #[doc = " Minimum possible fan speed value in percents."]
  pub iMinPercent: ::std::os::raw::c_int,
  #[doc = " Maximum possible fan speed value in percents."]
  pub iMaxPercent: ::std::os::raw::c_int,
  #[doc = " Minimum possible fan speed value in RPM."]
  pub iMinRPM: ::std::os::raw::c_int,
  #[doc = " Maximum possible fan speed value in RPM."]
  pub iMaxRPM: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLFanSpeedInfo"][::std::mem::size_of::<ADLFanSpeedInfo>() - 24usize];
  ["Alignment of ADLFanSpeedInfo"][::std::mem::align_of::<ADLFanSpeedInfo>() - 4usize];
  ["Offset of field: ADLFanSpeedInfo::iSize"]
    [::std::mem::offset_of!(ADLFanSpeedInfo, iSize) - 0usize];
  ["Offset of field: ADLFanSpeedInfo::iFlags"]
    [::std::mem::offset_of!(ADLFanSpeedInfo, iFlags) - 4usize];
  ["Offset of field: ADLFanSpeedInfo::iMinPercent"]
    [::std::mem::offset_of!(ADLFanSpeedInfo, iMinPercent) - 8usize];
  ["Offset of field: ADLFanSpeedInfo::iMaxPercent"]
    [::std::mem::offset_of!(ADLFanSpeedInfo, iMaxPercent) - 12usize];
  ["Offset of field: ADLFanSpeedInfo::iMinRPM"]
    [::std::mem::offset_of!(ADLFanSpeedInfo, iMinRPM) - 16usize];
  ["Offset of field: ADLFanSpeedInfo::iMaxRPM"]
    [::std::mem::offset_of!(ADLFanSpeedInfo, iMaxRPM) - 20usize];
};
#[doc = "\n\\brief Structure containing information about fan speed reported by thermal controller.\n\n This structure is used to store information about fan speed reported by thermal controller.\n This structure is used by the ADL_Overdrive5_FanSpeed_Get() and ADL_Overdrive5_FanSpeed_Set() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLFanSpeedValue {
  #[doc = " Must be set to the size of the structure"]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " Possible valies: \\ref ADL_DL_FANCTRL_SPEED_TYPE_PERCENT or \\ref ADL_DL_FANCTRL_SPEED_TYPE_RPM"]
  pub iSpeedType: ::std::os::raw::c_int,
  #[doc = " Fan speed value"]
  pub iFanSpeed: ::std::os::raw::c_int,
  #[doc = " The only flag for now is: \\ref ADL_DL_FANCTRL_FLAG_USER_DEFINED_SPEED"]
  pub iFlags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLFanSpeedValue"][::std::mem::size_of::<ADLFanSpeedValue>() - 16usize];
  ["Alignment of ADLFanSpeedValue"][::std::mem::align_of::<ADLFanSpeedValue>() - 4usize];
  ["Offset of field: ADLFanSpeedValue::iSize"]
    [::std::mem::offset_of!(ADLFanSpeedValue, iSize) - 0usize];
  ["Offset of field: ADLFanSpeedValue::iSpeedType"]
    [::std::mem::offset_of!(ADLFanSpeedValue, iSpeedType) - 4usize];
  ["Offset of field: ADLFanSpeedValue::iFanSpeed"]
    [::std::mem::offset_of!(ADLFanSpeedValue, iFanSpeed) - 8usize];
  ["Offset of field: ADLFanSpeedValue::iFlags"]
    [::std::mem::offset_of!(ADLFanSpeedValue, iFlags) - 12usize];
};
#[doc = "\n\\brief Structure containing the range of Overdrive parameter.\n\n This structure is used to store information about the range of Overdrive parameter.\n This structure is used by ADLODParameters.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLODParameterRange {
  #[doc = " Minimum parameter value."]
  pub iMin: ::std::os::raw::c_int,
  #[doc = " Maximum parameter value."]
  pub iMax: ::std::os::raw::c_int,
  #[doc = " Parameter step value."]
  pub iStep: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLODParameterRange"][::std::mem::size_of::<ADLODParameterRange>() - 12usize];
  ["Alignment of ADLODParameterRange"]
    [::std::mem::align_of::<ADLODParameterRange>() - 4usize];
  ["Offset of field: ADLODParameterRange::iMin"]
    [::std::mem::offset_of!(ADLODParameterRange, iMin) - 0usize];
  ["Offset of field: ADLODParameterRange::iMax"]
    [::std::mem::offset_of!(ADLODParameterRange, iMax) - 4usize];
  ["Offset of field: ADLODParameterRange::iStep"]
    [::std::mem::offset_of!(ADLODParameterRange, iStep) - 8usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive parameters.\n\n This structure is used to store information about Overdrive parameters.\n This structure is used by the ADL_Overdrive5_ODParameters_Get() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLODParameters {
  #[doc = " Must be set to the size of the structure"]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " Number of standard performance states."]
  pub iNumberOfPerformanceLevels: ::std::os::raw::c_int,
  #[doc = " Indicates whether the GPU is capable to measure its activity."]
  pub iActivityReportingSupported: ::std::os::raw::c_int,
  #[doc = " Indicates whether the GPU supports discrete performance levels or performance range."]
  pub iDiscretePerformanceLevels: ::std::os::raw::c_int,
  #[doc = " Reserved for future use."]
  pub iReserved: ::std::os::raw::c_int,
  #[doc = " Engine clock range."]
  pub sEngineClock: ADLODParameterRange,
  #[doc = " Memory clock range."]
  pub sMemoryClock: ADLODParameterRange,
  #[doc = " Core voltage range."]
  pub sVddc: ADLODParameterRange,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLODParameters"][::std::mem::size_of::<ADLODParameters>() - 56usize];
  ["Alignment of ADLODParameters"][::std::mem::align_of::<ADLODParameters>() - 4usize];
  ["Offset of field: ADLODParameters::iSize"]
    [::std::mem::offset_of!(ADLODParameters, iSize) - 0usize];
  ["Offset of field: ADLODParameters::iNumberOfPerformanceLevels"]
    [::std::mem::offset_of!(ADLODParameters, iNumberOfPerformanceLevels) - 4usize];
  ["Offset of field: ADLODParameters::iActivityReportingSupported"]
    [::std::mem::offset_of!(ADLODParameters, iActivityReportingSupported) - 8usize];
  ["Offset of field: ADLODParameters::iDiscretePerformanceLevels"]
    [::std::mem::offset_of!(ADLODParameters, iDiscretePerformanceLevels) - 12usize];
  ["Offset of field: ADLODParameters::iReserved"]
    [::std::mem::offset_of!(ADLODParameters, iReserved) - 16usize];
  ["Offset of field: ADLODParameters::sEngineClock"]
    [::std::mem::offset_of!(ADLODParameters, sEngineClock) - 20usize];
  ["Offset of field: ADLODParameters::sMemoryClock"]
    [::std::mem::offset_of!(ADLODParameters, sMemoryClock) - 32usize];
  ["Offset of field: ADLODParameters::sVddc"]
    [::std::mem::offset_of!(ADLODParameters, sVddc) - 44usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive level.\n\n This structure is used to store information about Overdrive level.\n This structure is used by ADLODPerformanceLevels.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLODPerformanceLevel {
  #[doc = " Engine clock."]
  pub iEngineClock: ::std::os::raw::c_int,
  #[doc = " Memory clock."]
  pub iMemoryClock: ::std::os::raw::c_int,
  #[doc = " Core voltage."]
  pub iVddc: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLODPerformanceLevel"]
    [::std::mem::size_of::<ADLODPerformanceLevel>() - 12usize];
  ["Alignment of ADLODPerformanceLevel"]
    [::std::mem::align_of::<ADLODPerformanceLevel>() - 4usize];
  ["Offset of field: ADLODPerformanceLevel::iEngineClock"]
    [::std::mem::offset_of!(ADLODPerformanceLevel, iEngineClock) - 0usize];
  ["Offset of field: ADLODPerformanceLevel::iMemoryClock"]
    [::std::mem::offset_of!(ADLODPerformanceLevel, iMemoryClock) - 4usize];
  ["Offset of field: ADLODPerformanceLevel::iVddc"]
    [::std::mem::offset_of!(ADLODPerformanceLevel, iVddc) - 8usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive performance levels.\n\n This structure is used to store information about Overdrive performance levels.\n This structure is used by the ADL_Overdrive5_ODPerformanceLevels_Get() and ADL_Overdrive5_ODPerformanceLevels_Set() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLODPerformanceLevels {
  #[doc = " Must be set to sizeof( \\ref ADLODPerformanceLevels ) + sizeof( \\ref ADLODPerformanceLevel ) * (ADLODParameters.iNumberOfPerformanceLevels - 1)"]
  pub iSize: ::std::os::raw::c_int,
  pub iReserved: ::std::os::raw::c_int,
  #[doc = " Array of performance state descriptors. Must have ADLODParameters.iNumberOfPerformanceLevels elements."]
  pub aLevels: [ADLODPerformanceLevel; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLODPerformanceLevels"]
    [::std::mem::size_of::<ADLODPerformanceLevels>() - 20usize];
  ["Alignment of ADLODPerformanceLevels"]
    [::std::mem::align_of::<ADLODPerformanceLevels>() - 4usize];
  ["Offset of field: ADLODPerformanceLevels::iSize"]
    [::std::mem::offset_of!(ADLODPerformanceLevels, iSize) - 0usize];
  ["Offset of field: ADLODPerformanceLevels::iReserved"]
    [::std::mem::offset_of!(ADLODPerformanceLevels, iReserved) - 4usize];
  ["Offset of field: ADLODPerformanceLevels::aLevels"]
    [::std::mem::offset_of!(ADLODPerformanceLevels, aLevels) - 8usize];
};
#[doc = "\n\\brief Structure containing information about the proper CrossfireX chains combinations.\n\n This structure is used to store information about the CrossfireX chains combination for a particular adapter.\n This structure is used by the ADL_Adapter_Crossfire_Caps(), ADL_Adapter_Crossfire_Get(), and ADL_Adapter_Crossfire_Set() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLCrossfireComb {
  #[doc = " Number of adapters in this combination."]
  pub iNumLinkAdapter: ::std::os::raw::c_int,
  #[doc = " A list of ADL indexes of the linked adapters in this combination."]
  pub iAdaptLink: [::std::os::raw::c_int; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLCrossfireComb"][::std::mem::size_of::<ADLCrossfireComb>() - 16usize];
  ["Alignment of ADLCrossfireComb"][::std::mem::align_of::<ADLCrossfireComb>() - 4usize];
  ["Offset of field: ADLCrossfireComb::iNumLinkAdapter"]
    [::std::mem::offset_of!(ADLCrossfireComb, iNumLinkAdapter) - 0usize];
  ["Offset of field: ADLCrossfireComb::iAdaptLink"]
    [::std::mem::offset_of!(ADLCrossfireComb, iAdaptLink) - 4usize];
};
#[doc = "\n\\brief Structure containing CrossfireX state and error information.\n\n This structure is used to store state and error information about a particular adapter CrossfireX combination.\n This structure is used by the ADL_Adapter_Crossfire_Get() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLCrossfireInfo {
  #[doc = " Current error code of this CrossfireX combination."]
  pub iErrorCode: ::std::os::raw::c_int,
  #[doc = " Current \\ref define_crossfirestate"]
  pub iState: ::std::os::raw::c_int,
  #[doc = " If CrossfireX is supported by this combination. The value is either \\ref ADL_TRUE or \\ref ADL_FALSE."]
  pub iSupported: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLCrossfireInfo"][::std::mem::size_of::<ADLCrossfireInfo>() - 12usize];
  ["Alignment of ADLCrossfireInfo"][::std::mem::align_of::<ADLCrossfireInfo>() - 4usize];
  ["Offset of field: ADLCrossfireInfo::iErrorCode"]
    [::std::mem::offset_of!(ADLCrossfireInfo, iErrorCode) - 0usize];
  ["Offset of field: ADLCrossfireInfo::iState"]
    [::std::mem::offset_of!(ADLCrossfireInfo, iState) - 4usize];
  ["Offset of field: ADLCrossfireInfo::iSupported"]
    [::std::mem::offset_of!(ADLCrossfireInfo, iSupported) - 8usize];
};
#[doc = "\n \\brief Structure containing information about the BIOS.\n\n This structure is used to store various information about the Chipset.  This\n information can be returned to the user.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLBiosInfo {
  #[doc = "< Part number."]
  pub strPartNumber: [::std::os::raw::c_char; 256usize],
  #[doc = "< Version number."]
  pub strVersion: [::std::os::raw::c_char; 256usize],
  #[doc = "< BIOS date in yyyy/mm/dd hh:mm format."]
  pub strDate: [::std::os::raw::c_char; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLBiosInfo"][::std::mem::size_of::<ADLBiosInfo>() - 768usize];
  ["Alignment of ADLBiosInfo"][::std::mem::align_of::<ADLBiosInfo>() - 1usize];
  ["Offset of field: ADLBiosInfo::strPartNumber"]
    [::std::mem::offset_of!(ADLBiosInfo, strPartNumber) - 0usize];
  ["Offset of field: ADLBiosInfo::strVersion"]
    [::std::mem::offset_of!(ADLBiosInfo, strVersion) - 256usize];
  ["Offset of field: ADLBiosInfo::strDate"]
    [::std::mem::offset_of!(ADLBiosInfo, strDate) - 512usize];
};
#[doc = "\n \\brief Structure containing information about the BIOS.\n\n This structure is used to store various information about the Chipset.  This\n information can be returned to the user.\n \\nosubgrouping\n"]
pub type LPADLBiosInfo = *mut ADLBiosInfo;
#[doc = "\n \\brief Structure containing information about adapter location.\n\n This structure is used to store information about adapter location.\n This structure is used by ADLMVPUStatus.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLAdapterLocation {
  #[doc = " PCI Bus number : 8 bits"]
  pub iBus: ::std::os::raw::c_int,
  #[doc = " Device number : 5 bits"]
  pub iDevice: ::std::os::raw::c_int,
  #[doc = " Function number : 3 bits"]
  pub iFunction: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLAdapterLocation"][::std::mem::size_of::<ADLAdapterLocation>() - 12usize];
  ["Alignment of ADLAdapterLocation"]
    [::std::mem::align_of::<ADLAdapterLocation>() - 4usize];
  ["Offset of field: ADLAdapterLocation::iBus"]
    [::std::mem::offset_of!(ADLAdapterLocation, iBus) - 0usize];
  ["Offset of field: ADLAdapterLocation::iDevice"]
    [::std::mem::offset_of!(ADLAdapterLocation, iDevice) - 4usize];
  ["Offset of field: ADLAdapterLocation::iFunction"]
    [::std::mem::offset_of!(ADLAdapterLocation, iFunction) - 8usize];
};
#[doc = "\n \\brief Structure containing information about adapter location.\n\n This structure is used to store information about adapter location.\n This structure is used by ADLMVPUStatus.\n \\nosubgrouping\n"]
pub type ADLBdf = ADLAdapterLocation;
#[doc = "\n \\brief Structure containing version information\n\n This structure is used to store software version information, description of the display device and a web link to the latest installed Catalyst drivers.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLVersionsInfo {
  #[doc = " Driver Release (Packaging) Version (e.g. 8.71-100128n-094835E-ATI)"]
  pub strDriverVer: [::std::os::raw::c_char; 256usize],
  #[doc = " Catalyst Version(e.g. \"10.1\")."]
  pub strCatalystVersion: [::std::os::raw::c_char; 256usize],
  #[doc = " Web link to an XML file with information about the latest AMD drivers and locations (e.g. \"http://www.amd.com/us/driverxml\" )"]
  pub strCatalystWebLink: [::std::os::raw::c_char; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLVersionsInfo"][::std::mem::size_of::<ADLVersionsInfo>() - 768usize];
  ["Alignment of ADLVersionsInfo"][::std::mem::align_of::<ADLVersionsInfo>() - 1usize];
  ["Offset of field: ADLVersionsInfo::strDriverVer"]
    [::std::mem::offset_of!(ADLVersionsInfo, strDriverVer) - 0usize];
  ["Offset of field: ADLVersionsInfo::strCatalystVersion"]
    [::std::mem::offset_of!(ADLVersionsInfo, strCatalystVersion) - 256usize];
  ["Offset of field: ADLVersionsInfo::strCatalystWebLink"]
    [::std::mem::offset_of!(ADLVersionsInfo, strCatalystWebLink) - 512usize];
};
#[doc = "\n \\brief Structure containing version information\n\n This structure is used to store software version information, description of the display device and a web link to the latest installed Catalyst drivers.\n \\nosubgrouping\n"]
pub type LPADLVersionsInfo = *mut ADLVersionsInfo;
#[doc = "\n \\brief Structure containing version information\n\n This structure is used to store software version information, description of the display device and a web link to the latest installed Catalyst drivers.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLVersionsInfoX2 {
  #[doc = " Driver Release (Packaging) Version (e.g. \"16.20.1035-160621a-303814C\")"]
  pub strDriverVer: [::std::os::raw::c_char; 256usize],
  #[doc = " Catalyst Version(e.g. \"15.8\")."]
  pub strCatalystVersion: [::std::os::raw::c_char; 256usize],
  #[doc = " Crimson Version(e.g. \"16.6.2\")."]
  pub strCrimsonVersion: [::std::os::raw::c_char; 256usize],
  #[doc = " Web link to an XML file with information about the latest AMD drivers and locations (e.g. \"http://support.amd.com/drivers/xml/driver_09_us.xml\" )"]
  pub strCatalystWebLink: [::std::os::raw::c_char; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLVersionsInfoX2"][::std::mem::size_of::<ADLVersionsInfoX2>() - 1024usize];
  ["Alignment of ADLVersionsInfoX2"]
    [::std::mem::align_of::<ADLVersionsInfoX2>() - 1usize];
  ["Offset of field: ADLVersionsInfoX2::strDriverVer"]
    [::std::mem::offset_of!(ADLVersionsInfoX2, strDriverVer) - 0usize];
  ["Offset of field: ADLVersionsInfoX2::strCatalystVersion"]
    [::std::mem::offset_of!(ADLVersionsInfoX2, strCatalystVersion) - 256usize];
  ["Offset of field: ADLVersionsInfoX2::strCrimsonVersion"]
    [::std::mem::offset_of!(ADLVersionsInfoX2, strCrimsonVersion) - 512usize];
  ["Offset of field: ADLVersionsInfoX2::strCatalystWebLink"]
    [::std::mem::offset_of!(ADLVersionsInfoX2, strCatalystWebLink) - 768usize];
};
#[doc = "\n \\brief Structure containing version information\n\n This structure is used to store software version information, description of the display device and a web link to the latest installed Catalyst drivers.\n \\nosubgrouping\n"]
pub type LPADLVersionsInfoX2 = *mut ADLVersionsInfoX2;
#[doc = "\n \\brief Structure containing information about MultiVPU capabilities.\n\n This structure is used to store information about MultiVPU capabilities.\n This structure is used by the ADL_Display_MVPUCaps_Get() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLMVPUCaps {
  #[doc = " Must be set to sizeof( ADLMVPUCaps )."]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " Number of adapters."]
  pub iAdapterCount: ::std::os::raw::c_int,
  #[doc = " Bits set for all possible MVPU masters. \\ref MVPU_ADAPTER_0 .. \\ref MVPU_ADAPTER_3"]
  pub iPossibleMVPUMasters: ::std::os::raw::c_int,
  #[doc = " Bits set for all possible MVPU slaves. \\ref MVPU_ADAPTER_0 .. \\ref MVPU_ADAPTER_3"]
  pub iPossibleMVPUSlaves: ::std::os::raw::c_int,
  #[doc = " Registry path for each adapter."]
  pub cAdapterPath: [[::std::os::raw::c_char; 256usize]; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLMVPUCaps"][::std::mem::size_of::<ADLMVPUCaps>() - 1040usize];
  ["Alignment of ADLMVPUCaps"][::std::mem::align_of::<ADLMVPUCaps>() - 4usize];
  ["Offset of field: ADLMVPUCaps::iSize"]
    [::std::mem::offset_of!(ADLMVPUCaps, iSize) - 0usize];
  ["Offset of field: ADLMVPUCaps::iAdapterCount"]
    [::std::mem::offset_of!(ADLMVPUCaps, iAdapterCount) - 4usize];
  ["Offset of field: ADLMVPUCaps::iPossibleMVPUMasters"]
    [::std::mem::offset_of!(ADLMVPUCaps, iPossibleMVPUMasters) - 8usize];
  ["Offset of field: ADLMVPUCaps::iPossibleMVPUSlaves"]
    [::std::mem::offset_of!(ADLMVPUCaps, iPossibleMVPUSlaves) - 12usize];
  ["Offset of field: ADLMVPUCaps::cAdapterPath"]
    [::std::mem::offset_of!(ADLMVPUCaps, cAdapterPath) - 16usize];
};
#[doc = "\n \\brief Structure containing information about MultiVPU status.\n\n This structure is used to store information about MultiVPU status.\n Ths structure is used by the ADL_Display_MVPUStatus_Get() function.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLMVPUStatus {
  #[doc = " Must be set to sizeof( ADLMVPUStatus )."]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " Number of active adapters."]
  pub iActiveAdapterCount: ::std::os::raw::c_int,
  #[doc = " MVPU status."]
  pub iStatus: ::std::os::raw::c_int,
  #[doc = " PCI Bus/Device/Function for each active adapter participating in MVPU."]
  pub aAdapterLocation: [ADLAdapterLocation; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLMVPUStatus"][::std::mem::size_of::<ADLMVPUStatus>() - 60usize];
  ["Alignment of ADLMVPUStatus"][::std::mem::align_of::<ADLMVPUStatus>() - 4usize];
  ["Offset of field: ADLMVPUStatus::iSize"]
    [::std::mem::offset_of!(ADLMVPUStatus, iSize) - 0usize];
  ["Offset of field: ADLMVPUStatus::iActiveAdapterCount"]
    [::std::mem::offset_of!(ADLMVPUStatus, iActiveAdapterCount) - 4usize];
  ["Offset of field: ADLMVPUStatus::iStatus"]
    [::std::mem::offset_of!(ADLMVPUStatus, iStatus) - 8usize];
  ["Offset of field: ADLMVPUStatus::aAdapterLocation"]
    [::std::mem::offset_of!(ADLMVPUStatus, aAdapterLocation) - 12usize];
};
#[doc = "\n \\brief Structure containing information about the activatable source.\n\n This structure is used to store activatable source information\n This information can be returned to the user.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLActivatableSource {
  #[doc = " The Persistent logical Adapter Index."]
  pub iAdapterIndex: ::std::os::raw::c_int,
  #[doc = " The number of Activatable Sources."]
  pub iNumActivatableSources: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the number of bits ActivatableSourceValue is using. (Not currnetly used)"]
  pub iActivatableSourceMask: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the status.  (Not currnetly used)"]
  pub iActivatableSourceValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLActivatableSource"]
    [::std::mem::size_of::<ADLActivatableSource>() - 16usize];
  ["Alignment of ADLActivatableSource"]
    [::std::mem::align_of::<ADLActivatableSource>() - 4usize];
  ["Offset of field: ADLActivatableSource::iAdapterIndex"]
    [::std::mem::offset_of!(ADLActivatableSource, iAdapterIndex) - 0usize];
  ["Offset of field: ADLActivatableSource::iNumActivatableSources"]
    [::std::mem::offset_of!(ADLActivatableSource, iNumActivatableSources) - 4usize];
  ["Offset of field: ADLActivatableSource::iActivatableSourceMask"]
    [::std::mem::offset_of!(ADLActivatableSource, iActivatableSourceMask) - 8usize];
  ["Offset of field: ADLActivatableSource::iActivatableSourceValue"]
    [::std::mem::offset_of!(ADLActivatableSource, iActivatableSourceValue) - 12usize];
};
#[doc = "\n \\brief Structure containing information about the activatable source.\n\n This structure is used to store activatable source information\n This information can be returned to the user.\n \\nosubgrouping\n"]
pub type LPADLActivatableSource = *mut ADLActivatableSource;
#[doc = "\n \\brief Structure containing information about display mode.\n\n This structure is used to store the display mode for the current adapter\n such as X, Y positions, screen resolutions, orientation,\n color depth, refresh rate, progressive or interlace mode, etc.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLMode {
  #[doc = " Adapter index."]
  pub iAdapterIndex: ::std::os::raw::c_int,
  #[doc = " Display IDs."]
  pub displayID: ADLDisplayID,
  #[doc = " Screen position X coordinate."]
  pub iXPos: ::std::os::raw::c_int,
  #[doc = " Screen position Y coordinate."]
  pub iYPos: ::std::os::raw::c_int,
  #[doc = " Screen resolution Width."]
  pub iXRes: ::std::os::raw::c_int,
  #[doc = " Screen resolution Height."]
  pub iYRes: ::std::os::raw::c_int,
  #[doc = " Screen Color Depth. E.g., 16, 32."]
  pub iColourDepth: ::std::os::raw::c_int,
  #[doc = " Screen refresh rate. Could be fractional E.g. 59.97"]
  pub fRefreshRate: f32,
  #[doc = " Screen orientation. E.g., 0, 90, 180, 270."]
  pub iOrientation: ::std::os::raw::c_int,
  #[doc = " Vista mode flag indicating Progressive or Interlaced mode."]
  pub iModeFlag: ::std::os::raw::c_int,
  #[doc = " The bit mask identifying the number of bits this Mode is currently using. It is the sum of all the bit definitions defined in \\ref define_displaymode"]
  pub iModeMask: ::std::os::raw::c_int,
  #[doc = " The bit mask identifying the display status. The detailed definition is in  \\ref define_displaymode"]
  pub iModeValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLMode"][::std::mem::size_of::<ADLMode>() - 60usize];
  ["Alignment of ADLMode"][::std::mem::align_of::<ADLMode>() - 4usize];
  ["Offset of field: ADLMode::iAdapterIndex"]
    [::std::mem::offset_of!(ADLMode, iAdapterIndex) - 0usize];
  ["Offset of field: ADLMode::displayID"]
    [::std::mem::offset_of!(ADLMode, displayID) - 4usize];
  ["Offset of field: ADLMode::iXPos"][::std::mem::offset_of!(ADLMode, iXPos) - 20usize];
  ["Offset of field: ADLMode::iYPos"][::std::mem::offset_of!(ADLMode, iYPos) - 24usize];
  ["Offset of field: ADLMode::iXRes"][::std::mem::offset_of!(ADLMode, iXRes) - 28usize];
  ["Offset of field: ADLMode::iYRes"][::std::mem::offset_of!(ADLMode, iYRes) - 32usize];
  ["Offset of field: ADLMode::iColourDepth"]
    [::std::mem::offset_of!(ADLMode, iColourDepth) - 36usize];
  ["Offset of field: ADLMode::fRefreshRate"]
    [::std::mem::offset_of!(ADLMode, fRefreshRate) - 40usize];
  ["Offset of field: ADLMode::iOrientation"]
    [::std::mem::offset_of!(ADLMode, iOrientation) - 44usize];
  ["Offset of field: ADLMode::iModeFlag"]
    [::std::mem::offset_of!(ADLMode, iModeFlag) - 48usize];
  ["Offset of field: ADLMode::iModeMask"]
    [::std::mem::offset_of!(ADLMode, iModeMask) - 52usize];
  ["Offset of field: ADLMode::iModeValue"]
    [::std::mem::offset_of!(ADLMode, iModeValue) - 56usize];
};
#[doc = "\n \\brief Structure containing information about display mode.\n\n This structure is used to store the display mode for the current adapter\n such as X, Y positions, screen resolutions, orientation,\n color depth, refresh rate, progressive or interlace mode, etc.\n \\nosubgrouping\n"]
pub type LPADLMode = *mut ADLMode;
#[doc = "\n \\brief Structure containing information about display target information.\n\n This structure is used to store the display target information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDisplayTarget {
  #[doc = " The Display ID."]
  pub displayID: ADLDisplayID,
  #[doc = " The display map index identify this manner and the desktop surface."]
  pub iDisplayMapIndex: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the number of bits DisplayTarget is currently using. It is the sum of all the bit definitions defined in \\ref ADL_DISPLAY_DISPLAYTARGET_PREFERRED."]
  pub iDisplayTargetMask: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the display status. The detailed definition is in \\ref ADL_DISPLAY_DISPLAYTARGET_PREFERRED."]
  pub iDisplayTargetValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDisplayTarget"][::std::mem::size_of::<ADLDisplayTarget>() - 28usize];
  ["Alignment of ADLDisplayTarget"][::std::mem::align_of::<ADLDisplayTarget>() - 4usize];
  ["Offset of field: ADLDisplayTarget::displayID"]
    [::std::mem::offset_of!(ADLDisplayTarget, displayID) - 0usize];
  ["Offset of field: ADLDisplayTarget::iDisplayMapIndex"]
    [::std::mem::offset_of!(ADLDisplayTarget, iDisplayMapIndex) - 16usize];
  ["Offset of field: ADLDisplayTarget::iDisplayTargetMask"]
    [::std::mem::offset_of!(ADLDisplayTarget, iDisplayTargetMask) - 20usize];
  ["Offset of field: ADLDisplayTarget::iDisplayTargetValue"]
    [::std::mem::offset_of!(ADLDisplayTarget, iDisplayTargetValue) - 24usize];
};
#[doc = "\n \\brief Structure containing information about display target information.\n\n This structure is used to store the display target information.\n \\nosubgrouping\n"]
pub type LPADLDisplayTarget = *mut ADLDisplayTarget;
#[doc = "\n\\brief Structure containing information about the display SLS bezel Mode information.\n\n This structure is used to store the display SLS bezel Mode information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagADLBezelTransientMode {
  #[doc = " Adapter Index"]
  pub iAdapterIndex: ::std::os::raw::c_int,
  #[doc = " SLS Map Index"]
  pub iSLSMapIndex: ::std::os::raw::c_int,
  #[doc = " The mode index"]
  pub iSLSModeIndex: ::std::os::raw::c_int,
  #[doc = " The mode"]
  pub displayMode: ADLMode,
  #[doc = " The number of bezel offsets belongs to this map"]
  pub iNumBezelOffset: ::std::os::raw::c_int,
  #[doc = " The first bezel offset array index in the native mode array"]
  pub iFirstBezelOffsetArrayIndex: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the bits this structure is currently using. It will be the total OR of all the bit definitions."]
  pub iSLSBezelTransientModeMask: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the display status. The detail definition is defined below."]
  pub iSLSBezelTransientModeValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of tagADLBezelTransientMode"]
    [::std::mem::size_of::<tagADLBezelTransientMode>() - 88usize];
  ["Alignment of tagADLBezelTransientMode"]
    [::std::mem::align_of::<tagADLBezelTransientMode>() - 4usize];
  ["Offset of field: tagADLBezelTransientMode::iAdapterIndex"]
    [::std::mem::offset_of!(tagADLBezelTransientMode, iAdapterIndex) - 0usize];
  ["Offset of field: tagADLBezelTransientMode::iSLSMapIndex"]
    [::std::mem::offset_of!(tagADLBezelTransientMode, iSLSMapIndex) - 4usize];
  ["Offset of field: tagADLBezelTransientMode::iSLSModeIndex"]
    [::std::mem::offset_of!(tagADLBezelTransientMode, iSLSModeIndex) - 8usize];
  ["Offset of field: tagADLBezelTransientMode::displayMode"]
    [::std::mem::offset_of!(tagADLBezelTransientMode, displayMode) - 12usize];
  ["Offset of field: tagADLBezelTransientMode::iNumBezelOffset"]
    [::std::mem::offset_of!(tagADLBezelTransientMode, iNumBezelOffset) - 72usize];
  ["Offset of field: tagADLBezelTransientMode::iFirstBezelOffsetArrayIndex"][::std::mem::offset_of!(
    tagADLBezelTransientMode,
    iFirstBezelOffsetArrayIndex
  ) - 76usize];
  ["Offset of field: tagADLBezelTransientMode::iSLSBezelTransientModeMask"][::std::mem::offset_of!(
    tagADLBezelTransientMode,
    iSLSBezelTransientModeMask
  ) - 80usize];
  ["Offset of field: tagADLBezelTransientMode::iSLSBezelTransientModeValue"][::std::mem::offset_of!(
    tagADLBezelTransientMode,
    iSLSBezelTransientModeValue
  ) - 84usize];
};
#[doc = "\n\\brief Structure containing information about the display SLS bezel Mode information.\n\n This structure is used to store the display SLS bezel Mode information.\n \\nosubgrouping\n"]
pub type ADLBezelTransientMode = tagADLBezelTransientMode;
#[doc = "\n\\brief Structure containing information about the display SLS bezel Mode information.\n\n This structure is used to store the display SLS bezel Mode information.\n \\nosubgrouping\n"]
pub type LPADLBezelTransientMode = *mut tagADLBezelTransientMode;
#[doc = "\n \\brief Structure containing information about the adapter display manner.\n\n This structure is used to store adapter display manner information\n This information can be returned to the user. Alternatively, it can be used to access various driver calls to\n fetch various display device related display manner settings upon the user's request.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLAdapterDisplayCap {
  #[doc = " The Persistent logical Adapter Index."]
  pub iAdapterIndex: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the number of bits AdapterDisplayCap is currently using. Sum all the bits defined in ADL_ADAPTER_DISPLAYCAP_XXX"]
  pub iAdapterDisplayCapMask: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the status. Refer to ADL_ADAPTER_DISPLAYCAP_XXX"]
  pub iAdapterDisplayCapValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLAdapterDisplayCap"]
    [::std::mem::size_of::<ADLAdapterDisplayCap>() - 12usize];
  ["Alignment of ADLAdapterDisplayCap"]
    [::std::mem::align_of::<ADLAdapterDisplayCap>() - 4usize];
  ["Offset of field: ADLAdapterDisplayCap::iAdapterIndex"]
    [::std::mem::offset_of!(ADLAdapterDisplayCap, iAdapterIndex) - 0usize];
  ["Offset of field: ADLAdapterDisplayCap::iAdapterDisplayCapMask"]
    [::std::mem::offset_of!(ADLAdapterDisplayCap, iAdapterDisplayCapMask) - 4usize];
  ["Offset of field: ADLAdapterDisplayCap::iAdapterDisplayCapValue"]
    [::std::mem::offset_of!(ADLAdapterDisplayCap, iAdapterDisplayCapValue) - 8usize];
};
#[doc = "\n \\brief Structure containing information about the adapter display manner.\n\n This structure is used to store adapter display manner information\n This information can be returned to the user. Alternatively, it can be used to access various driver calls to\n fetch various display device related display manner settings upon the user's request.\n \\nosubgrouping\n"]
pub type LPADLAdapterDisplayCap = *mut ADLAdapterDisplayCap;
#[doc = "\n\\brief Structure containing information about display mapping.\n\n This structure is used to store the display mapping data such as display manner.\n For displays with horizontal or vertical stretch manner,\n this structure also stores the display order, display row, and column data.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDisplayMap {
  #[doc = " The current display map index. It is the OS desktop index. For example, if the OS index 1 is showing clone mode, the display map will be 1."]
  pub iDisplayMapIndex: ::std::os::raw::c_int,
  #[doc = " The Display Mode for the current map"]
  pub displayMode: ADLMode,
  #[doc = " The number of display targets belongs to this map\\n"]
  pub iNumDisplayTarget: ::std::os::raw::c_int,
  #[doc = " The first target array index in the Target array\\n"]
  pub iFirstDisplayTargetArrayIndex: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the number of bits DisplayMap is currently using. It is the sum of all the bit definitions defined in ADL_DISPLAY_DISPLAYMAP_MANNER_xxx."]
  pub iDisplayMapMask: ::std::os::raw::c_int,
  #[doc = "The bit mask identifies the display status. The detailed definition is in ADL_DISPLAY_DISPLAYMAP_MANNER_xxx."]
  pub iDisplayMapValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDisplayMap"][::std::mem::size_of::<ADLDisplayMap>() - 80usize];
  ["Alignment of ADLDisplayMap"][::std::mem::align_of::<ADLDisplayMap>() - 4usize];
  ["Offset of field: ADLDisplayMap::iDisplayMapIndex"]
    [::std::mem::offset_of!(ADLDisplayMap, iDisplayMapIndex) - 0usize];
  ["Offset of field: ADLDisplayMap::displayMode"]
    [::std::mem::offset_of!(ADLDisplayMap, displayMode) - 4usize];
  ["Offset of field: ADLDisplayMap::iNumDisplayTarget"]
    [::std::mem::offset_of!(ADLDisplayMap, iNumDisplayTarget) - 64usize];
  ["Offset of field: ADLDisplayMap::iFirstDisplayTargetArrayIndex"]
    [::std::mem::offset_of!(ADLDisplayMap, iFirstDisplayTargetArrayIndex) - 68usize];
  ["Offset of field: ADLDisplayMap::iDisplayMapMask"]
    [::std::mem::offset_of!(ADLDisplayMap, iDisplayMapMask) - 72usize];
  ["Offset of field: ADLDisplayMap::iDisplayMapValue"]
    [::std::mem::offset_of!(ADLDisplayMap, iDisplayMapValue) - 76usize];
};
#[doc = "\n\\brief Structure containing information about display mapping.\n\n This structure is used to store the display mapping data such as display manner.\n For displays with horizontal or vertical stretch manner,\n this structure also stores the display order, display row, and column data.\n \\nosubgrouping\n"]
pub type LPADLDisplayMap = *mut ADLDisplayMap;
#[doc = "\n \\brief Structure containing information about the display device possible map for one GPU\n\n This structure is used to store the display device possible map\n This information can be returned to the user.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLPossibleMap {
  #[doc = " The current PossibleMap index. Each PossibleMap is assigned an index"]
  pub iIndex: ::std::os::raw::c_int,
  #[doc = " The adapter index identifying the GPU for which to validate these Maps & Targets"]
  pub iAdapterIndex: ::std::os::raw::c_int,
  #[doc = " Number of display Maps for this GPU to be validated"]
  pub iNumDisplayMap: ::std::os::raw::c_int,
  #[doc = " The display Maps list to validate"]
  pub displayMap: *mut ADLDisplayMap,
  #[doc = " the number of display Targets for these display Maps"]
  pub iNumDisplayTarget: ::std::os::raw::c_int,
  #[doc = " The display Targets list for these display Maps to be validated."]
  pub displayTarget: *mut ADLDisplayTarget,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLPossibleMap"][::std::mem::size_of::<ADLPossibleMap>() - 40usize];
  ["Alignment of ADLPossibleMap"][::std::mem::align_of::<ADLPossibleMap>() - 8usize];
  ["Offset of field: ADLPossibleMap::iIndex"]
    [::std::mem::offset_of!(ADLPossibleMap, iIndex) - 0usize];
  ["Offset of field: ADLPossibleMap::iAdapterIndex"]
    [::std::mem::offset_of!(ADLPossibleMap, iAdapterIndex) - 4usize];
  ["Offset of field: ADLPossibleMap::iNumDisplayMap"]
    [::std::mem::offset_of!(ADLPossibleMap, iNumDisplayMap) - 8usize];
  ["Offset of field: ADLPossibleMap::displayMap"]
    [::std::mem::offset_of!(ADLPossibleMap, displayMap) - 16usize];
  ["Offset of field: ADLPossibleMap::iNumDisplayTarget"]
    [::std::mem::offset_of!(ADLPossibleMap, iNumDisplayTarget) - 24usize];
  ["Offset of field: ADLPossibleMap::displayTarget"]
    [::std::mem::offset_of!(ADLPossibleMap, displayTarget) - 32usize];
};
#[doc = "\n \\brief Structure containing information about the display device possible map for one GPU\n\n This structure is used to store the display device possible map\n This information can be returned to the user.\n \\nosubgrouping\n"]
pub type LPADLPossibleMap = *mut ADLPossibleMap;
#[doc = "\n \\brief Structure containing information about display possible mapping.\n\n This structure is used to store the display possible mapping's controller index for the current display.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLPossibleMapping {
  #[doc = "< The display index. Each display is assigned an index."]
  pub iDisplayIndex: ::std::os::raw::c_int,
  #[doc = "< The controller index to which display is mapped."]
  pub iDisplayControllerIndex: ::std::os::raw::c_int,
  #[doc = "< The supported display manner."]
  pub iDisplayMannerSupported: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLPossibleMapping"][::std::mem::size_of::<ADLPossibleMapping>() - 12usize];
  ["Alignment of ADLPossibleMapping"]
    [::std::mem::align_of::<ADLPossibleMapping>() - 4usize];
  ["Offset of field: ADLPossibleMapping::iDisplayIndex"]
    [::std::mem::offset_of!(ADLPossibleMapping, iDisplayIndex) - 0usize];
  ["Offset of field: ADLPossibleMapping::iDisplayControllerIndex"]
    [::std::mem::offset_of!(ADLPossibleMapping, iDisplayControllerIndex) - 4usize];
  ["Offset of field: ADLPossibleMapping::iDisplayMannerSupported"]
    [::std::mem::offset_of!(ADLPossibleMapping, iDisplayMannerSupported) - 8usize];
};
#[doc = "\n \\brief Structure containing information about display possible mapping.\n\n This structure is used to store the display possible mapping's controller index for the current display.\n \\nosubgrouping\n"]
pub type LPADLPossibleMapping = *mut ADLPossibleMapping;
#[doc = "\n \\brief Structure containing information about the validated display device possible map result.\n\n This structure is used to store the validated display device possible map result\n This information can be returned to the user.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLPossibleMapResult {
  #[doc = " The current display map index. It is the OS Desktop index. For example, OS Index 1 showing clone mode. The Display Map will be 1."]
  pub iIndex: ::std::os::raw::c_int,
  pub iPossibleMapResultMask: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the possible map result. The detail definition is defined in ADL_DISPLAY_POSSIBLEMAPRESULT_XXX."]
  pub iPossibleMapResultValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLPossibleMapResult"]
    [::std::mem::size_of::<ADLPossibleMapResult>() - 12usize];
  ["Alignment of ADLPossibleMapResult"]
    [::std::mem::align_of::<ADLPossibleMapResult>() - 4usize];
  ["Offset of field: ADLPossibleMapResult::iIndex"]
    [::std::mem::offset_of!(ADLPossibleMapResult, iIndex) - 0usize];
  ["Offset of field: ADLPossibleMapResult::iPossibleMapResultMask"]
    [::std::mem::offset_of!(ADLPossibleMapResult, iPossibleMapResultMask) - 4usize];
  ["Offset of field: ADLPossibleMapResult::iPossibleMapResultValue"]
    [::std::mem::offset_of!(ADLPossibleMapResult, iPossibleMapResultValue) - 8usize];
};
#[doc = "\n \\brief Structure containing information about the validated display device possible map result.\n\n This structure is used to store the validated display device possible map result\n This information can be returned to the user.\n \\nosubgrouping\n"]
pub type LPADLPossibleMapResult = *mut ADLPossibleMapResult;
#[doc = "\n\\brief Structure containing information about the display SLS Grid information.\n\n This structure is used to store the display SLS Grid information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLSLSGrid {
  #[doc = " The Adapter index."]
  pub iAdapterIndex: ::std::os::raw::c_int,
  #[doc = " The grid index."]
  pub iSLSGridIndex: ::std::os::raw::c_int,
  #[doc = " The grid row."]
  pub iSLSGridRow: ::std::os::raw::c_int,
  #[doc = " The grid column."]
  pub iSLSGridColumn: ::std::os::raw::c_int,
  #[doc = " The grid bit mask identifies the number of bits DisplayMap is currently using. Sum of all bits defined in ADL_DISPLAY_SLSGRID_ORIENTATION_XXX"]
  pub iSLSGridMask: ::std::os::raw::c_int,
  #[doc = " The grid bit value identifies the display status. Refer to ADL_DISPLAY_SLSGRID_ORIENTATION_XXX"]
  pub iSLSGridValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLSLSGrid"][::std::mem::size_of::<ADLSLSGrid>() - 24usize];
  ["Alignment of ADLSLSGrid"][::std::mem::align_of::<ADLSLSGrid>() - 4usize];
  ["Offset of field: ADLSLSGrid::iAdapterIndex"]
    [::std::mem::offset_of!(ADLSLSGrid, iAdapterIndex) - 0usize];
  ["Offset of field: ADLSLSGrid::iSLSGridIndex"]
    [::std::mem::offset_of!(ADLSLSGrid, iSLSGridIndex) - 4usize];
  ["Offset of field: ADLSLSGrid::iSLSGridRow"]
    [::std::mem::offset_of!(ADLSLSGrid, iSLSGridRow) - 8usize];
  ["Offset of field: ADLSLSGrid::iSLSGridColumn"]
    [::std::mem::offset_of!(ADLSLSGrid, iSLSGridColumn) - 12usize];
  ["Offset of field: ADLSLSGrid::iSLSGridMask"]
    [::std::mem::offset_of!(ADLSLSGrid, iSLSGridMask) - 16usize];
  ["Offset of field: ADLSLSGrid::iSLSGridValue"]
    [::std::mem::offset_of!(ADLSLSGrid, iSLSGridValue) - 20usize];
};
#[doc = "\n\\brief Structure containing information about the display SLS Grid information.\n\n This structure is used to store the display SLS Grid information.\n \\nosubgrouping\n"]
pub type LPADLSLSGrid = *mut ADLSLSGrid;
#[doc = "\n\\brief Structure containing information about the display SLS Map information.\n\n This structure is used to store the display SLS Map information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLSLSMap {
  #[doc = " The Adapter Index"]
  pub iAdapterIndex: ::std::os::raw::c_int,
  #[doc = " The current display map index. It is the OS Desktop index. For example, OS Index 1 showing clone mode. The Display Map will be 1."]
  pub iSLSMapIndex: ::std::os::raw::c_int,
  #[doc = " Indicate the current grid"]
  pub grid: ADLSLSGrid,
  #[doc = " OS surface index"]
  pub iSurfaceMapIndex: ::std::os::raw::c_int,
  #[doc = "  Screen orientation. E.g., 0, 90, 180, 270"]
  pub iOrientation: ::std::os::raw::c_int,
  #[doc = " The number of display targets belongs to this map"]
  pub iNumSLSTarget: ::std::os::raw::c_int,
  #[doc = " The first target array index in the Target array"]
  pub iFirstSLSTargetArrayIndex: ::std::os::raw::c_int,
  #[doc = " The number of native modes belongs to this map"]
  pub iNumNativeMode: ::std::os::raw::c_int,
  #[doc = " The first native mode array index in the native mode array"]
  pub iFirstNativeModeArrayIndex: ::std::os::raw::c_int,
  #[doc = " The number of bezel modes belongs to this map"]
  pub iNumBezelMode: ::std::os::raw::c_int,
  #[doc = " The first bezel mode array index in the native mode array"]
  pub iFirstBezelModeArrayIndex: ::std::os::raw::c_int,
  #[doc = " The number of bezel offsets belongs to this map"]
  pub iNumBezelOffset: ::std::os::raw::c_int,
  #[doc = " The first bezel offset array index in the"]
  pub iFirstBezelOffsetArrayIndex: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the number of bits DisplayMap is currently using. Sum all the bit definitions defined in ADL_DISPLAY_SLSMAP_XXX."]
  pub iSLSMapMask: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the display map status. Refer to ADL_DISPLAY_SLSMAP_XXX"]
  pub iSLSMapValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLSLSMap"][::std::mem::size_of::<ADLSLSMap>() - 80usize];
  ["Alignment of ADLSLSMap"][::std::mem::align_of::<ADLSLSMap>() - 4usize];
  ["Offset of field: ADLSLSMap::iAdapterIndex"]
    [::std::mem::offset_of!(ADLSLSMap, iAdapterIndex) - 0usize];
  ["Offset of field: ADLSLSMap::iSLSMapIndex"]
    [::std::mem::offset_of!(ADLSLSMap, iSLSMapIndex) - 4usize];
  ["Offset of field: ADLSLSMap::grid"][::std::mem::offset_of!(ADLSLSMap, grid) - 8usize];
  ["Offset of field: ADLSLSMap::iSurfaceMapIndex"]
    [::std::mem::offset_of!(ADLSLSMap, iSurfaceMapIndex) - 32usize];
  ["Offset of field: ADLSLSMap::iOrientation"]
    [::std::mem::offset_of!(ADLSLSMap, iOrientation) - 36usize];
  ["Offset of field: ADLSLSMap::iNumSLSTarget"]
    [::std::mem::offset_of!(ADLSLSMap, iNumSLSTarget) - 40usize];
  ["Offset of field: ADLSLSMap::iFirstSLSTargetArrayIndex"]
    [::std::mem::offset_of!(ADLSLSMap, iFirstSLSTargetArrayIndex) - 44usize];
  ["Offset of field: ADLSLSMap::iNumNativeMode"]
    [::std::mem::offset_of!(ADLSLSMap, iNumNativeMode) - 48usize];
  ["Offset of field: ADLSLSMap::iFirstNativeModeArrayIndex"]
    [::std::mem::offset_of!(ADLSLSMap, iFirstNativeModeArrayIndex) - 52usize];
  ["Offset of field: ADLSLSMap::iNumBezelMode"]
    [::std::mem::offset_of!(ADLSLSMap, iNumBezelMode) - 56usize];
  ["Offset of field: ADLSLSMap::iFirstBezelModeArrayIndex"]
    [::std::mem::offset_of!(ADLSLSMap, iFirstBezelModeArrayIndex) - 60usize];
  ["Offset of field: ADLSLSMap::iNumBezelOffset"]
    [::std::mem::offset_of!(ADLSLSMap, iNumBezelOffset) - 64usize];
  ["Offset of field: ADLSLSMap::iFirstBezelOffsetArrayIndex"]
    [::std::mem::offset_of!(ADLSLSMap, iFirstBezelOffsetArrayIndex) - 68usize];
  ["Offset of field: ADLSLSMap::iSLSMapMask"]
    [::std::mem::offset_of!(ADLSLSMap, iSLSMapMask) - 72usize];
  ["Offset of field: ADLSLSMap::iSLSMapValue"]
    [::std::mem::offset_of!(ADLSLSMap, iSLSMapValue) - 76usize];
};
#[doc = "\n\\brief Structure containing information about the display SLS Map information.\n\n This structure is used to store the display SLS Map information.\n \\nosubgrouping\n"]
pub type LPADLSLSMap = *mut ADLSLSMap;
#[doc = "\n\\brief Structure containing information about the display SLS Offset information.\n\n This structure is used to store the display SLS Offset information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLSLSOffset {
  #[doc = " The Adapter Index"]
  pub iAdapterIndex: ::std::os::raw::c_int,
  #[doc = " The current display map index. It is the OS Desktop index. For example, OS Index 1 showing clone mode. The Display Map will be 1."]
  pub iSLSMapIndex: ::std::os::raw::c_int,
  #[doc = " The Display ID."]
  pub displayID: ADLDisplayID,
  #[doc = " SLS Bezel Mode Index"]
  pub iBezelModeIndex: ::std::os::raw::c_int,
  #[doc = " SLS Bezel Offset X"]
  pub iBezelOffsetX: ::std::os::raw::c_int,
  #[doc = " SLS Bezel Offset Y"]
  pub iBezelOffsetY: ::std::os::raw::c_int,
  #[doc = " SLS Display Width"]
  pub iDisplayWidth: ::std::os::raw::c_int,
  #[doc = " SLS Display Height"]
  pub iDisplayHeight: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the number of bits Offset is currently using."]
  pub iBezelOffsetMask: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the display status."]
  pub iBezelffsetValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLSLSOffset"][::std::mem::size_of::<ADLSLSOffset>() - 52usize];
  ["Alignment of ADLSLSOffset"][::std::mem::align_of::<ADLSLSOffset>() - 4usize];
  ["Offset of field: ADLSLSOffset::iAdapterIndex"]
    [::std::mem::offset_of!(ADLSLSOffset, iAdapterIndex) - 0usize];
  ["Offset of field: ADLSLSOffset::iSLSMapIndex"]
    [::std::mem::offset_of!(ADLSLSOffset, iSLSMapIndex) - 4usize];
  ["Offset of field: ADLSLSOffset::displayID"]
    [::std::mem::offset_of!(ADLSLSOffset, displayID) - 8usize];
  ["Offset of field: ADLSLSOffset::iBezelModeIndex"]
    [::std::mem::offset_of!(ADLSLSOffset, iBezelModeIndex) - 24usize];
  ["Offset of field: ADLSLSOffset::iBezelOffsetX"]
    [::std::mem::offset_of!(ADLSLSOffset, iBezelOffsetX) - 28usize];
  ["Offset of field: ADLSLSOffset::iBezelOffsetY"]
    [::std::mem::offset_of!(ADLSLSOffset, iBezelOffsetY) - 32usize];
  ["Offset of field: ADLSLSOffset::iDisplayWidth"]
    [::std::mem::offset_of!(ADLSLSOffset, iDisplayWidth) - 36usize];
  ["Offset of field: ADLSLSOffset::iDisplayHeight"]
    [::std::mem::offset_of!(ADLSLSOffset, iDisplayHeight) - 40usize];
  ["Offset of field: ADLSLSOffset::iBezelOffsetMask"]
    [::std::mem::offset_of!(ADLSLSOffset, iBezelOffsetMask) - 44usize];
  ["Offset of field: ADLSLSOffset::iBezelffsetValue"]
    [::std::mem::offset_of!(ADLSLSOffset, iBezelffsetValue) - 48usize];
};
#[doc = "\n\\brief Structure containing information about the display SLS Offset information.\n\n This structure is used to store the display SLS Offset information.\n \\nosubgrouping\n"]
pub type LPADLSLSOffset = *mut ADLSLSOffset;
#[doc = "\n\\brief Structure containing information about the display SLS Mode information.\n\n This structure is used to store the display SLS Mode information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLSLSMode {
  #[doc = " The Adapter Index"]
  pub iAdapterIndex: ::std::os::raw::c_int,
  #[doc = " The current display map index. It is the OS Desktop index. For example, OS Index 1 showing clone mode. The Display Map will be 1."]
  pub iSLSMapIndex: ::std::os::raw::c_int,
  #[doc = " The mode index"]
  pub iSLSModeIndex: ::std::os::raw::c_int,
  #[doc = " The mode for this map."]
  pub displayMode: ADLMode,
  #[doc = " The bit mask identifies the number of bits Mode is currently using."]
  pub iSLSNativeModeMask: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the display status."]
  pub iSLSNativeModeValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLSLSMode"][::std::mem::size_of::<ADLSLSMode>() - 80usize];
  ["Alignment of ADLSLSMode"][::std::mem::align_of::<ADLSLSMode>() - 4usize];
  ["Offset of field: ADLSLSMode::iAdapterIndex"]
    [::std::mem::offset_of!(ADLSLSMode, iAdapterIndex) - 0usize];
  ["Offset of field: ADLSLSMode::iSLSMapIndex"]
    [::std::mem::offset_of!(ADLSLSMode, iSLSMapIndex) - 4usize];
  ["Offset of field: ADLSLSMode::iSLSModeIndex"]
    [::std::mem::offset_of!(ADLSLSMode, iSLSModeIndex) - 8usize];
  ["Offset of field: ADLSLSMode::displayMode"]
    [::std::mem::offset_of!(ADLSLSMode, displayMode) - 12usize];
  ["Offset of field: ADLSLSMode::iSLSNativeModeMask"]
    [::std::mem::offset_of!(ADLSLSMode, iSLSNativeModeMask) - 72usize];
  ["Offset of field: ADLSLSMode::iSLSNativeModeValue"]
    [::std::mem::offset_of!(ADLSLSMode, iSLSNativeModeValue) - 76usize];
};
#[doc = "\n\\brief Structure containing information about the display SLS Mode information.\n\n This structure is used to store the display SLS Mode information.\n \\nosubgrouping\n"]
pub type LPADLSLSMode = *mut ADLSLSMode;
#[doc = "\n\\brief Structure containing information about the display Possible SLS Map information.\n\n This structure is used to store the display Possible SLS Map information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLPossibleSLSMap {
  #[doc = " The current display map index. It is the OS Desktop index.\n For example, OS Index 1 showing clone mode. The Display Map will be 1."]
  pub iSLSMapIndex: ::std::os::raw::c_int,
  #[doc = " Number of display map to be validated."]
  pub iNumSLSMap: ::std::os::raw::c_int,
  #[doc = " The display map list for validation"]
  pub lpSLSMap: *mut ADLSLSMap,
  #[doc = " the number of display map config to be validated."]
  pub iNumSLSTarget: ::std::os::raw::c_int,
  #[doc = " The display target list for validation."]
  pub lpDisplayTarget: *mut ADLDisplayTarget,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLPossibleSLSMap"][::std::mem::size_of::<ADLPossibleSLSMap>() - 32usize];
  ["Alignment of ADLPossibleSLSMap"]
    [::std::mem::align_of::<ADLPossibleSLSMap>() - 8usize];
  ["Offset of field: ADLPossibleSLSMap::iSLSMapIndex"]
    [::std::mem::offset_of!(ADLPossibleSLSMap, iSLSMapIndex) - 0usize];
  ["Offset of field: ADLPossibleSLSMap::iNumSLSMap"]
    [::std::mem::offset_of!(ADLPossibleSLSMap, iNumSLSMap) - 4usize];
  ["Offset of field: ADLPossibleSLSMap::lpSLSMap"]
    [::std::mem::offset_of!(ADLPossibleSLSMap, lpSLSMap) - 8usize];
  ["Offset of field: ADLPossibleSLSMap::iNumSLSTarget"]
    [::std::mem::offset_of!(ADLPossibleSLSMap, iNumSLSTarget) - 16usize];
  ["Offset of field: ADLPossibleSLSMap::lpDisplayTarget"]
    [::std::mem::offset_of!(ADLPossibleSLSMap, lpDisplayTarget) - 24usize];
};
#[doc = "\n\\brief Structure containing information about the display Possible SLS Map information.\n\n This structure is used to store the display Possible SLS Map information.\n \\nosubgrouping\n"]
pub type LPADLPossibleSLSMap = *mut ADLPossibleSLSMap;
#[doc = "\n\\brief Structure containing information about the SLS targets.\n\n This structure is used to store the SLS targets information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLSLSTarget {
  #[doc = " the logic adapter index"]
  pub iAdapterIndex: ::std::os::raw::c_int,
  #[doc = " The SLS map index"]
  pub iSLSMapIndex: ::std::os::raw::c_int,
  #[doc = " The target ID"]
  pub displayTarget: ADLDisplayTarget,
  #[doc = " Target postion X in SLS grid"]
  pub iSLSGridPositionX: ::std::os::raw::c_int,
  #[doc = " Target postion Y in SLS grid"]
  pub iSLSGridPositionY: ::std::os::raw::c_int,
  #[doc = " The view size width, height and rotation angle per SLS Target"]
  pub viewSize: ADLMode,
  #[doc = " The bit mask identifies the bits in iSLSTargetValue are currently used"]
  pub iSLSTargetMask: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies status info. It is for function extension purpose"]
  pub iSLSTargetValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLSLSTarget"][::std::mem::size_of::<ADLSLSTarget>() - 112usize];
  ["Alignment of ADLSLSTarget"][::std::mem::align_of::<ADLSLSTarget>() - 4usize];
  ["Offset of field: ADLSLSTarget::iAdapterIndex"]
    [::std::mem::offset_of!(ADLSLSTarget, iAdapterIndex) - 0usize];
  ["Offset of field: ADLSLSTarget::iSLSMapIndex"]
    [::std::mem::offset_of!(ADLSLSTarget, iSLSMapIndex) - 4usize];
  ["Offset of field: ADLSLSTarget::displayTarget"]
    [::std::mem::offset_of!(ADLSLSTarget, displayTarget) - 8usize];
  ["Offset of field: ADLSLSTarget::iSLSGridPositionX"]
    [::std::mem::offset_of!(ADLSLSTarget, iSLSGridPositionX) - 36usize];
  ["Offset of field: ADLSLSTarget::iSLSGridPositionY"]
    [::std::mem::offset_of!(ADLSLSTarget, iSLSGridPositionY) - 40usize];
  ["Offset of field: ADLSLSTarget::viewSize"]
    [::std::mem::offset_of!(ADLSLSTarget, viewSize) - 44usize];
  ["Offset of field: ADLSLSTarget::iSLSTargetMask"]
    [::std::mem::offset_of!(ADLSLSTarget, iSLSTargetMask) - 104usize];
  ["Offset of field: ADLSLSTarget::iSLSTargetValue"]
    [::std::mem::offset_of!(ADLSLSTarget, iSLSTargetValue) - 108usize];
};
#[doc = "\n\\brief Structure containing information about the SLS targets.\n\n This structure is used to store the SLS targets information.\n \\nosubgrouping\n"]
pub type LPADLSLSTarget = *mut ADLSLSTarget;
#[doc = "\n\\brief Structure containing information about the Adapter offset stepping size.\n\n This structure is used to store the Adapter offset stepping size information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLBezelOffsetSteppingSize {
  #[doc = " the logic adapter index"]
  pub iAdapterIndex: ::std::os::raw::c_int,
  #[doc = " The SLS map index"]
  pub iSLSMapIndex: ::std::os::raw::c_int,
  #[doc = " Bezel X stepping size offset"]
  pub iBezelOffsetSteppingSizeX: ::std::os::raw::c_int,
  #[doc = " Bezel Y stepping size offset"]
  pub iBezelOffsetSteppingSizeY: ::std::os::raw::c_int,
  #[doc = " Identifies the bits this structure is currently using. It will be the total OR of all the bit definitions."]
  pub iBezelOffsetSteppingSizeMask: ::std::os::raw::c_int,
  #[doc = " Bit mask identifies the display status."]
  pub iBezelOffsetSteppingSizeValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLBezelOffsetSteppingSize"]
    [::std::mem::size_of::<ADLBezelOffsetSteppingSize>() - 24usize];
  ["Alignment of ADLBezelOffsetSteppingSize"]
    [::std::mem::align_of::<ADLBezelOffsetSteppingSize>() - 4usize];
  ["Offset of field: ADLBezelOffsetSteppingSize::iAdapterIndex"]
    [::std::mem::offset_of!(ADLBezelOffsetSteppingSize, iAdapterIndex) - 0usize];
  ["Offset of field: ADLBezelOffsetSteppingSize::iSLSMapIndex"]
    [::std::mem::offset_of!(ADLBezelOffsetSteppingSize, iSLSMapIndex) - 4usize];
  ["Offset of field: ADLBezelOffsetSteppingSize::iBezelOffsetSteppingSizeX"][::std::mem::offset_of!(
    ADLBezelOffsetSteppingSize,
    iBezelOffsetSteppingSizeX
  ) - 8usize];
  ["Offset of field: ADLBezelOffsetSteppingSize::iBezelOffsetSteppingSizeY"][::std::mem::offset_of!(
    ADLBezelOffsetSteppingSize,
    iBezelOffsetSteppingSizeY
  ) - 12usize];
  ["Offset of field: ADLBezelOffsetSteppingSize::iBezelOffsetSteppingSizeMask"][::std::mem::offset_of!(
    ADLBezelOffsetSteppingSize,
    iBezelOffsetSteppingSizeMask
  )
    - 16usize];
  ["Offset of field: ADLBezelOffsetSteppingSize::iBezelOffsetSteppingSizeValue"][::std::mem::offset_of!(
    ADLBezelOffsetSteppingSize,
    iBezelOffsetSteppingSizeValue
  )
    - 20usize];
};
#[doc = "\n\\brief Structure containing information about the Adapter offset stepping size.\n\n This structure is used to store the Adapter offset stepping size information.\n \\nosubgrouping\n"]
pub type LPADLBezelOffsetSteppingSize = *mut ADLBezelOffsetSteppingSize;
#[doc = "\n\\brief Structure containing information about the overlap offset info for all the displays for each SLS mode.\n\n This structure is used to store the no. of overlapped modes for each SLS Mode once user finishes the configuration from Overlap Widget\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLSLSOverlappedMode {
  #[doc = " the SLS mode for which the overlap is configured"]
  pub SLSMode: ADLMode,
  #[doc = " the number of target displays in SLS."]
  pub iNumSLSTarget: ::std::os::raw::c_int,
  #[doc = " the first target array index in the target array"]
  pub iFirstTargetArrayIndex: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLSLSOverlappedMode"]
    [::std::mem::size_of::<ADLSLSOverlappedMode>() - 68usize];
  ["Alignment of ADLSLSOverlappedMode"]
    [::std::mem::align_of::<ADLSLSOverlappedMode>() - 4usize];
  ["Offset of field: ADLSLSOverlappedMode::SLSMode"]
    [::std::mem::offset_of!(ADLSLSOverlappedMode, SLSMode) - 0usize];
  ["Offset of field: ADLSLSOverlappedMode::iNumSLSTarget"]
    [::std::mem::offset_of!(ADLSLSOverlappedMode, iNumSLSTarget) - 60usize];
  ["Offset of field: ADLSLSOverlappedMode::iFirstTargetArrayIndex"]
    [::std::mem::offset_of!(ADLSLSOverlappedMode, iFirstTargetArrayIndex) - 64usize];
};
#[doc = "\n\\brief Structure containing information about the overlap offset info for all the displays for each SLS mode.\n\n This structure is used to store the no. of overlapped modes for each SLS Mode once user finishes the configuration from Overlap Widget\n \\nosubgrouping\n"]
pub type ADLSLSTargetOverlap = ADLSLSOverlappedMode;
#[doc = "\n\\brief Structure containing information about the overlap offset info for all the displays for each SLS mode.\n\n This structure is used to store the no. of overlapped modes for each SLS Mode once user finishes the configuration from Overlap Widget\n \\nosubgrouping\n"]
pub type LPADLSLSTargetOverlap = *mut ADLSLSOverlappedMode;
#[doc = "\n\\brief Structure containing information about driver supported PowerExpress Config Caps\n\n This structure is used to store the driver supported PowerExpress Config Caps\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLPXConfigCaps {
  #[doc = " The Persistent logical Adapter Index."]
  pub iAdapterIndex: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the number of bits PowerExpress Config Caps is currently using. It is the sum of all the bit definitions defined in ADL_PX_CONFIGCAPS_XXXX /ref define_powerxpress_constants."]
  pub iPXConfigCapMask: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the PowerExpress Config Caps value. The detailed definition is in ADL_PX_CONFIGCAPS_XXXX /ref define_powerxpress_constants."]
  pub iPXConfigCapValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLPXConfigCaps"][::std::mem::size_of::<ADLPXConfigCaps>() - 12usize];
  ["Alignment of ADLPXConfigCaps"][::std::mem::align_of::<ADLPXConfigCaps>() - 4usize];
  ["Offset of field: ADLPXConfigCaps::iAdapterIndex"]
    [::std::mem::offset_of!(ADLPXConfigCaps, iAdapterIndex) - 0usize];
  ["Offset of field: ADLPXConfigCaps::iPXConfigCapMask"]
    [::std::mem::offset_of!(ADLPXConfigCaps, iPXConfigCapMask) - 4usize];
  ["Offset of field: ADLPXConfigCaps::iPXConfigCapValue"]
    [::std::mem::offset_of!(ADLPXConfigCaps, iPXConfigCapValue) - 8usize];
};
#[doc = "\n\\brief Structure containing information about driver supported PowerExpress Config Caps\n\n This structure is used to store the driver supported PowerExpress Config Caps\n \\nosubgrouping\n"]
pub type LPADLPXConfigCaps = *mut ADLPXConfigCaps;
pub const ADLPxType_ADL_PX_NONE: ADLPxType = 0;
pub const ADLPxType_ADL_SWITCHABLE_AMDAMD: ADLPxType = 1;
pub const ADLPxType_ADL_HG_AMDAMD: ADLPxType = 2;
pub const ADLPxType_ADL_SWITCHABLE_AMDOTHER: ADLPxType = 3;
pub const ADLPxType_ADL_HG_AMDOTHER: ADLPxType = 4;
#[doc = "\n\\brief Enum containing PX or HG type\n\n This enum is used to get PX or hG type\n\n \\nosubgrouping\n"]
pub type ADLPxType = ::std::os::raw::c_int;
#[doc = "\n\\brief Structure containing information about an application\n\n This structure is used to store basic information of an application\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLApplicationData {
  #[doc = " Path Name"]
  pub strPathName: [::std::os::raw::c_char; 256usize],
  #[doc = " File Name"]
  pub strFileName: [::std::os::raw::c_char; 256usize],
  #[doc = " Creation timestamp"]
  pub strTimeStamp: [::std::os::raw::c_char; 32usize],
  #[doc = " Version"]
  pub strVersion: [::std::os::raw::c_char; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLApplicationData"][::std::mem::size_of::<ADLApplicationData>() - 576usize];
  ["Alignment of ADLApplicationData"]
    [::std::mem::align_of::<ADLApplicationData>() - 1usize];
  ["Offset of field: ADLApplicationData::strPathName"]
    [::std::mem::offset_of!(ADLApplicationData, strPathName) - 0usize];
  ["Offset of field: ADLApplicationData::strFileName"]
    [::std::mem::offset_of!(ADLApplicationData, strFileName) - 256usize];
  ["Offset of field: ADLApplicationData::strTimeStamp"]
    [::std::mem::offset_of!(ADLApplicationData, strTimeStamp) - 512usize];
  ["Offset of field: ADLApplicationData::strVersion"]
    [::std::mem::offset_of!(ADLApplicationData, strVersion) - 544usize];
};
#[doc = "\n\\brief Structure containing information about an application\n\n This structure is used to store basic information of an application\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLApplicationDataX2 {
  #[doc = " Path Name"]
  pub strPathName: [wchar_t; 256usize],
  #[doc = " File Name"]
  pub strFileName: [wchar_t; 256usize],
  #[doc = " Creation timestamp"]
  pub strTimeStamp: [wchar_t; 32usize],
  #[doc = " Version"]
  pub strVersion: [wchar_t; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLApplicationDataX2"]
    [::std::mem::size_of::<ADLApplicationDataX2>() - 1152usize];
  ["Alignment of ADLApplicationDataX2"]
    [::std::mem::align_of::<ADLApplicationDataX2>() - 2usize];
  ["Offset of field: ADLApplicationDataX2::strPathName"]
    [::std::mem::offset_of!(ADLApplicationDataX2, strPathName) - 0usize];
  ["Offset of field: ADLApplicationDataX2::strFileName"]
    [::std::mem::offset_of!(ADLApplicationDataX2, strFileName) - 512usize];
  ["Offset of field: ADLApplicationDataX2::strTimeStamp"]
    [::std::mem::offset_of!(ADLApplicationDataX2, strTimeStamp) - 1024usize];
  ["Offset of field: ADLApplicationDataX2::strVersion"]
    [::std::mem::offset_of!(ADLApplicationDataX2, strVersion) - 1088usize];
};
#[doc = "\n\\brief Structure containing information about an application\n\n This structure is used to store basic information of an application including process id\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLApplicationDataX3 {
  #[doc = " Path Name"]
  pub strPathName: [wchar_t; 256usize],
  #[doc = " File Name"]
  pub strFileName: [wchar_t; 256usize],
  #[doc = " Creation timestamp"]
  pub strTimeStamp: [wchar_t; 32usize],
  #[doc = " Version"]
  pub strVersion: [wchar_t; 32usize],
  pub iProcessId: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLApplicationDataX3"]
    [::std::mem::size_of::<ADLApplicationDataX3>() - 1156usize];
  ["Alignment of ADLApplicationDataX3"]
    [::std::mem::align_of::<ADLApplicationDataX3>() - 4usize];
  ["Offset of field: ADLApplicationDataX3::strPathName"]
    [::std::mem::offset_of!(ADLApplicationDataX3, strPathName) - 0usize];
  ["Offset of field: ADLApplicationDataX3::strFileName"]
    [::std::mem::offset_of!(ADLApplicationDataX3, strFileName) - 512usize];
  ["Offset of field: ADLApplicationDataX3::strTimeStamp"]
    [::std::mem::offset_of!(ADLApplicationDataX3, strTimeStamp) - 1024usize];
  ["Offset of field: ADLApplicationDataX3::strVersion"]
    [::std::mem::offset_of!(ADLApplicationDataX3, strVersion) - 1088usize];
  ["Offset of field: ADLApplicationDataX3::iProcessId"]
    [::std::mem::offset_of!(ADLApplicationDataX3, iProcessId) - 1152usize];
};
#[doc = "\n\\brief Structure containing information of a property of an application profile\n\n This structure is used to store property information of an application profile\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PropertyRecord {
  #[doc = " Property Name"]
  pub strName: [::std::os::raw::c_char; 64usize],
  #[doc = " Property Type"]
  pub eType: ADLProfilePropertyType,
  #[doc = " Data Size in bytes"]
  pub iDataSize: ::std::os::raw::c_int,
  #[doc = " Property Value, can be any data type"]
  pub uData: [::std::os::raw::c_uchar; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of PropertyRecord"][::std::mem::size_of::<PropertyRecord>() - 76usize];
  ["Alignment of PropertyRecord"][::std::mem::align_of::<PropertyRecord>() - 4usize];
  ["Offset of field: PropertyRecord::strName"]
    [::std::mem::offset_of!(PropertyRecord, strName) - 0usize];
  ["Offset of field: PropertyRecord::eType"]
    [::std::mem::offset_of!(PropertyRecord, eType) - 64usize];
  ["Offset of field: PropertyRecord::iDataSize"]
    [::std::mem::offset_of!(PropertyRecord, iDataSize) - 68usize];
  ["Offset of field: PropertyRecord::uData"]
    [::std::mem::offset_of!(PropertyRecord, uData) - 72usize];
};
#[doc = "\n\\brief Structure containing information about an application profile\n\n This structure is used to store information of an application profile\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLApplicationProfile {
  #[doc = " Number of properties"]
  pub iCount: ::std::os::raw::c_int,
  #[doc = " Buffer to store all property records"]
  pub record: [PropertyRecord; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLApplicationProfile"]
    [::std::mem::size_of::<ADLApplicationProfile>() - 80usize];
  ["Alignment of ADLApplicationProfile"]
    [::std::mem::align_of::<ADLApplicationProfile>() - 4usize];
  ["Offset of field: ADLApplicationProfile::iCount"]
    [::std::mem::offset_of!(ADLApplicationProfile, iCount) - 0usize];
  ["Offset of field: ADLApplicationProfile::record"]
    [::std::mem::offset_of!(ADLApplicationProfile, record) - 4usize];
};
#[doc = "\n\\brief Structure containing information about an OD5 Power Control feature\n\n This structure is used to store information of an Power Control feature\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLPowerControlInfo {
  #[doc = " Minimum value."]
  pub iMinValue: ::std::os::raw::c_int,
  #[doc = " Maximum value."]
  pub iMaxValue: ::std::os::raw::c_int,
  #[doc = " The minimum change in between minValue and maxValue."]
  pub iStepValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLPowerControlInfo"][::std::mem::size_of::<ADLPowerControlInfo>() - 12usize];
  ["Alignment of ADLPowerControlInfo"]
    [::std::mem::align_of::<ADLPowerControlInfo>() - 4usize];
  ["Offset of field: ADLPowerControlInfo::iMinValue"]
    [::std::mem::offset_of!(ADLPowerControlInfo, iMinValue) - 0usize];
  ["Offset of field: ADLPowerControlInfo::iMaxValue"]
    [::std::mem::offset_of!(ADLPowerControlInfo, iMaxValue) - 4usize];
  ["Offset of field: ADLPowerControlInfo::iStepValue"]
    [::std::mem::offset_of!(ADLPowerControlInfo, iStepValue) - 8usize];
};
#[doc = "\n\\brief Structure containing information about an controller mode\n\n This structure is used to store information of an controller mode\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLControllerMode {
  #[doc = " This falg indicates actions that will be applied by set viewport\n The value can be a combination of ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_POSITION,\n ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_PANLOCK and ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_SIZE"]
  pub iModifiers: ::std::os::raw::c_int,
  #[doc = " Horizontal view starting position"]
  pub iViewPositionCx: ::std::os::raw::c_int,
  #[doc = " Vertical view starting position"]
  pub iViewPositionCy: ::std::os::raw::c_int,
  #[doc = " Horizontal left panlock position"]
  pub iViewPanLockLeft: ::std::os::raw::c_int,
  #[doc = " Horizontal right panlock position"]
  pub iViewPanLockRight: ::std::os::raw::c_int,
  #[doc = " Vertical top panlock position"]
  pub iViewPanLockTop: ::std::os::raw::c_int,
  #[doc = " Vertical bottom panlock position"]
  pub iViewPanLockBottom: ::std::os::raw::c_int,
  #[doc = " View resolution in pixels (width)"]
  pub iViewResolutionCx: ::std::os::raw::c_int,
  #[doc = " View resolution in pixels (hight)"]
  pub iViewResolutionCy: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLControllerMode"][::std::mem::size_of::<ADLControllerMode>() - 36usize];
  ["Alignment of ADLControllerMode"]
    [::std::mem::align_of::<ADLControllerMode>() - 4usize];
  ["Offset of field: ADLControllerMode::iModifiers"]
    [::std::mem::offset_of!(ADLControllerMode, iModifiers) - 0usize];
  ["Offset of field: ADLControllerMode::iViewPositionCx"]
    [::std::mem::offset_of!(ADLControllerMode, iViewPositionCx) - 4usize];
  ["Offset of field: ADLControllerMode::iViewPositionCy"]
    [::std::mem::offset_of!(ADLControllerMode, iViewPositionCy) - 8usize];
  ["Offset of field: ADLControllerMode::iViewPanLockLeft"]
    [::std::mem::offset_of!(ADLControllerMode, iViewPanLockLeft) - 12usize];
  ["Offset of field: ADLControllerMode::iViewPanLockRight"]
    [::std::mem::offset_of!(ADLControllerMode, iViewPanLockRight) - 16usize];
  ["Offset of field: ADLControllerMode::iViewPanLockTop"]
    [::std::mem::offset_of!(ADLControllerMode, iViewPanLockTop) - 20usize];
  ["Offset of field: ADLControllerMode::iViewPanLockBottom"]
    [::std::mem::offset_of!(ADLControllerMode, iViewPanLockBottom) - 24usize];
  ["Offset of field: ADLControllerMode::iViewResolutionCx"]
    [::std::mem::offset_of!(ADLControllerMode, iViewResolutionCx) - 28usize];
  ["Offset of field: ADLControllerMode::iViewResolutionCy"]
    [::std::mem::offset_of!(ADLControllerMode, iViewResolutionCy) - 32usize];
};
#[doc = "\n\\brief Structure containing information about a display\n\n This structure is used to store information about a display\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDisplayIdentifier {
  #[doc = " ADL display index"]
  pub ulDisplayIndex: ::std::os::raw::c_long,
  #[doc = " manufacturer ID of the display"]
  pub ulManufacturerId: ::std::os::raw::c_long,
  #[doc = " product ID of the display"]
  pub ulProductId: ::std::os::raw::c_long,
  #[doc = " serial number of the display"]
  pub ulSerialNo: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDisplayIdentifier"]
    [::std::mem::size_of::<ADLDisplayIdentifier>() - 16usize];
  ["Alignment of ADLDisplayIdentifier"]
    [::std::mem::align_of::<ADLDisplayIdentifier>() - 4usize];
  ["Offset of field: ADLDisplayIdentifier::ulDisplayIndex"]
    [::std::mem::offset_of!(ADLDisplayIdentifier, ulDisplayIndex) - 0usize];
  ["Offset of field: ADLDisplayIdentifier::ulManufacturerId"]
    [::std::mem::offset_of!(ADLDisplayIdentifier, ulManufacturerId) - 4usize];
  ["Offset of field: ADLDisplayIdentifier::ulProductId"]
    [::std::mem::offset_of!(ADLDisplayIdentifier, ulProductId) - 8usize];
  ["Offset of field: ADLDisplayIdentifier::ulSerialNo"]
    [::std::mem::offset_of!(ADLDisplayIdentifier, ulSerialNo) - 12usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive 6 clock range\n\n This structure is used to store information about Overdrive 6 clock range\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLOD6ParameterRange {
  #[doc = " The starting value of the clock range"]
  pub iMin: ::std::os::raw::c_int,
  #[doc = " The ending value of the clock range"]
  pub iMax: ::std::os::raw::c_int,
  #[doc = " The minimum increment between clock values"]
  pub iStep: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLOD6ParameterRange"]
    [::std::mem::size_of::<ADLOD6ParameterRange>() - 12usize];
  ["Alignment of ADLOD6ParameterRange"]
    [::std::mem::align_of::<ADLOD6ParameterRange>() - 4usize];
  ["Offset of field: ADLOD6ParameterRange::iMin"]
    [::std::mem::offset_of!(ADLOD6ParameterRange, iMin) - 0usize];
  ["Offset of field: ADLOD6ParameterRange::iMax"]
    [::std::mem::offset_of!(ADLOD6ParameterRange, iMax) - 4usize];
  ["Offset of field: ADLOD6ParameterRange::iStep"]
    [::std::mem::offset_of!(ADLOD6ParameterRange, iStep) - 8usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive 6 capabilities\n\n This structure is used to store information about Overdrive 6 capabilities\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLOD6Capabilities {
  #[doc = " Contains a bitmap of the OD6 capability flags.  Possible values: \\ref ADL_OD6_CAPABILITY_SCLK_CUSTOMIZATION,\n \\ref ADL_OD6_CAPABILITY_MCLK_CUSTOMIZATION, \\ref ADL_OD6_CAPABILITY_GPU_ACTIVITY_MONITOR"]
  pub iCapabilities: ::std::os::raw::c_int,
  #[doc = " Contains a bitmap indicating the power states\n supported by OD6.  Currently only the performance state\n is supported. Possible Values: \\ref ADL_OD6_SUPPORTEDSTATE_PERFORMANCE"]
  pub iSupportedStates: ::std::os::raw::c_int,
  #[doc = " Number of levels. OD6 will always use 2 levels, which describe\n the minimum to maximum clock ranges.\n The 1st level indicates the minimum clocks, and the 2nd level\n indicates the maximum clocks."]
  pub iNumberOfPerformanceLevels: ::std::os::raw::c_int,
  #[doc = " Contains the hard limits of the sclk range.  Overdrive\n clocks cannot be set outside this range."]
  pub sEngineClockRange: ADLOD6ParameterRange,
  #[doc = " Contains the hard limits of the mclk range.  Overdrive\n clocks cannot be set outside this range."]
  pub sMemoryClockRange: ADLOD6ParameterRange,
  #[doc = " Value for future extension"]
  pub iExtValue: ::std::os::raw::c_int,
  #[doc = " Mask for future extension"]
  pub iExtMask: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLOD6Capabilities"][::std::mem::size_of::<ADLOD6Capabilities>() - 44usize];
  ["Alignment of ADLOD6Capabilities"]
    [::std::mem::align_of::<ADLOD6Capabilities>() - 4usize];
  ["Offset of field: ADLOD6Capabilities::iCapabilities"]
    [::std::mem::offset_of!(ADLOD6Capabilities, iCapabilities) - 0usize];
  ["Offset of field: ADLOD6Capabilities::iSupportedStates"]
    [::std::mem::offset_of!(ADLOD6Capabilities, iSupportedStates) - 4usize];
  ["Offset of field: ADLOD6Capabilities::iNumberOfPerformanceLevels"]
    [::std::mem::offset_of!(ADLOD6Capabilities, iNumberOfPerformanceLevels) - 8usize];
  ["Offset of field: ADLOD6Capabilities::sEngineClockRange"]
    [::std::mem::offset_of!(ADLOD6Capabilities, sEngineClockRange) - 12usize];
  ["Offset of field: ADLOD6Capabilities::sMemoryClockRange"]
    [::std::mem::offset_of!(ADLOD6Capabilities, sMemoryClockRange) - 24usize];
  ["Offset of field: ADLOD6Capabilities::iExtValue"]
    [::std::mem::offset_of!(ADLOD6Capabilities, iExtValue) - 36usize];
  ["Offset of field: ADLOD6Capabilities::iExtMask"]
    [::std::mem::offset_of!(ADLOD6Capabilities, iExtMask) - 40usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive 6 clock values.\n\n This structure is used to store information about Overdrive 6 clock values.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLOD6PerformanceLevel {
  #[doc = " Engine (core) clock."]
  pub iEngineClock: ::std::os::raw::c_int,
  #[doc = " Memory clock."]
  pub iMemoryClock: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLOD6PerformanceLevel"]
    [::std::mem::size_of::<ADLOD6PerformanceLevel>() - 8usize];
  ["Alignment of ADLOD6PerformanceLevel"]
    [::std::mem::align_of::<ADLOD6PerformanceLevel>() - 4usize];
  ["Offset of field: ADLOD6PerformanceLevel::iEngineClock"]
    [::std::mem::offset_of!(ADLOD6PerformanceLevel, iEngineClock) - 0usize];
  ["Offset of field: ADLOD6PerformanceLevel::iMemoryClock"]
    [::std::mem::offset_of!(ADLOD6PerformanceLevel, iMemoryClock) - 4usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive 6 clocks.\n\n This structure is used to store information about Overdrive 6 clocks.  This is a\n variable-sized structure.  iNumberOfPerformanceLevels indicate how many elements\n are contained in the aLevels array.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLOD6StateInfo {
  #[doc = " Number of levels.  OD6 uses clock ranges instead of discrete performance levels.\n iNumberOfPerformanceLevels is always 2.  The 1st level indicates the minimum clocks\n in the range.  The 2nd level indicates the maximum clocks in the range."]
  pub iNumberOfPerformanceLevels: ::std::os::raw::c_int,
  #[doc = " Value for future extension"]
  pub iExtValue: ::std::os::raw::c_int,
  #[doc = " Mask for future extension"]
  pub iExtMask: ::std::os::raw::c_int,
  #[doc = " Variable-sized array of levels.\n The number of elements in the array is specified by iNumberofPerformanceLevels."]
  pub aLevels: [ADLOD6PerformanceLevel; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLOD6StateInfo"][::std::mem::size_of::<ADLOD6StateInfo>() - 20usize];
  ["Alignment of ADLOD6StateInfo"][::std::mem::align_of::<ADLOD6StateInfo>() - 4usize];
  ["Offset of field: ADLOD6StateInfo::iNumberOfPerformanceLevels"]
    [::std::mem::offset_of!(ADLOD6StateInfo, iNumberOfPerformanceLevels) - 0usize];
  ["Offset of field: ADLOD6StateInfo::iExtValue"]
    [::std::mem::offset_of!(ADLOD6StateInfo, iExtValue) - 4usize];
  ["Offset of field: ADLOD6StateInfo::iExtMask"]
    [::std::mem::offset_of!(ADLOD6StateInfo, iExtMask) - 8usize];
  ["Offset of field: ADLOD6StateInfo::aLevels"]
    [::std::mem::offset_of!(ADLOD6StateInfo, aLevels) - 12usize];
};
#[doc = "\n\\brief Structure containing information about current Overdrive 6 performance status.\n\n This structure is used to store information about current Overdrive 6 performance status.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLOD6CurrentStatus {
  #[doc = " Current engine clock in 10 KHz."]
  pub iEngineClock: ::std::os::raw::c_int,
  #[doc = " Current memory clock in 10 KHz."]
  pub iMemoryClock: ::std::os::raw::c_int,
  #[doc = " Current GPU activity in percent.  This\n indicates how \"busy\" the GPU is."]
  pub iActivityPercent: ::std::os::raw::c_int,
  #[doc = " Not used.  Reserved for future use."]
  pub iCurrentPerformanceLevel: ::std::os::raw::c_int,
  #[doc = " Current PCI-E bus speed"]
  pub iCurrentBusSpeed: ::std::os::raw::c_int,
  #[doc = " Current PCI-E bus # of lanes"]
  pub iCurrentBusLanes: ::std::os::raw::c_int,
  #[doc = " Maximum possible PCI-E bus # of lanes"]
  pub iMaximumBusLanes: ::std::os::raw::c_int,
  #[doc = " Value for future extension"]
  pub iExtValue: ::std::os::raw::c_int,
  #[doc = " Mask for future extension"]
  pub iExtMask: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLOD6CurrentStatus"][::std::mem::size_of::<ADLOD6CurrentStatus>() - 36usize];
  ["Alignment of ADLOD6CurrentStatus"]
    [::std::mem::align_of::<ADLOD6CurrentStatus>() - 4usize];
  ["Offset of field: ADLOD6CurrentStatus::iEngineClock"]
    [::std::mem::offset_of!(ADLOD6CurrentStatus, iEngineClock) - 0usize];
  ["Offset of field: ADLOD6CurrentStatus::iMemoryClock"]
    [::std::mem::offset_of!(ADLOD6CurrentStatus, iMemoryClock) - 4usize];
  ["Offset of field: ADLOD6CurrentStatus::iActivityPercent"]
    [::std::mem::offset_of!(ADLOD6CurrentStatus, iActivityPercent) - 8usize];
  ["Offset of field: ADLOD6CurrentStatus::iCurrentPerformanceLevel"]
    [::std::mem::offset_of!(ADLOD6CurrentStatus, iCurrentPerformanceLevel) - 12usize];
  ["Offset of field: ADLOD6CurrentStatus::iCurrentBusSpeed"]
    [::std::mem::offset_of!(ADLOD6CurrentStatus, iCurrentBusSpeed) - 16usize];
  ["Offset of field: ADLOD6CurrentStatus::iCurrentBusLanes"]
    [::std::mem::offset_of!(ADLOD6CurrentStatus, iCurrentBusLanes) - 20usize];
  ["Offset of field: ADLOD6CurrentStatus::iMaximumBusLanes"]
    [::std::mem::offset_of!(ADLOD6CurrentStatus, iMaximumBusLanes) - 24usize];
  ["Offset of field: ADLOD6CurrentStatus::iExtValue"]
    [::std::mem::offset_of!(ADLOD6CurrentStatus, iExtValue) - 28usize];
  ["Offset of field: ADLOD6CurrentStatus::iExtMask"]
    [::std::mem::offset_of!(ADLOD6CurrentStatus, iExtMask) - 32usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive 6 thermal contoller capabilities\n\n This structure is used to store information about Overdrive 6 thermal controller capabilities\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLOD6ThermalControllerCaps {
  #[doc = " Contains a bitmap of thermal controller capability flags. Possible values: \\ref ADL_OD6_TCCAPS_THERMAL_CONTROLLER, \\ref ADL_OD6_TCCAPS_FANSPEED_CONTROL,\n \\ref ADL_OD6_TCCAPS_FANSPEED_PERCENT_READ, \\ref ADL_OD6_TCCAPS_FANSPEED_PERCENT_WRITE, \\ref ADL_OD6_TCCAPS_FANSPEED_RPM_READ, \\ref ADL_OD6_TCCAPS_FANSPEED_RPM_WRITE"]
  pub iCapabilities: ::std::os::raw::c_int,
  #[doc = " Minimum fan speed expressed as a percentage"]
  pub iFanMinPercent: ::std::os::raw::c_int,
  #[doc = " Maximum fan speed expressed as a percentage"]
  pub iFanMaxPercent: ::std::os::raw::c_int,
  #[doc = " Minimum fan speed expressed in revolutions-per-minute"]
  pub iFanMinRPM: ::std::os::raw::c_int,
  #[doc = " Maximum fan speed expressed in revolutions-per-minute"]
  pub iFanMaxRPM: ::std::os::raw::c_int,
  #[doc = " Value for future extension"]
  pub iExtValue: ::std::os::raw::c_int,
  #[doc = " Mask for future extension"]
  pub iExtMask: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLOD6ThermalControllerCaps"]
    [::std::mem::size_of::<ADLOD6ThermalControllerCaps>() - 28usize];
  ["Alignment of ADLOD6ThermalControllerCaps"]
    [::std::mem::align_of::<ADLOD6ThermalControllerCaps>() - 4usize];
  ["Offset of field: ADLOD6ThermalControllerCaps::iCapabilities"]
    [::std::mem::offset_of!(ADLOD6ThermalControllerCaps, iCapabilities) - 0usize];
  ["Offset of field: ADLOD6ThermalControllerCaps::iFanMinPercent"]
    [::std::mem::offset_of!(ADLOD6ThermalControllerCaps, iFanMinPercent) - 4usize];
  ["Offset of field: ADLOD6ThermalControllerCaps::iFanMaxPercent"]
    [::std::mem::offset_of!(ADLOD6ThermalControllerCaps, iFanMaxPercent) - 8usize];
  ["Offset of field: ADLOD6ThermalControllerCaps::iFanMinRPM"]
    [::std::mem::offset_of!(ADLOD6ThermalControllerCaps, iFanMinRPM) - 12usize];
  ["Offset of field: ADLOD6ThermalControllerCaps::iFanMaxRPM"]
    [::std::mem::offset_of!(ADLOD6ThermalControllerCaps, iFanMaxRPM) - 16usize];
  ["Offset of field: ADLOD6ThermalControllerCaps::iExtValue"]
    [::std::mem::offset_of!(ADLOD6ThermalControllerCaps, iExtValue) - 20usize];
  ["Offset of field: ADLOD6ThermalControllerCaps::iExtMask"]
    [::std::mem::offset_of!(ADLOD6ThermalControllerCaps, iExtMask) - 24usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive 6 fan speed information\n\n This structure is used to store information about Overdrive 6 fan speed information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLOD6FanSpeedInfo {
  #[doc = " Contains a bitmap of the valid fan speed type flags.  Possible values: \\ref ADL_OD6_FANSPEED_TYPE_PERCENT, \\ref ADL_OD6_FANSPEED_TYPE_RPM, \\ref ADL_OD6_FANSPEED_USER_DEFINED"]
  pub iSpeedType: ::std::os::raw::c_int,
  #[doc = " Contains current fan speed in percent (if valid flag exists in iSpeedType)"]
  pub iFanSpeedPercent: ::std::os::raw::c_int,
  #[doc = " Contains current fan speed in RPM (if valid flag exists in iSpeedType)"]
  pub iFanSpeedRPM: ::std::os::raw::c_int,
  #[doc = " Value for future extension"]
  pub iExtValue: ::std::os::raw::c_int,
  #[doc = " Mask for future extension"]
  pub iExtMask: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLOD6FanSpeedInfo"][::std::mem::size_of::<ADLOD6FanSpeedInfo>() - 20usize];
  ["Alignment of ADLOD6FanSpeedInfo"]
    [::std::mem::align_of::<ADLOD6FanSpeedInfo>() - 4usize];
  ["Offset of field: ADLOD6FanSpeedInfo::iSpeedType"]
    [::std::mem::offset_of!(ADLOD6FanSpeedInfo, iSpeedType) - 0usize];
  ["Offset of field: ADLOD6FanSpeedInfo::iFanSpeedPercent"]
    [::std::mem::offset_of!(ADLOD6FanSpeedInfo, iFanSpeedPercent) - 4usize];
  ["Offset of field: ADLOD6FanSpeedInfo::iFanSpeedRPM"]
    [::std::mem::offset_of!(ADLOD6FanSpeedInfo, iFanSpeedRPM) - 8usize];
  ["Offset of field: ADLOD6FanSpeedInfo::iExtValue"]
    [::std::mem::offset_of!(ADLOD6FanSpeedInfo, iExtValue) - 12usize];
  ["Offset of field: ADLOD6FanSpeedInfo::iExtMask"]
    [::std::mem::offset_of!(ADLOD6FanSpeedInfo, iExtMask) - 16usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive 6 fan speed value\n\n This structure is used to store information about Overdrive 6 fan speed value\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLOD6FanSpeedValue {
  #[doc = " Indicates the units of the fan speed.  Possible values: \\ref ADL_OD6_FANSPEED_TYPE_PERCENT, \\ref ADL_OD6_FANSPEED_TYPE_RPM"]
  pub iSpeedType: ::std::os::raw::c_int,
  #[doc = " Fan speed value (units as indicated above)"]
  pub iFanSpeed: ::std::os::raw::c_int,
  #[doc = " Value for future extension"]
  pub iExtValue: ::std::os::raw::c_int,
  #[doc = " Mask for future extension"]
  pub iExtMask: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLOD6FanSpeedValue"][::std::mem::size_of::<ADLOD6FanSpeedValue>() - 16usize];
  ["Alignment of ADLOD6FanSpeedValue"]
    [::std::mem::align_of::<ADLOD6FanSpeedValue>() - 4usize];
  ["Offset of field: ADLOD6FanSpeedValue::iSpeedType"]
    [::std::mem::offset_of!(ADLOD6FanSpeedValue, iSpeedType) - 0usize];
  ["Offset of field: ADLOD6FanSpeedValue::iFanSpeed"]
    [::std::mem::offset_of!(ADLOD6FanSpeedValue, iFanSpeed) - 4usize];
  ["Offset of field: ADLOD6FanSpeedValue::iExtValue"]
    [::std::mem::offset_of!(ADLOD6FanSpeedValue, iExtValue) - 8usize];
  ["Offset of field: ADLOD6FanSpeedValue::iExtMask"]
    [::std::mem::offset_of!(ADLOD6FanSpeedValue, iExtMask) - 12usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive 6 PowerControl settings.\n\n This structure is used to store information about Overdrive 6 PowerControl settings.\n PowerControl is the feature which allows the performance characteristics of the GPU\n to be adjusted by changing the PowerTune power limits.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLOD6PowerControlInfo {
  #[doc = " The minimum PowerControl adjustment value"]
  pub iMinValue: ::std::os::raw::c_int,
  #[doc = " The maximum PowerControl adjustment value"]
  pub iMaxValue: ::std::os::raw::c_int,
  #[doc = " The minimum difference between PowerControl adjustment values"]
  pub iStepValue: ::std::os::raw::c_int,
  #[doc = " Value for future extension"]
  pub iExtValue: ::std::os::raw::c_int,
  #[doc = " Mask for future extension"]
  pub iExtMask: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLOD6PowerControlInfo"]
    [::std::mem::size_of::<ADLOD6PowerControlInfo>() - 20usize];
  ["Alignment of ADLOD6PowerControlInfo"]
    [::std::mem::align_of::<ADLOD6PowerControlInfo>() - 4usize];
  ["Offset of field: ADLOD6PowerControlInfo::iMinValue"]
    [::std::mem::offset_of!(ADLOD6PowerControlInfo, iMinValue) - 0usize];
  ["Offset of field: ADLOD6PowerControlInfo::iMaxValue"]
    [::std::mem::offset_of!(ADLOD6PowerControlInfo, iMaxValue) - 4usize];
  ["Offset of field: ADLOD6PowerControlInfo::iStepValue"]
    [::std::mem::offset_of!(ADLOD6PowerControlInfo, iStepValue) - 8usize];
  ["Offset of field: ADLOD6PowerControlInfo::iExtValue"]
    [::std::mem::offset_of!(ADLOD6PowerControlInfo, iExtValue) - 12usize];
  ["Offset of field: ADLOD6PowerControlInfo::iExtMask"]
    [::std::mem::offset_of!(ADLOD6PowerControlInfo, iExtMask) - 16usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive 6 PowerControl settings.\n\n This structure is used to store information about Overdrive 6 PowerControl settings.\n PowerControl is the feature which allows the performance characteristics of the GPU\n to be adjusted by changing the PowerTune power limits.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLOD6VoltageControlInfo {
  #[doc = " The minimum VoltageControl adjustment value"]
  pub iMinValue: ::std::os::raw::c_int,
  #[doc = " The maximum VoltageControl adjustment value"]
  pub iMaxValue: ::std::os::raw::c_int,
  #[doc = " The minimum difference between VoltageControl adjustment values"]
  pub iStepValue: ::std::os::raw::c_int,
  #[doc = " Value for future extension"]
  pub iExtValue: ::std::os::raw::c_int,
  #[doc = " Mask for future extension"]
  pub iExtMask: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLOD6VoltageControlInfo"]
    [::std::mem::size_of::<ADLOD6VoltageControlInfo>() - 20usize];
  ["Alignment of ADLOD6VoltageControlInfo"]
    [::std::mem::align_of::<ADLOD6VoltageControlInfo>() - 4usize];
  ["Offset of field: ADLOD6VoltageControlInfo::iMinValue"]
    [::std::mem::offset_of!(ADLOD6VoltageControlInfo, iMinValue) - 0usize];
  ["Offset of field: ADLOD6VoltageControlInfo::iMaxValue"]
    [::std::mem::offset_of!(ADLOD6VoltageControlInfo, iMaxValue) - 4usize];
  ["Offset of field: ADLOD6VoltageControlInfo::iStepValue"]
    [::std::mem::offset_of!(ADLOD6VoltageControlInfo, iStepValue) - 8usize];
  ["Offset of field: ADLOD6VoltageControlInfo::iExtValue"]
    [::std::mem::offset_of!(ADLOD6VoltageControlInfo, iExtValue) - 12usize];
  ["Offset of field: ADLOD6VoltageControlInfo::iExtMask"]
    [::std::mem::offset_of!(ADLOD6VoltageControlInfo, iExtMask) - 16usize];
};
#[doc = "\n\\brief Structure containing ECC statistics namely SEC counts and DED counts\n Single error count - count of errors that can be corrected\n Doubt Error Detect -  count of errors that cannot be corrected\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLECCData {
  pub iSec: ::std::os::raw::c_int,
  pub iDed: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLECCData"][::std::mem::size_of::<ADLECCData>() - 8usize];
  ["Alignment of ADLECCData"][::std::mem::align_of::<ADLECCData>() - 4usize];
  ["Offset of field: ADLECCData::iSec"]
    [::std::mem::offset_of!(ADLECCData, iSec) - 0usize];
  ["Offset of field: ADLECCData::iDed"]
    [::std::mem::offset_of!(ADLECCData, iDed) - 4usize];
};
#[doc = " \\brief Handle to ADL client context.\n\n  ADL clients obtain context handle from initial call to \\ref ADL2_Main_Control_Create.\n  Clients have to pass the handle to each subsequent ADL call and finally destroy\n  the context with call to \\ref ADL2_Main_Control_Destroy\n \\nosubgrouping"]
pub type ADL_CONTEXT_HANDLE = *mut ::std::os::raw::c_void;
#[doc = " \\brief Handle to ADL Frame Monitor Token.\n\n  Frame Monitor clients obtain handle from initial call to \\ref ADL2_Adapter_FrameMetrics_FrameDuration_Enable\n  Clients have to pass the handle to each subsequent ADL call to \\ref ADL2_Adapter_FrameMetrics_FrameDuration_Get\n  and finally destroy the token with call to \\ref ADL2_Adapter_FrameMetrics_FrameDuration_Disable\n \\nosubgrouping"]
pub type ADL_FRAME_DURATION_HANDLE = *mut ::std::os::raw::c_void;
#[doc = "\n\\brief Structure containing the display mode definition used per controller.\n\n This structure is used to store the display mode definition used per controller.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDisplayModeX2 {
  #[doc = " Horizontal resolution (in pixels)."]
  pub iWidth: ::std::os::raw::c_int,
  #[doc = " Vertical resolution (in lines)."]
  pub iHeight: ::std::os::raw::c_int,
  #[doc = " Interlaced/Progressive. The value will be set for Interlaced as ADL_DL_TIMINGFLAG_INTERLACED. If not set it is progressive. Refer define_detailed_timing_flags."]
  pub iScanType: ::std::os::raw::c_int,
  #[doc = " Refresh rate."]
  pub iRefreshRate: ::std::os::raw::c_int,
  #[doc = " Timing Standard. Refer define_modetiming_standard."]
  pub iTimingStandard: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDisplayModeX2"][::std::mem::size_of::<ADLDisplayModeX2>() - 20usize];
  ["Alignment of ADLDisplayModeX2"][::std::mem::align_of::<ADLDisplayModeX2>() - 4usize];
  ["Offset of field: ADLDisplayModeX2::iWidth"]
    [::std::mem::offset_of!(ADLDisplayModeX2, iWidth) - 0usize];
  ["Offset of field: ADLDisplayModeX2::iHeight"]
    [::std::mem::offset_of!(ADLDisplayModeX2, iHeight) - 4usize];
  ["Offset of field: ADLDisplayModeX2::iScanType"]
    [::std::mem::offset_of!(ADLDisplayModeX2, iScanType) - 8usize];
  ["Offset of field: ADLDisplayModeX2::iRefreshRate"]
    [::std::mem::offset_of!(ADLDisplayModeX2, iRefreshRate) - 12usize];
  ["Offset of field: ADLDisplayModeX2::iTimingStandard"]
    [::std::mem::offset_of!(ADLDisplayModeX2, iTimingStandard) - 16usize];
};
pub const ADLAppProcessState_APP_PROC_INVALID: ADLAppProcessState = 0;
pub const ADLAppProcessState_APP_PROC_PREMPTION: ADLAppProcessState = 1;
pub const ADLAppProcessState_APP_PROC_CREATION: ADLAppProcessState = 2;
pub const ADLAppProcessState_APP_PROC_READ: ADLAppProcessState = 3;
pub const ADLAppProcessState_APP_PROC_WAIT: ADLAppProcessState = 4;
pub const ADLAppProcessState_APP_PROC_RUNNING: ADLAppProcessState = 5;
pub const ADLAppProcessState_APP_PROC_TERMINATE: ADLAppProcessState = 6;
pub type ADLAppProcessState = ::std::os::raw::c_int;
pub const ADLAppInterceptionListType_ADL_INVALID_FORMAT: ADLAppInterceptionListType = 0;
pub const ADLAppInterceptionListType_ADL_IMAGEFILEFORMAT: ADLAppInterceptionListType = 1;
pub const ADLAppInterceptionListType_ADL_ENVVAR: ADLAppInterceptionListType = 2;
pub type ADLAppInterceptionListType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLAppInterceptionInfo {
  pub AppName: [wchar_t; 256usize],
  pub ProcessId: ::std::os::raw::c_uint,
  pub AppFormat: ADLAppInterceptionListType,
  pub AppState: ADLAppProcessState,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLAppInterceptionInfo"]
    [::std::mem::size_of::<ADLAppInterceptionInfo>() - 524usize];
  ["Alignment of ADLAppInterceptionInfo"]
    [::std::mem::align_of::<ADLAppInterceptionInfo>() - 4usize];
  ["Offset of field: ADLAppInterceptionInfo::AppName"]
    [::std::mem::offset_of!(ADLAppInterceptionInfo, AppName) - 0usize];
  ["Offset of field: ADLAppInterceptionInfo::ProcessId"]
    [::std::mem::offset_of!(ADLAppInterceptionInfo, ProcessId) - 512usize];
  ["Offset of field: ADLAppInterceptionInfo::AppFormat"]
    [::std::mem::offset_of!(ADLAppInterceptionInfo, AppFormat) - 516usize];
  ["Offset of field: ADLAppInterceptionInfo::AppState"]
    [::std::mem::offset_of!(ADLAppInterceptionInfo, AppState) - 520usize];
};
pub const ADL_AP_DATABASE_ADL_AP_DATABASE__SYSTEM: ADL_AP_DATABASE = 0;
pub const ADL_AP_DATABASE_ADL_AP_DATABASE__USER: ADL_AP_DATABASE = 1;
pub const ADL_AP_DATABASE_ADL_AP_DATABASE__OEM: ADL_AP_DATABASE = 2;
pub type ADL_AP_DATABASE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLAppInterceptionInfoX2 {
  pub AppName: [wchar_t; 256usize],
  pub ProcessId: ::std::os::raw::c_uint,
  pub WaitForResumeNeeded: ::std::os::raw::c_uint,
  pub CommandLine: [wchar_t; 256usize],
  pub AppFormat: ADLAppInterceptionListType,
  pub AppState: ADLAppProcessState,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLAppInterceptionInfoX2"]
    [::std::mem::size_of::<ADLAppInterceptionInfoX2>() - 1040usize];
  ["Alignment of ADLAppInterceptionInfoX2"]
    [::std::mem::align_of::<ADLAppInterceptionInfoX2>() - 4usize];
  ["Offset of field: ADLAppInterceptionInfoX2::AppName"]
    [::std::mem::offset_of!(ADLAppInterceptionInfoX2, AppName) - 0usize];
  ["Offset of field: ADLAppInterceptionInfoX2::ProcessId"]
    [::std::mem::offset_of!(ADLAppInterceptionInfoX2, ProcessId) - 512usize];
  ["Offset of field: ADLAppInterceptionInfoX2::WaitForResumeNeeded"]
    [::std::mem::offset_of!(ADLAppInterceptionInfoX2, WaitForResumeNeeded) - 516usize];
  ["Offset of field: ADLAppInterceptionInfoX2::CommandLine"]
    [::std::mem::offset_of!(ADLAppInterceptionInfoX2, CommandLine) - 520usize];
  ["Offset of field: ADLAppInterceptionInfoX2::AppFormat"]
    [::std::mem::offset_of!(ADLAppInterceptionInfoX2, AppFormat) - 1032usize];
  ["Offset of field: ADLAppInterceptionInfoX2::AppState"]
    [::std::mem::offset_of!(ADLAppInterceptionInfoX2, AppState) - 1036usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLAppInterceptionInfoX3 {
  pub AppName: [wchar_t; 256usize],
  pub ProcessId: ::std::os::raw::c_uint,
  pub WaitForResumeNeeded: ::std::os::raw::c_uint,
  pub RayTracingStatus: ::std::os::raw::c_uint,
  pub CommandLine: [wchar_t; 256usize],
  pub AppFormat: ADLAppInterceptionListType,
  pub AppState: ADLAppProcessState,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLAppInterceptionInfoX3"]
    [::std::mem::size_of::<ADLAppInterceptionInfoX3>() - 1044usize];
  ["Alignment of ADLAppInterceptionInfoX3"]
    [::std::mem::align_of::<ADLAppInterceptionInfoX3>() - 4usize];
  ["Offset of field: ADLAppInterceptionInfoX3::AppName"]
    [::std::mem::offset_of!(ADLAppInterceptionInfoX3, AppName) - 0usize];
  ["Offset of field: ADLAppInterceptionInfoX3::ProcessId"]
    [::std::mem::offset_of!(ADLAppInterceptionInfoX3, ProcessId) - 512usize];
  ["Offset of field: ADLAppInterceptionInfoX3::WaitForResumeNeeded"]
    [::std::mem::offset_of!(ADLAppInterceptionInfoX3, WaitForResumeNeeded) - 516usize];
  ["Offset of field: ADLAppInterceptionInfoX3::RayTracingStatus"]
    [::std::mem::offset_of!(ADLAppInterceptionInfoX3, RayTracingStatus) - 520usize];
  ["Offset of field: ADLAppInterceptionInfoX3::CommandLine"]
    [::std::mem::offset_of!(ADLAppInterceptionInfoX3, CommandLine) - 524usize];
  ["Offset of field: ADLAppInterceptionInfoX3::AppFormat"]
    [::std::mem::offset_of!(ADLAppInterceptionInfoX3, AppFormat) - 1036usize];
  ["Offset of field: ADLAppInterceptionInfoX3::AppState"]
    [::std::mem::offset_of!(ADLAppInterceptionInfoX3, AppState) - 1040usize];
};
#[doc = "\n\\brief Structure containing information info for a property record in a profile\n\n This structure is used to store info for a property record in a profile\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLPropertyRecordCreate {
  #[doc = " Name of the property"]
  pub strPropertyName: *mut wchar_t,
  #[doc = " Data type of the property"]
  pub eType: ADLProfilePropertyType,
  pub strPropertyValue: *mut wchar_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLPropertyRecordCreate"]
    [::std::mem::size_of::<ADLPropertyRecordCreate>() - 24usize];
  ["Alignment of ADLPropertyRecordCreate"]
    [::std::mem::align_of::<ADLPropertyRecordCreate>() - 8usize];
  ["Offset of field: ADLPropertyRecordCreate::strPropertyName"]
    [::std::mem::offset_of!(ADLPropertyRecordCreate, strPropertyName) - 0usize];
  ["Offset of field: ADLPropertyRecordCreate::eType"]
    [::std::mem::offset_of!(ADLPropertyRecordCreate, eType) - 8usize];
  ["Offset of field: ADLPropertyRecordCreate::strPropertyValue"]
    [::std::mem::offset_of!(ADLPropertyRecordCreate, strPropertyValue) - 16usize];
};
#[doc = "\n\\brief Structure containing information info for an application record\n\n This structure is used to store info for an application record\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLApplicationRecord {
  #[doc = " Title of the application"]
  pub strTitle: *mut wchar_t,
  #[doc = " File path of the application"]
  pub strPathName: *mut wchar_t,
  #[doc = " File name of the application"]
  pub strFileName: *mut wchar_t,
  #[doc = " File versin the application"]
  pub strVersion: *mut wchar_t,
  #[doc = " Nostes on the application"]
  pub strNotes: *mut wchar_t,
  #[doc = " Driver area which the application uses"]
  pub strArea: *mut wchar_t,
  #[doc = " Name of profile assigned to the application"]
  pub strProfileName: *mut wchar_t,
  pub recordSource: ADL_AP_DATABASE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLApplicationRecord"]
    [::std::mem::size_of::<ADLApplicationRecord>() - 64usize];
  ["Alignment of ADLApplicationRecord"]
    [::std::mem::align_of::<ADLApplicationRecord>() - 8usize];
  ["Offset of field: ADLApplicationRecord::strTitle"]
    [::std::mem::offset_of!(ADLApplicationRecord, strTitle) - 0usize];
  ["Offset of field: ADLApplicationRecord::strPathName"]
    [::std::mem::offset_of!(ADLApplicationRecord, strPathName) - 8usize];
  ["Offset of field: ADLApplicationRecord::strFileName"]
    [::std::mem::offset_of!(ADLApplicationRecord, strFileName) - 16usize];
  ["Offset of field: ADLApplicationRecord::strVersion"]
    [::std::mem::offset_of!(ADLApplicationRecord, strVersion) - 24usize];
  ["Offset of field: ADLApplicationRecord::strNotes"]
    [::std::mem::offset_of!(ADLApplicationRecord, strNotes) - 32usize];
  ["Offset of field: ADLApplicationRecord::strArea"]
    [::std::mem::offset_of!(ADLApplicationRecord, strArea) - 40usize];
  ["Offset of field: ADLApplicationRecord::strProfileName"]
    [::std::mem::offset_of!(ADLApplicationRecord, strProfileName) - 48usize];
  ["Offset of field: ADLApplicationRecord::recordSource"]
    [::std::mem::offset_of!(ADLApplicationRecord, recordSource) - 56usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive 6 extension capabilities\n\n This structure is used to store information about Overdrive 6 extension capabilities\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLOD6CapabilitiesEx {
  #[doc = " Contains a bitmap of the OD6 extension capability flags.  Possible values: \\ref ADL_OD6_CAPABILITY_SCLK_CUSTOMIZATION,\n \\ref ADL_OD6_CAPABILITY_MCLK_CUSTOMIZATION, \\ref ADL_OD6_CAPABILITY_GPU_ACTIVITY_MONITOR,\n \\ref ADL_OD6_CAPABILITY_POWER_CONTROL, \\ref ADL_OD6_CAPABILITY_VOLTAGE_CONTROL, \\ref ADL_OD6_CAPABILITY_PERCENT_ADJUSTMENT,\n \\ref ADL_OD6_CAPABILITY_THERMAL_LIMIT_UNLOCK"]
  pub iCapabilities: ::std::os::raw::c_int,
  #[doc = " The Power states that support clock and power customization.  Only performance state is currently supported.\n Possible Values: \\ref ADL_OD6_SUPPORTEDSTATE_PERFORMANCE"]
  pub iSupportedStates: ::std::os::raw::c_int,
  #[doc = " Returns the hard limits of the SCLK overdrive adjustment range.  Overdrive clocks should not be adjusted outside of this range.  The values are specified as +/- percentages."]
  pub sEngineClockPercent: ADLOD6ParameterRange,
  #[doc = " Returns the hard limits of the MCLK overdrive adjustment range.  Overdrive clocks should not be adjusted outside of this range.  The values are specified as +/- percentages."]
  pub sMemoryClockPercent: ADLOD6ParameterRange,
  #[doc = " Returns the hard limits of the Power Limit adjustment range.  Power limit should not be adjusted outside this range.  The values are specified as +/- percentages."]
  pub sPowerControlPercent: ADLOD6ParameterRange,
  #[doc = " Reserved for future expansion of the structure."]
  pub iExtValue: ::std::os::raw::c_int,
  #[doc = " Reserved for future expansion of the structure."]
  pub iExtMask: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLOD6CapabilitiesEx"]
    [::std::mem::size_of::<ADLOD6CapabilitiesEx>() - 52usize];
  ["Alignment of ADLOD6CapabilitiesEx"]
    [::std::mem::align_of::<ADLOD6CapabilitiesEx>() - 4usize];
  ["Offset of field: ADLOD6CapabilitiesEx::iCapabilities"]
    [::std::mem::offset_of!(ADLOD6CapabilitiesEx, iCapabilities) - 0usize];
  ["Offset of field: ADLOD6CapabilitiesEx::iSupportedStates"]
    [::std::mem::offset_of!(ADLOD6CapabilitiesEx, iSupportedStates) - 4usize];
  ["Offset of field: ADLOD6CapabilitiesEx::sEngineClockPercent"]
    [::std::mem::offset_of!(ADLOD6CapabilitiesEx, sEngineClockPercent) - 8usize];
  ["Offset of field: ADLOD6CapabilitiesEx::sMemoryClockPercent"]
    [::std::mem::offset_of!(ADLOD6CapabilitiesEx, sMemoryClockPercent) - 20usize];
  ["Offset of field: ADLOD6CapabilitiesEx::sPowerControlPercent"]
    [::std::mem::offset_of!(ADLOD6CapabilitiesEx, sPowerControlPercent) - 32usize];
  ["Offset of field: ADLOD6CapabilitiesEx::iExtValue"]
    [::std::mem::offset_of!(ADLOD6CapabilitiesEx, iExtValue) - 44usize];
  ["Offset of field: ADLOD6CapabilitiesEx::iExtMask"]
    [::std::mem::offset_of!(ADLOD6CapabilitiesEx, iExtMask) - 48usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive 6 extension state information\n\n This structure is used to store information about Overdrive 6 extension state information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLOD6StateEx {
  #[doc = " The current engine clock adjustment value, specified as a +/- percent."]
  pub iEngineClockPercent: ::std::os::raw::c_int,
  #[doc = " The current memory clock adjustment value, specified as a +/- percent."]
  pub iMemoryClockPercent: ::std::os::raw::c_int,
  #[doc = " The current power control adjustment value, specified as a +/- percent."]
  pub iPowerControlPercent: ::std::os::raw::c_int,
  #[doc = " Reserved for future expansion of the structure."]
  pub iExtValue: ::std::os::raw::c_int,
  #[doc = " Reserved for future expansion of the structure."]
  pub iExtMask: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLOD6StateEx"][::std::mem::size_of::<ADLOD6StateEx>() - 20usize];
  ["Alignment of ADLOD6StateEx"][::std::mem::align_of::<ADLOD6StateEx>() - 4usize];
  ["Offset of field: ADLOD6StateEx::iEngineClockPercent"]
    [::std::mem::offset_of!(ADLOD6StateEx, iEngineClockPercent) - 0usize];
  ["Offset of field: ADLOD6StateEx::iMemoryClockPercent"]
    [::std::mem::offset_of!(ADLOD6StateEx, iMemoryClockPercent) - 4usize];
  ["Offset of field: ADLOD6StateEx::iPowerControlPercent"]
    [::std::mem::offset_of!(ADLOD6StateEx, iPowerControlPercent) - 8usize];
  ["Offset of field: ADLOD6StateEx::iExtValue"]
    [::std::mem::offset_of!(ADLOD6StateEx, iExtValue) - 12usize];
  ["Offset of field: ADLOD6StateEx::iExtMask"]
    [::std::mem::offset_of!(ADLOD6StateEx, iExtMask) - 16usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive 6 extension recommended maximum clock adjustment values\n\n This structure is used to store information about Overdrive 6 extension recommended maximum clock adjustment values\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLOD6MaxClockAdjust {
  #[doc = " The recommended maximum engine clock adjustment in percent, for the specified power limit value."]
  pub iEngineClockMax: ::std::os::raw::c_int,
  #[doc = " The recommended maximum memory clock adjustment in percent, for the specified power limit value.\n Currently the memory is independent of the Power Limit setting, so iMemoryClockMax will always return the maximum\n possible adjustment value.  This field is here for future enhancement in case we add a dependency between Memory Clock\n adjustment and Power Limit setting."]
  pub iMemoryClockMax: ::std::os::raw::c_int,
  #[doc = " Reserved for future expansion of the structure."]
  pub iExtValue: ::std::os::raw::c_int,
  #[doc = " Reserved for future expansion of the structure."]
  pub iExtMask: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLOD6MaxClockAdjust"]
    [::std::mem::size_of::<ADLOD6MaxClockAdjust>() - 16usize];
  ["Alignment of ADLOD6MaxClockAdjust"]
    [::std::mem::align_of::<ADLOD6MaxClockAdjust>() - 4usize];
  ["Offset of field: ADLOD6MaxClockAdjust::iEngineClockMax"]
    [::std::mem::offset_of!(ADLOD6MaxClockAdjust, iEngineClockMax) - 0usize];
  ["Offset of field: ADLOD6MaxClockAdjust::iMemoryClockMax"]
    [::std::mem::offset_of!(ADLOD6MaxClockAdjust, iMemoryClockMax) - 4usize];
  ["Offset of field: ADLOD6MaxClockAdjust::iExtValue"]
    [::std::mem::offset_of!(ADLOD6MaxClockAdjust, iExtValue) - 8usize];
  ["Offset of field: ADLOD6MaxClockAdjust::iExtMask"]
    [::std::mem::offset_of!(ADLOD6MaxClockAdjust, iExtMask) - 12usize];
};
#[doc = "\n\\brief Structure containing the Connector information\n\n this structure is used to get the connector information like length, positions & etc.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLConnectorInfo {
  #[doc = "index of the connector(0-based)"]
  pub iConnectorIndex: ::std::os::raw::c_int,
  #[doc = "used for disply identification/ordering"]
  pub iConnectorId: ::std::os::raw::c_int,
  #[doc = "index of the slot, 0-based index."]
  pub iSlotIndex: ::std::os::raw::c_int,
  #[doc = "Type of the connector. \\ref define_connector_types"]
  pub iType: ::std::os::raw::c_int,
  #[doc = "Position of the connector(in millimeters), from the right side of the slot."]
  pub iOffset: ::std::os::raw::c_int,
  #[doc = "Length of the connector(in millimeters)."]
  pub iLength: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLConnectorInfo"][::std::mem::size_of::<ADLConnectorInfo>() - 24usize];
  ["Alignment of ADLConnectorInfo"][::std::mem::align_of::<ADLConnectorInfo>() - 4usize];
  ["Offset of field: ADLConnectorInfo::iConnectorIndex"]
    [::std::mem::offset_of!(ADLConnectorInfo, iConnectorIndex) - 0usize];
  ["Offset of field: ADLConnectorInfo::iConnectorId"]
    [::std::mem::offset_of!(ADLConnectorInfo, iConnectorId) - 4usize];
  ["Offset of field: ADLConnectorInfo::iSlotIndex"]
    [::std::mem::offset_of!(ADLConnectorInfo, iSlotIndex) - 8usize];
  ["Offset of field: ADLConnectorInfo::iType"]
    [::std::mem::offset_of!(ADLConnectorInfo, iType) - 12usize];
  ["Offset of field: ADLConnectorInfo::iOffset"]
    [::std::mem::offset_of!(ADLConnectorInfo, iOffset) - 16usize];
  ["Offset of field: ADLConnectorInfo::iLength"]
    [::std::mem::offset_of!(ADLConnectorInfo, iLength) - 20usize];
};
#[doc = "\n\\brief Structure containing the slot information\n\n this structure is used to get the slot information like length of the slot, no of connectors on the slot & etc.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLBracketSlotInfo {
  #[doc = "index of the slot, 0-based index."]
  pub iSlotIndex: ::std::os::raw::c_int,
  #[doc = "length of the slot(in millimeters)."]
  pub iLength: ::std::os::raw::c_int,
  #[doc = "width of the slot(in millimeters)."]
  pub iWidth: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLBracketSlotInfo"][::std::mem::size_of::<ADLBracketSlotInfo>() - 12usize];
  ["Alignment of ADLBracketSlotInfo"]
    [::std::mem::align_of::<ADLBracketSlotInfo>() - 4usize];
  ["Offset of field: ADLBracketSlotInfo::iSlotIndex"]
    [::std::mem::offset_of!(ADLBracketSlotInfo, iSlotIndex) - 0usize];
  ["Offset of field: ADLBracketSlotInfo::iLength"]
    [::std::mem::offset_of!(ADLBracketSlotInfo, iLength) - 4usize];
  ["Offset of field: ADLBracketSlotInfo::iWidth"]
    [::std::mem::offset_of!(ADLBracketSlotInfo, iWidth) - 8usize];
};
#[doc = "\n\\brief Structure containing MST branch information\n\n this structure is used to store the MST branch information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLMSTRad {
  #[doc = "depth of the link."]
  pub iLinkNumber: ::std::os::raw::c_int,
  #[doc = " Relative address, address scheme starts from source side"]
  pub rad: [::std::os::raw::c_char; 15usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLMSTRad"][::std::mem::size_of::<ADLMSTRad>() - 20usize];
  ["Alignment of ADLMSTRad"][::std::mem::align_of::<ADLMSTRad>() - 4usize];
  ["Offset of field: ADLMSTRad::iLinkNumber"]
    [::std::mem::offset_of!(ADLMSTRad, iLinkNumber) - 0usize];
  ["Offset of field: ADLMSTRad::rad"][::std::mem::offset_of!(ADLMSTRad, rad) - 4usize];
};
#[doc = "\n\\brief Structure containing port information\n\n this structure is used to get the display or MST branch information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDevicePort {
  #[doc = "index of the connector."]
  pub iConnectorIndex: ::std::os::raw::c_int,
  #[doc = "Relative MST address. If MST RAD contains 0 it means DP or Root of the MST topology. For non DP connectors MST RAD is ignored."]
  pub aMSTRad: ADLMSTRad,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDevicePort"][::std::mem::size_of::<ADLDevicePort>() - 24usize];
  ["Alignment of ADLDevicePort"][::std::mem::align_of::<ADLDevicePort>() - 4usize];
  ["Offset of field: ADLDevicePort::iConnectorIndex"]
    [::std::mem::offset_of!(ADLDevicePort, iConnectorIndex) - 0usize];
  ["Offset of field: ADLDevicePort::aMSTRad"]
    [::std::mem::offset_of!(ADLDevicePort, aMSTRad) - 4usize];
};
#[doc = "\n\\brief Structure containing supported connection types and properties\n\n this structure is used to get the supported connection types and supported properties of given connector\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLSupportedConnections {
  #[doc = "Bit vector of supported connections. Bitmask is defined in constants section. \\ref define_connection_types"]
  pub iSupportedConnections: ::std::os::raw::c_int,
  #[doc = "Array of bitvectors. Each bit vector represents supported properties for one connection type. Index of this array is connection type (bit number in mask)."]
  pub iSupportedProperties: [::std::os::raw::c_int; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLSupportedConnections"]
    [::std::mem::size_of::<ADLSupportedConnections>() - 132usize];
  ["Alignment of ADLSupportedConnections"]
    [::std::mem::align_of::<ADLSupportedConnections>() - 4usize];
  ["Offset of field: ADLSupportedConnections::iSupportedConnections"]
    [::std::mem::offset_of!(ADLSupportedConnections, iSupportedConnections) - 0usize];
  ["Offset of field: ADLSupportedConnections::iSupportedProperties"]
    [::std::mem::offset_of!(ADLSupportedConnections, iSupportedProperties) - 4usize];
};
#[doc = "\n\\brief Structure containing connection state of the connector\n\n this structure is used to get the current Emulation status and mode of the given connector\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLConnectionState {
  #[doc = "The value is bit vector. Each bit represents status. See masks constants for details. \\ref define_emulation_status"]
  pub iEmulationStatus: ::std::os::raw::c_int,
  #[doc = "It contains information about current emulation mode. See constants for details. \\ref define_emulation_mode"]
  pub iEmulationMode: ::std::os::raw::c_int,
  #[doc = "If connection is active it will contain display id, otherwise CWDDEDI_INVALID_DISPLAY_INDEX"]
  pub iDisplayIndex: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLConnectionState"][::std::mem::size_of::<ADLConnectionState>() - 12usize];
  ["Alignment of ADLConnectionState"]
    [::std::mem::align_of::<ADLConnectionState>() - 4usize];
  ["Offset of field: ADLConnectionState::iEmulationStatus"]
    [::std::mem::offset_of!(ADLConnectionState, iEmulationStatus) - 0usize];
  ["Offset of field: ADLConnectionState::iEmulationMode"]
    [::std::mem::offset_of!(ADLConnectionState, iEmulationMode) - 4usize];
  ["Offset of field: ADLConnectionState::iDisplayIndex"]
    [::std::mem::offset_of!(ADLConnectionState, iDisplayIndex) - 8usize];
};
#[doc = "\n\\brief Structure containing connection properties information\n\n this structure is used to retrieve the properties of connection type\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLConnectionProperties {
  pub iValidProperties: ::std::os::raw::c_int,
  pub iBitrate: ::std::os::raw::c_int,
  pub iNumberOfLanes: ::std::os::raw::c_int,
  pub iColorDepth: ::std::os::raw::c_int,
  pub iStereo3DCaps: ::std::os::raw::c_int,
  #[doc = "Output Bandwidth. Could be used for MST branch, DP or DP Active dongle. \\ref define_linkrate_constants"]
  pub iOutputBandwidth: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLConnectionProperties"]
    [::std::mem::size_of::<ADLConnectionProperties>() - 24usize];
  ["Alignment of ADLConnectionProperties"]
    [::std::mem::align_of::<ADLConnectionProperties>() - 4usize];
  ["Offset of field: ADLConnectionProperties::iValidProperties"]
    [::std::mem::offset_of!(ADLConnectionProperties, iValidProperties) - 0usize];
  ["Offset of field: ADLConnectionProperties::iBitrate"]
    [::std::mem::offset_of!(ADLConnectionProperties, iBitrate) - 4usize];
  ["Offset of field: ADLConnectionProperties::iNumberOfLanes"]
    [::std::mem::offset_of!(ADLConnectionProperties, iNumberOfLanes) - 8usize];
  ["Offset of field: ADLConnectionProperties::iColorDepth"]
    [::std::mem::offset_of!(ADLConnectionProperties, iColorDepth) - 12usize];
  ["Offset of field: ADLConnectionProperties::iStereo3DCaps"]
    [::std::mem::offset_of!(ADLConnectionProperties, iStereo3DCaps) - 16usize];
  ["Offset of field: ADLConnectionProperties::iOutputBandwidth"]
    [::std::mem::offset_of!(ADLConnectionProperties, iOutputBandwidth) - 20usize];
};
#[doc = "\n\\brief Structure containing connection information\n\n this structure is used to retrieve the data from driver which includes\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLConnectionData {
  #[doc = "Connection type. based on the connection type either iNumberofPorts or IDataSize,EDIDdata is valid, \\ref define_connection_types"]
  pub iConnectionType: ::std::os::raw::c_int,
  #[doc = "Specifies the connection properties."]
  pub aConnectionProperties: ADLConnectionProperties,
  #[doc = "Number of ports"]
  pub iNumberofPorts: ::std::os::raw::c_int,
  #[doc = "Number of Active Connections"]
  pub iActiveConnections: ::std::os::raw::c_int,
  #[doc = "actual size of EDID data block size."]
  pub iDataSize: ::std::os::raw::c_int,
  #[doc = "EDID Data"]
  pub EdidData: [::std::os::raw::c_char; 1024usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLConnectionData"][::std::mem::size_of::<ADLConnectionData>() - 1064usize];
  ["Alignment of ADLConnectionData"]
    [::std::mem::align_of::<ADLConnectionData>() - 4usize];
  ["Offset of field: ADLConnectionData::iConnectionType"]
    [::std::mem::offset_of!(ADLConnectionData, iConnectionType) - 0usize];
  ["Offset of field: ADLConnectionData::aConnectionProperties"]
    [::std::mem::offset_of!(ADLConnectionData, aConnectionProperties) - 4usize];
  ["Offset of field: ADLConnectionData::iNumberofPorts"]
    [::std::mem::offset_of!(ADLConnectionData, iNumberofPorts) - 28usize];
  ["Offset of field: ADLConnectionData::iActiveConnections"]
    [::std::mem::offset_of!(ADLConnectionData, iActiveConnections) - 32usize];
  ["Offset of field: ADLConnectionData::iDataSize"]
    [::std::mem::offset_of!(ADLConnectionData, iDataSize) - 36usize];
  ["Offset of field: ADLConnectionData::EdidData"]
    [::std::mem::offset_of!(ADLConnectionData, EdidData) - 40usize];
};
#[doc = "\n\\brief Structure containing information about an controller mode including Number of Connectors\n\n This structure is used to store information of an controller mode\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLAdapterCapsX2 {
  #[doc = " AdapterID for this adapter"]
  pub iAdapterID: ::std::os::raw::c_int,
  #[doc = " Number of controllers for this adapter"]
  pub iNumControllers: ::std::os::raw::c_int,
  #[doc = " Number of displays for this adapter"]
  pub iNumDisplays: ::std::os::raw::c_int,
  #[doc = " Number of overlays for this adapter"]
  pub iNumOverlays: ::std::os::raw::c_int,
  #[doc = " Number of GLSyncConnectors"]
  pub iNumOfGLSyncConnectors: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the adapter caps"]
  pub iCapsMask: ::std::os::raw::c_int,
  #[doc = " The bit identifies the adapter caps \\ref define_adapter_caps"]
  pub iCapsValue: ::std::os::raw::c_int,
  #[doc = " Number of Connectors for this adapter"]
  pub iNumConnectors: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLAdapterCapsX2"][::std::mem::size_of::<ADLAdapterCapsX2>() - 32usize];
  ["Alignment of ADLAdapterCapsX2"][::std::mem::align_of::<ADLAdapterCapsX2>() - 4usize];
  ["Offset of field: ADLAdapterCapsX2::iAdapterID"]
    [::std::mem::offset_of!(ADLAdapterCapsX2, iAdapterID) - 0usize];
  ["Offset of field: ADLAdapterCapsX2::iNumControllers"]
    [::std::mem::offset_of!(ADLAdapterCapsX2, iNumControllers) - 4usize];
  ["Offset of field: ADLAdapterCapsX2::iNumDisplays"]
    [::std::mem::offset_of!(ADLAdapterCapsX2, iNumDisplays) - 8usize];
  ["Offset of field: ADLAdapterCapsX2::iNumOverlays"]
    [::std::mem::offset_of!(ADLAdapterCapsX2, iNumOverlays) - 12usize];
  ["Offset of field: ADLAdapterCapsX2::iNumOfGLSyncConnectors"]
    [::std::mem::offset_of!(ADLAdapterCapsX2, iNumOfGLSyncConnectors) - 16usize];
  ["Offset of field: ADLAdapterCapsX2::iCapsMask"]
    [::std::mem::offset_of!(ADLAdapterCapsX2, iCapsMask) - 20usize];
  ["Offset of field: ADLAdapterCapsX2::iCapsValue"]
    [::std::mem::offset_of!(ADLAdapterCapsX2, iCapsValue) - 24usize];
  ["Offset of field: ADLAdapterCapsX2::iNumConnectors"]
    [::std::mem::offset_of!(ADLAdapterCapsX2, iNumConnectors) - 28usize];
};
pub const ADL_ERROR_RECORD_SEVERITY_ADL_GLOBALLY_UNCORRECTED: ADL_ERROR_RECORD_SEVERITY =
  1;
pub const ADL_ERROR_RECORD_SEVERITY_ADL_LOCALLY_UNCORRECTED: ADL_ERROR_RECORD_SEVERITY =
  2;
pub const ADL_ERROR_RECORD_SEVERITY_ADL_DEFFERRED: ADL_ERROR_RECORD_SEVERITY = 3;
pub const ADL_ERROR_RECORD_SEVERITY_ADL_CORRECTED: ADL_ERROR_RECORD_SEVERITY = 4;
pub type ADL_ERROR_RECORD_SEVERITY = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ADL_ECC_EDC_FLAG {
  pub bits: _ADL_ECC_EDC_FLAG__bindgen_ty_1,
  pub u32All: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ADL_ECC_EDC_FLAG__bindgen_ty_1 {
  pub _bitfield_align_1: [u32; 0],
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _ADL_ECC_EDC_FLAG__bindgen_ty_1"]
    [::std::mem::size_of::<_ADL_ECC_EDC_FLAG__bindgen_ty_1>() - 4usize];
  ["Alignment of _ADL_ECC_EDC_FLAG__bindgen_ty_1"]
    [::std::mem::align_of::<_ADL_ECC_EDC_FLAG__bindgen_ty_1>() - 4usize];
};
impl _ADL_ECC_EDC_FLAG__bindgen_ty_1 {
  #[inline]
  pub fn isEccAccessing(&self) -> ::std::os::raw::c_uint {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_isEccAccessing(&mut self, val: ::std::os::raw::c_uint) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub unsafe fn isEccAccessing_raw(this: *const Self) -> ::std::os::raw::c_uint {
    unsafe {
      ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
        ::std::ptr::addr_of!((*this)._bitfield_1),
        0usize,
        1u8,
      ) as u32)
    }
  }
  #[inline]
  pub unsafe fn set_isEccAccessing_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
        0usize,
        1u8,
        val as u64,
      )
    }
  }
  #[inline]
  pub fn reserved(&self) -> ::std::os::raw::c_uint {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
  }
  #[inline]
  pub fn set_reserved(&mut self, val: ::std::os::raw::c_uint) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 31u8, val as u64)
    }
  }
  #[inline]
  pub unsafe fn reserved_raw(this: *const Self) -> ::std::os::raw::c_uint {
    unsafe {
      ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
        ::std::ptr::addr_of!((*this)._bitfield_1),
        1usize,
        31u8,
      ) as u32)
    }
  }
  #[inline]
  pub unsafe fn set_reserved_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
        1usize,
        31u8,
        val as u64,
      )
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    isEccAccessing: ::std::os::raw::c_uint,
    reserved: ::std::os::raw::c_uint,
  ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
      Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let isEccAccessing: u32 = unsafe { ::std::mem::transmute(isEccAccessing) };
      isEccAccessing as u64
    });
    __bindgen_bitfield_unit.set(1usize, 31u8, {
      let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
      reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _ADL_ECC_EDC_FLAG"][::std::mem::size_of::<_ADL_ECC_EDC_FLAG>() - 4usize];
  ["Alignment of _ADL_ECC_EDC_FLAG"]
    [::std::mem::align_of::<_ADL_ECC_EDC_FLAG>() - 4usize];
  ["Offset of field: _ADL_ECC_EDC_FLAG::bits"]
    [::std::mem::offset_of!(_ADL_ECC_EDC_FLAG, bits) - 0usize];
  ["Offset of field: _ADL_ECC_EDC_FLAG::u32All"]
    [::std::mem::offset_of!(_ADL_ECC_EDC_FLAG, u32All) - 0usize];
};
pub type ADL_ECC_EDC_FLAG = _ADL_ECC_EDC_FLAG;
#[doc = "\n\\brief Structure containing information about EDC Error Record\n\n This structure is used to store EDC Error Record\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLErrorRecord {
  pub Severity: ADL_ERROR_RECORD_SEVERITY,
  pub countValid: ::std::os::raw::c_int,
  pub count: ::std::os::raw::c_uint,
  pub locationValid: ::std::os::raw::c_int,
  pub CU: ::std::os::raw::c_uint,
  pub StructureName: [::std::os::raw::c_char; 32usize],
  pub tiestamp: [::std::os::raw::c_char; 32usize],
  pub padding: [::std::os::raw::c_uint; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLErrorRecord"][::std::mem::size_of::<ADLErrorRecord>() - 96usize];
  ["Alignment of ADLErrorRecord"][::std::mem::align_of::<ADLErrorRecord>() - 4usize];
  ["Offset of field: ADLErrorRecord::Severity"]
    [::std::mem::offset_of!(ADLErrorRecord, Severity) - 0usize];
  ["Offset of field: ADLErrorRecord::countValid"]
    [::std::mem::offset_of!(ADLErrorRecord, countValid) - 4usize];
  ["Offset of field: ADLErrorRecord::count"]
    [::std::mem::offset_of!(ADLErrorRecord, count) - 8usize];
  ["Offset of field: ADLErrorRecord::locationValid"]
    [::std::mem::offset_of!(ADLErrorRecord, locationValid) - 12usize];
  ["Offset of field: ADLErrorRecord::CU"]
    [::std::mem::offset_of!(ADLErrorRecord, CU) - 16usize];
  ["Offset of field: ADLErrorRecord::StructureName"]
    [::std::mem::offset_of!(ADLErrorRecord, StructureName) - 20usize];
  ["Offset of field: ADLErrorRecord::tiestamp"]
    [::std::mem::offset_of!(ADLErrorRecord, tiestamp) - 52usize];
  ["Offset of field: ADLErrorRecord::padding"]
    [::std::mem::offset_of!(ADLErrorRecord, padding) - 84usize];
};
pub const ADL_EDC_BLOCK_ID_ADL_EDC_BLOCK_ID_SQCIS: ADL_EDC_BLOCK_ID = 1;
pub const ADL_EDC_BLOCK_ID_ADL_EDC_BLOCK_ID_SQCDS: ADL_EDC_BLOCK_ID = 2;
pub const ADL_EDC_BLOCK_ID_ADL_EDC_BLOCK_ID_SGPR: ADL_EDC_BLOCK_ID = 3;
pub const ADL_EDC_BLOCK_ID_ADL_EDC_BLOCK_ID_VGPR: ADL_EDC_BLOCK_ID = 4;
pub const ADL_EDC_BLOCK_ID_ADL_EDC_BLOCK_ID_LDS: ADL_EDC_BLOCK_ID = 5;
pub const ADL_EDC_BLOCK_ID_ADL_EDC_BLOCK_ID_GDS: ADL_EDC_BLOCK_ID = 6;
pub const ADL_EDC_BLOCK_ID_ADL_EDC_BLOCK_ID_TCL1: ADL_EDC_BLOCK_ID = 7;
pub const ADL_EDC_BLOCK_ID_ADL_EDC_BLOCK_ID_TCL2: ADL_EDC_BLOCK_ID = 8;
pub type ADL_EDC_BLOCK_ID = ::std::os::raw::c_int;
pub const ADL_ERROR_INJECTION_MODE_ADL_ERROR_INJECTION_MODE_SINGLE:
  ADL_ERROR_INJECTION_MODE = 1;
pub const ADL_ERROR_INJECTION_MODE_ADL_ERROR_INJECTION_MODE_MULTIPLE:
  ADL_ERROR_INJECTION_MODE = 2;
pub const ADL_ERROR_INJECTION_MODE_ADL_ERROR_INJECTION_MODE_ADDRESS:
  ADL_ERROR_INJECTION_MODE = 3;
pub type ADL_ERROR_INJECTION_MODE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ADL_ERROR_PATTERN {
  pub bits: _ADL_ERROR_PATTERN__bindgen_ty_1,
  pub u64Value: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ADL_ERROR_PATTERN__bindgen_ty_1 {
  pub _bitfield_align_1: [u32; 0],
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 12usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _ADL_ERROR_PATTERN__bindgen_ty_1"]
    [::std::mem::size_of::<_ADL_ERROR_PATTERN__bindgen_ty_1>() - 12usize];
  ["Alignment of _ADL_ERROR_PATTERN__bindgen_ty_1"]
    [::std::mem::align_of::<_ADL_ERROR_PATTERN__bindgen_ty_1>() - 4usize];
};
impl _ADL_ERROR_PATTERN__bindgen_ty_1 {
  #[inline]
  pub fn EccInjVector(&self) -> ::std::os::raw::c_ulong {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
  }
  #[inline]
  pub fn set_EccInjVector(&mut self, val: ::std::os::raw::c_ulong) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 16u8, val as u64)
    }
  }
  #[inline]
  pub unsafe fn EccInjVector_raw(this: *const Self) -> ::std::os::raw::c_ulong {
    unsafe {
      ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
        ::std::ptr::addr_of!((*this)._bitfield_1),
        0usize,
        16u8,
      ) as u32)
    }
  }
  #[inline]
  pub unsafe fn set_EccInjVector_raw(this: *mut Self, val: ::std::os::raw::c_ulong) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
        0usize,
        16u8,
        val as u64,
      )
    }
  }
  #[inline]
  pub fn EccInjEn(&self) -> ::std::os::raw::c_ulong {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 9u8) as u32) }
  }
  #[inline]
  pub fn set_EccInjEn(&mut self, val: ::std::os::raw::c_ulong) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(16usize, 9u8, val as u64)
    }
  }
  #[inline]
  pub unsafe fn EccInjEn_raw(this: *const Self) -> ::std::os::raw::c_ulong {
    unsafe {
      ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
        ::std::ptr::addr_of!((*this)._bitfield_1),
        16usize,
        9u8,
      ) as u32)
    }
  }
  #[inline]
  pub unsafe fn set_EccInjEn_raw(this: *mut Self, val: ::std::os::raw::c_ulong) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
        16usize,
        9u8,
        val as u64,
      )
    }
  }
  #[inline]
  pub fn EccBeatEn(&self) -> ::std::os::raw::c_ulong {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 4u8) as u32) }
  }
  #[inline]
  pub fn set_EccBeatEn(&mut self, val: ::std::os::raw::c_ulong) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(25usize, 4u8, val as u64)
    }
  }
  #[inline]
  pub unsafe fn EccBeatEn_raw(this: *const Self) -> ::std::os::raw::c_ulong {
    unsafe {
      ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
        ::std::ptr::addr_of!((*this)._bitfield_1),
        25usize,
        4u8,
      ) as u32)
    }
  }
  #[inline]
  pub unsafe fn set_EccBeatEn_raw(this: *mut Self, val: ::std::os::raw::c_ulong) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
        25usize,
        4u8,
        val as u64,
      )
    }
  }
  #[inline]
  pub fn EccChEn(&self) -> ::std::os::raw::c_ulong {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 4u8) as u32) }
  }
  #[inline]
  pub fn set_EccChEn(&mut self, val: ::std::os::raw::c_ulong) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(32usize, 4u8, val as u64)
    }
  }
  #[inline]
  pub unsafe fn EccChEn_raw(this: *const Self) -> ::std::os::raw::c_ulong {
    unsafe {
      ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
        ::std::ptr::addr_of!((*this)._bitfield_1),
        32usize,
        4u8,
      ) as u32)
    }
  }
  #[inline]
  pub unsafe fn set_EccChEn_raw(this: *mut Self, val: ::std::os::raw::c_ulong) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
        32usize,
        4u8,
        val as u64,
      )
    }
  }
  #[inline]
  pub fn reserved(&self) -> ::std::os::raw::c_ulong {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 31u8) as u32) }
  }
  #[inline]
  pub fn set_reserved(&mut self, val: ::std::os::raw::c_ulong) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(64usize, 31u8, val as u64)
    }
  }
  #[inline]
  pub unsafe fn reserved_raw(this: *const Self) -> ::std::os::raw::c_ulong {
    unsafe {
      ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 12usize]>>::raw_get(
        ::std::ptr::addr_of!((*this)._bitfield_1),
        64usize,
        31u8,
      ) as u32)
    }
  }
  #[inline]
  pub unsafe fn set_reserved_raw(this: *mut Self, val: ::std::os::raw::c_ulong) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      <__BindgenBitfieldUnit<[u8; 12usize]>>::raw_set(
        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
        64usize,
        31u8,
        val as u64,
      )
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    EccInjVector: ::std::os::raw::c_ulong,
    EccInjEn: ::std::os::raw::c_ulong,
    EccBeatEn: ::std::os::raw::c_ulong,
    EccChEn: ::std::os::raw::c_ulong,
    reserved: ::std::os::raw::c_ulong,
  ) -> __BindgenBitfieldUnit<[u8; 12usize]> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 12usize]> =
      Default::default();
    __bindgen_bitfield_unit.set(0usize, 16u8, {
      let EccInjVector: u32 = unsafe { ::std::mem::transmute(EccInjVector) };
      EccInjVector as u64
    });
    __bindgen_bitfield_unit.set(16usize, 9u8, {
      let EccInjEn: u32 = unsafe { ::std::mem::transmute(EccInjEn) };
      EccInjEn as u64
    });
    __bindgen_bitfield_unit.set(25usize, 4u8, {
      let EccBeatEn: u32 = unsafe { ::std::mem::transmute(EccBeatEn) };
      EccBeatEn as u64
    });
    __bindgen_bitfield_unit.set(32usize, 4u8, {
      let EccChEn: u32 = unsafe { ::std::mem::transmute(EccChEn) };
      EccChEn as u64
    });
    __bindgen_bitfield_unit.set(64usize, 31u8, {
      let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
      reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _ADL_ERROR_PATTERN"][::std::mem::size_of::<_ADL_ERROR_PATTERN>() - 16usize];
  ["Alignment of _ADL_ERROR_PATTERN"]
    [::std::mem::align_of::<_ADL_ERROR_PATTERN>() - 8usize];
  ["Offset of field: _ADL_ERROR_PATTERN::bits"]
    [::std::mem::offset_of!(_ADL_ERROR_PATTERN, bits) - 0usize];
  ["Offset of field: _ADL_ERROR_PATTERN::u64Value"]
    [::std::mem::offset_of!(_ADL_ERROR_PATTERN, u64Value) - 0usize];
};
pub type ADL_ERROR_PATTERN = _ADL_ERROR_PATTERN;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_ERROR_INJECTION_DATA {
  pub errorAddress: ::std::os::raw::c_ulonglong,
  pub errorPattern: ADL_ERROR_PATTERN,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_ERROR_INJECTION_DATA"]
    [::std::mem::size_of::<ADL_ERROR_INJECTION_DATA>() - 24usize];
  ["Alignment of ADL_ERROR_INJECTION_DATA"]
    [::std::mem::align_of::<ADL_ERROR_INJECTION_DATA>() - 8usize];
  ["Offset of field: ADL_ERROR_INJECTION_DATA::errorAddress"]
    [::std::mem::offset_of!(ADL_ERROR_INJECTION_DATA, errorAddress) - 0usize];
  ["Offset of field: ADL_ERROR_INJECTION_DATA::errorPattern"]
    [::std::mem::offset_of!(ADL_ERROR_INJECTION_DATA, errorPattern) - 8usize];
};
#[doc = "\n\\brief Structure containing information about EDC Error Injection\n\n This structure is used to store EDC Error Injection\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLErrorInjection {
  pub blockId: ADL_EDC_BLOCK_ID,
  pub errorInjectionMode: ADL_ERROR_INJECTION_MODE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLErrorInjection"][::std::mem::size_of::<ADLErrorInjection>() - 8usize];
  ["Alignment of ADLErrorInjection"]
    [::std::mem::align_of::<ADLErrorInjection>() - 4usize];
  ["Offset of field: ADLErrorInjection::blockId"]
    [::std::mem::offset_of!(ADLErrorInjection, blockId) - 0usize];
  ["Offset of field: ADLErrorInjection::errorInjectionMode"]
    [::std::mem::offset_of!(ADLErrorInjection, errorInjectionMode) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLErrorInjectionX2 {
  pub blockId: ADL_EDC_BLOCK_ID,
  pub errorInjectionMode: ADL_ERROR_INJECTION_MODE,
  pub errorInjectionData: ADL_ERROR_INJECTION_DATA,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLErrorInjectionX2"][::std::mem::size_of::<ADLErrorInjectionX2>() - 32usize];
  ["Alignment of ADLErrorInjectionX2"]
    [::std::mem::align_of::<ADLErrorInjectionX2>() - 8usize];
  ["Offset of field: ADLErrorInjectionX2::blockId"]
    [::std::mem::offset_of!(ADLErrorInjectionX2, blockId) - 0usize];
  ["Offset of field: ADLErrorInjectionX2::errorInjectionMode"]
    [::std::mem::offset_of!(ADLErrorInjectionX2, errorInjectionMode) - 4usize];
  ["Offset of field: ADLErrorInjectionX2::errorInjectionData"]
    [::std::mem::offset_of!(ADLErrorInjectionX2, errorInjectionData) - 8usize];
};
#[doc = "\n\\brief Structure containing per display FreeSync capability information.\n\n This structure is used to store the FreeSync capability of both the display and\n the GPU the display is connected to.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLFreeSyncCap {
  #[doc = " FreeSync capability flags. \\ref define_freesync_caps"]
  pub iCaps: ::std::os::raw::c_int,
  #[doc = " Reports minimum FreeSync refresh rate supported by the display in micro hertz"]
  pub iMinRefreshRateInMicroHz: ::std::os::raw::c_int,
  #[doc = " Reports maximum FreeSync refresh rate supported by the display in micro hertz"]
  pub iMaxRefreshRateInMicroHz: ::std::os::raw::c_int,
  #[doc = " Index of FreeSync Label to use:  ADL_FREESYNC_LABEL_*"]
  pub ucLabelIndex: ::std::os::raw::c_uchar,
  #[doc = " Reserved"]
  pub cReserved: [::std::os::raw::c_char; 3usize],
  pub iReserved: [::std::os::raw::c_int; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLFreeSyncCap"][::std::mem::size_of::<ADLFreeSyncCap>() - 32usize];
  ["Alignment of ADLFreeSyncCap"][::std::mem::align_of::<ADLFreeSyncCap>() - 4usize];
  ["Offset of field: ADLFreeSyncCap::iCaps"]
    [::std::mem::offset_of!(ADLFreeSyncCap, iCaps) - 0usize];
  ["Offset of field: ADLFreeSyncCap::iMinRefreshRateInMicroHz"]
    [::std::mem::offset_of!(ADLFreeSyncCap, iMinRefreshRateInMicroHz) - 4usize];
  ["Offset of field: ADLFreeSyncCap::iMaxRefreshRateInMicroHz"]
    [::std::mem::offset_of!(ADLFreeSyncCap, iMaxRefreshRateInMicroHz) - 8usize];
  ["Offset of field: ADLFreeSyncCap::ucLabelIndex"]
    [::std::mem::offset_of!(ADLFreeSyncCap, ucLabelIndex) - 12usize];
  ["Offset of field: ADLFreeSyncCap::cReserved"]
    [::std::mem::offset_of!(ADLFreeSyncCap, cReserved) - 13usize];
  ["Offset of field: ADLFreeSyncCap::iReserved"]
    [::std::mem::offset_of!(ADLFreeSyncCap, iReserved) - 16usize];
};
#[doc = "\n\\brief Structure containing per display Display Connectivty Experience Settings\n\n This structure is used to store the Display Connectivity Experience settings of a\n display\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLDceSettings {
  pub type_: DceSettingsType,
  pub Settings: ADLDceSettings__bindgen_ty_1,
  pub iReserved: [::std::os::raw::c_int; 15usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADLDceSettings__bindgen_ty_1 {
  pub HdmiLq: ADLDceSettings__bindgen_ty_1__bindgen_ty_1,
  pub DpLink: ADLDceSettings__bindgen_ty_1__bindgen_ty_2,
  pub Protection: ADLDceSettings__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDceSettings__bindgen_ty_1__bindgen_ty_1 {
  pub qualityDetectionEnabled: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDceSettings__bindgen_ty_1__bindgen_ty_1"]
    [::std::mem::size_of::<ADLDceSettings__bindgen_ty_1__bindgen_ty_1>() - 4usize];
  ["Alignment of ADLDceSettings__bindgen_ty_1__bindgen_ty_1"]
    [::std::mem::align_of::<ADLDceSettings__bindgen_ty_1__bindgen_ty_1>() - 4usize];
  ["Offset of field: ADLDceSettings__bindgen_ty_1__bindgen_ty_1::qualityDetectionEnabled"] [:: std :: mem :: offset_of ! (ADLDceSettings__bindgen_ty_1__bindgen_ty_1 , qualityDetectionEnabled) - 0usize] ;
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDceSettings__bindgen_ty_1__bindgen_ty_2 {
  pub linkRate: DpLinkRate,
  pub numberOfActiveLanes: ::std::os::raw::c_uint,
  pub numberofTotalLanes: ::std::os::raw::c_uint,
  pub relativePreEmphasis: ::std::os::raw::c_int,
  pub relativeVoltageSwing: ::std::os::raw::c_int,
  pub persistFlag: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDceSettings__bindgen_ty_1__bindgen_ty_2"]
    [::std::mem::size_of::<ADLDceSettings__bindgen_ty_1__bindgen_ty_2>() - 24usize];
  ["Alignment of ADLDceSettings__bindgen_ty_1__bindgen_ty_2"]
    [::std::mem::align_of::<ADLDceSettings__bindgen_ty_1__bindgen_ty_2>() - 4usize];
  ["Offset of field: ADLDceSettings__bindgen_ty_1__bindgen_ty_2::linkRate"][::std::mem::offset_of!(
    ADLDceSettings__bindgen_ty_1__bindgen_ty_2,
    linkRate
  ) - 0usize];
  ["Offset of field: ADLDceSettings__bindgen_ty_1__bindgen_ty_2::numberOfActiveLanes"][::std::mem::offset_of!(
    ADLDceSettings__bindgen_ty_1__bindgen_ty_2,
    numberOfActiveLanes
  )
    - 4usize];
  ["Offset of field: ADLDceSettings__bindgen_ty_1__bindgen_ty_2::numberofTotalLanes"][::std::mem::offset_of!(
    ADLDceSettings__bindgen_ty_1__bindgen_ty_2,
    numberofTotalLanes
  )
    - 8usize];
  ["Offset of field: ADLDceSettings__bindgen_ty_1__bindgen_ty_2::relativePreEmphasis"][::std::mem::offset_of!(
    ADLDceSettings__bindgen_ty_1__bindgen_ty_2,
    relativePreEmphasis
  )
    - 12usize];
  ["Offset of field: ADLDceSettings__bindgen_ty_1__bindgen_ty_2::relativeVoltageSwing"][::std::mem::offset_of!(
    ADLDceSettings__bindgen_ty_1__bindgen_ty_2,
    relativeVoltageSwing
  )
    - 16usize];
  ["Offset of field: ADLDceSettings__bindgen_ty_1__bindgen_ty_2::persistFlag"][::std::mem::offset_of!(
    ADLDceSettings__bindgen_ty_1__bindgen_ty_2,
    persistFlag
  )
    - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDceSettings__bindgen_ty_1__bindgen_ty_3 {
  pub linkProtectionEnabled: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDceSettings__bindgen_ty_1__bindgen_ty_3"]
    [::std::mem::size_of::<ADLDceSettings__bindgen_ty_1__bindgen_ty_3>() - 4usize];
  ["Alignment of ADLDceSettings__bindgen_ty_1__bindgen_ty_3"]
    [::std::mem::align_of::<ADLDceSettings__bindgen_ty_1__bindgen_ty_3>() - 4usize];
  ["Offset of field: ADLDceSettings__bindgen_ty_1__bindgen_ty_3::linkProtectionEnabled"]
    [::std::mem::offset_of!(
      ADLDceSettings__bindgen_ty_1__bindgen_ty_3,
      linkProtectionEnabled
    ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDceSettings__bindgen_ty_1"]
    [::std::mem::size_of::<ADLDceSettings__bindgen_ty_1>() - 24usize];
  ["Alignment of ADLDceSettings__bindgen_ty_1"]
    [::std::mem::align_of::<ADLDceSettings__bindgen_ty_1>() - 4usize];
  ["Offset of field: ADLDceSettings__bindgen_ty_1::HdmiLq"]
    [::std::mem::offset_of!(ADLDceSettings__bindgen_ty_1, HdmiLq) - 0usize];
  ["Offset of field: ADLDceSettings__bindgen_ty_1::DpLink"]
    [::std::mem::offset_of!(ADLDceSettings__bindgen_ty_1, DpLink) - 0usize];
  ["Offset of field: ADLDceSettings__bindgen_ty_1::Protection"]
    [::std::mem::offset_of!(ADLDceSettings__bindgen_ty_1, Protection) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDceSettings"][::std::mem::size_of::<ADLDceSettings>() - 88usize];
  ["Alignment of ADLDceSettings"][::std::mem::align_of::<ADLDceSettings>() - 4usize];
  ["Offset of field: ADLDceSettings::type_"]
    [::std::mem::offset_of!(ADLDceSettings, type_) - 0usize];
  ["Offset of field: ADLDceSettings::Settings"]
    [::std::mem::offset_of!(ADLDceSettings, Settings) - 4usize];
  ["Offset of field: ADLDceSettings::iReserved"]
    [::std::mem::offset_of!(ADLDceSettings, iReserved) - 28usize];
};
#[doc = "\n\\brief Structure containing information about Graphic Core\n\n This structure is used to get Graphic Core Info\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLGraphicCoreInfo {
  #[doc = " indicate the graphic core generation"]
  pub iGCGen: ::std::os::raw::c_int,
  pub __bindgen_anon_1: ADLGraphicCoreInfo__bindgen_ty_1,
  pub __bindgen_anon_2: ADLGraphicCoreInfo__bindgen_ty_2,
  #[doc = " Total number of SIMDs. Valid for Pre GCN (iGCGen == Pre-GCN)"]
  pub iNumSIMDs: ::std::os::raw::c_int,
  #[doc = " Total number of ROPs. Valid for both GCN and Pre GCN"]
  pub iNumROPs: ::std::os::raw::c_int,
  #[doc = " reserved for future use"]
  pub iReserved: [::std::os::raw::c_int; 11usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADLGraphicCoreInfo__bindgen_ty_1 {
  #[doc = " Total number of CUs. Valid for GCN (iGCGen == GCN)"]
  pub iNumCUs: ::std::os::raw::c_int,
  #[doc = " Total number of WGPs. Valid for RDNA (iGCGen == RDNA)"]
  pub iNumWGPs: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLGraphicCoreInfo__bindgen_ty_1"]
    [::std::mem::size_of::<ADLGraphicCoreInfo__bindgen_ty_1>() - 4usize];
  ["Alignment of ADLGraphicCoreInfo__bindgen_ty_1"]
    [::std::mem::align_of::<ADLGraphicCoreInfo__bindgen_ty_1>() - 4usize];
  ["Offset of field: ADLGraphicCoreInfo__bindgen_ty_1::iNumCUs"]
    [::std::mem::offset_of!(ADLGraphicCoreInfo__bindgen_ty_1, iNumCUs) - 0usize];
  ["Offset of field: ADLGraphicCoreInfo__bindgen_ty_1::iNumWGPs"]
    [::std::mem::offset_of!(ADLGraphicCoreInfo__bindgen_ty_1, iNumWGPs) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADLGraphicCoreInfo__bindgen_ty_2 {
  #[doc = " Number of processing elements per CU. Valid for GCN (iGCGen == GCN)"]
  pub iNumPEsPerCU: ::std::os::raw::c_int,
  #[doc = " Number of processing elements per WGP. Valid for RDNA (iGCGen == RDNA)"]
  pub iNumPEsPerWGP: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLGraphicCoreInfo__bindgen_ty_2"]
    [::std::mem::size_of::<ADLGraphicCoreInfo__bindgen_ty_2>() - 4usize];
  ["Alignment of ADLGraphicCoreInfo__bindgen_ty_2"]
    [::std::mem::align_of::<ADLGraphicCoreInfo__bindgen_ty_2>() - 4usize];
  ["Offset of field: ADLGraphicCoreInfo__bindgen_ty_2::iNumPEsPerCU"]
    [::std::mem::offset_of!(ADLGraphicCoreInfo__bindgen_ty_2, iNumPEsPerCU) - 0usize];
  ["Offset of field: ADLGraphicCoreInfo__bindgen_ty_2::iNumPEsPerWGP"]
    [::std::mem::offset_of!(ADLGraphicCoreInfo__bindgen_ty_2, iNumPEsPerWGP) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLGraphicCoreInfo"][::std::mem::size_of::<ADLGraphicCoreInfo>() - 64usize];
  ["Alignment of ADLGraphicCoreInfo"]
    [::std::mem::align_of::<ADLGraphicCoreInfo>() - 4usize];
  ["Offset of field: ADLGraphicCoreInfo::iGCGen"]
    [::std::mem::offset_of!(ADLGraphicCoreInfo, iGCGen) - 0usize];
  ["Offset of field: ADLGraphicCoreInfo::iNumSIMDs"]
    [::std::mem::offset_of!(ADLGraphicCoreInfo, iNumSIMDs) - 12usize];
  ["Offset of field: ADLGraphicCoreInfo::iNumROPs"]
    [::std::mem::offset_of!(ADLGraphicCoreInfo, iNumROPs) - 16usize];
  ["Offset of field: ADLGraphicCoreInfo::iReserved"]
    [::std::mem::offset_of!(ADLGraphicCoreInfo, iReserved) - 20usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive N clock range\n\n This structure is used to store information about Overdrive N clock range\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLODNParameterRange {
  #[doc = " The starting value of the clock range"]
  pub iMode: ::std::os::raw::c_int,
  #[doc = " The starting value of the clock range"]
  pub iMin: ::std::os::raw::c_int,
  #[doc = " The ending value of the clock range"]
  pub iMax: ::std::os::raw::c_int,
  #[doc = " The minimum increment between clock values"]
  pub iStep: ::std::os::raw::c_int,
  #[doc = " The default clock values"]
  pub iDefault: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLODNParameterRange"]
    [::std::mem::size_of::<ADLODNParameterRange>() - 20usize];
  ["Alignment of ADLODNParameterRange"]
    [::std::mem::align_of::<ADLODNParameterRange>() - 4usize];
  ["Offset of field: ADLODNParameterRange::iMode"]
    [::std::mem::offset_of!(ADLODNParameterRange, iMode) - 0usize];
  ["Offset of field: ADLODNParameterRange::iMin"]
    [::std::mem::offset_of!(ADLODNParameterRange, iMin) - 4usize];
  ["Offset of field: ADLODNParameterRange::iMax"]
    [::std::mem::offset_of!(ADLODNParameterRange, iMax) - 8usize];
  ["Offset of field: ADLODNParameterRange::iStep"]
    [::std::mem::offset_of!(ADLODNParameterRange, iStep) - 12usize];
  ["Offset of field: ADLODNParameterRange::iDefault"]
    [::std::mem::offset_of!(ADLODNParameterRange, iDefault) - 16usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive N capabilities\n\n This structure is used to store information about Overdrive N capabilities\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLODNCapabilities {
  #[doc = " Number of levels which describe the minimum to maximum clock ranges.\n The 1st level indicates the minimum clocks, and the 2nd level\n indicates the maximum clocks."]
  pub iMaximumNumberOfPerformanceLevels: ::std::os::raw::c_int,
  #[doc = " Contains the hard limits of the sclk range.  Overdrive\n clocks cannot be set outside this range."]
  pub sEngineClockRange: ADLODNParameterRange,
  #[doc = " Contains the hard limits of the mclk range.  Overdrive\n clocks cannot be set outside this range."]
  pub sMemoryClockRange: ADLODNParameterRange,
  #[doc = " Contains the hard limits of the vddc range.  Overdrive\n clocks cannot be set outside this range."]
  pub svddcRange: ADLODNParameterRange,
  #[doc = " Contains the hard limits of the power range.  Overdrive\n clocks cannot be set outside this range."]
  pub power: ADLODNParameterRange,
  #[doc = " Contains the hard limits of the power range.  Overdrive\n clocks cannot be set outside this range."]
  pub powerTuneTemperature: ADLODNParameterRange,
  #[doc = " Contains the hard limits of the Temperature range.  Overdrive\n clocks cannot be set outside this range."]
  pub fanTemperature: ADLODNParameterRange,
  #[doc = " Contains the hard limits of the Fan range.  Overdrive\n clocks cannot be set outside this range."]
  pub fanSpeed: ADLODNParameterRange,
  #[doc = " Contains the hard limits of the Fan range.  Overdrive\n clocks cannot be set outside this range."]
  pub minimumPerformanceClock: ADLODNParameterRange,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLODNCapabilities"][::std::mem::size_of::<ADLODNCapabilities>() - 164usize];
  ["Alignment of ADLODNCapabilities"]
    [::std::mem::align_of::<ADLODNCapabilities>() - 4usize];
  ["Offset of field: ADLODNCapabilities::iMaximumNumberOfPerformanceLevels"][::std::mem::offset_of!(
    ADLODNCapabilities,
    iMaximumNumberOfPerformanceLevels
  ) - 0usize];
  ["Offset of field: ADLODNCapabilities::sEngineClockRange"]
    [::std::mem::offset_of!(ADLODNCapabilities, sEngineClockRange) - 4usize];
  ["Offset of field: ADLODNCapabilities::sMemoryClockRange"]
    [::std::mem::offset_of!(ADLODNCapabilities, sMemoryClockRange) - 24usize];
  ["Offset of field: ADLODNCapabilities::svddcRange"]
    [::std::mem::offset_of!(ADLODNCapabilities, svddcRange) - 44usize];
  ["Offset of field: ADLODNCapabilities::power"]
    [::std::mem::offset_of!(ADLODNCapabilities, power) - 64usize];
  ["Offset of field: ADLODNCapabilities::powerTuneTemperature"]
    [::std::mem::offset_of!(ADLODNCapabilities, powerTuneTemperature) - 84usize];
  ["Offset of field: ADLODNCapabilities::fanTemperature"]
    [::std::mem::offset_of!(ADLODNCapabilities, fanTemperature) - 104usize];
  ["Offset of field: ADLODNCapabilities::fanSpeed"]
    [::std::mem::offset_of!(ADLODNCapabilities, fanSpeed) - 124usize];
  ["Offset of field: ADLODNCapabilities::minimumPerformanceClock"]
    [::std::mem::offset_of!(ADLODNCapabilities, minimumPerformanceClock) - 144usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive N capabilities\n\n This structure is used to store information about Overdrive N capabilities\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLODNCapabilitiesX2 {
  #[doc = " Number of levels which describe the minimum to maximum clock ranges.\n The 1st level indicates the minimum clocks, and the 2nd level\n indicates the maximum clocks."]
  pub iMaximumNumberOfPerformanceLevels: ::std::os::raw::c_int,
  #[doc = " bit vector, which tells what are the features are supported.\n \\ref: ADLODNFEATURECONTROL"]
  pub iFlags: ::std::os::raw::c_int,
  #[doc = " Contains the hard limits of the sclk range.  Overdrive\n clocks cannot be set outside this range."]
  pub sEngineClockRange: ADLODNParameterRange,
  #[doc = " Contains the hard limits of the mclk range.  Overdrive\n clocks cannot be set outside this range."]
  pub sMemoryClockRange: ADLODNParameterRange,
  #[doc = " Contains the hard limits of the vddc range.  Overdrive\n clocks cannot be set outside this range."]
  pub svddcRange: ADLODNParameterRange,
  #[doc = " Contains the hard limits of the power range.  Overdrive\n clocks cannot be set outside this range."]
  pub power: ADLODNParameterRange,
  #[doc = " Contains the hard limits of the power range.  Overdrive\n clocks cannot be set outside this range."]
  pub powerTuneTemperature: ADLODNParameterRange,
  #[doc = " Contains the hard limits of the Temperature range.  Overdrive\n clocks cannot be set outside this range."]
  pub fanTemperature: ADLODNParameterRange,
  #[doc = " Contains the hard limits of the Fan range.  Overdrive\n clocks cannot be set outside this range."]
  pub fanSpeed: ADLODNParameterRange,
  #[doc = " Contains the hard limits of the Fan range.  Overdrive\n clocks cannot be set outside this range."]
  pub minimumPerformanceClock: ADLODNParameterRange,
  #[doc = " Contains the hard limits of the throttleNotification"]
  pub throttleNotificaion: ADLODNParameterRange,
  #[doc = " Contains the hard limits of the Auto Systemclock"]
  pub autoSystemClock: ADLODNParameterRange,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLODNCapabilitiesX2"]
    [::std::mem::size_of::<ADLODNCapabilitiesX2>() - 208usize];
  ["Alignment of ADLODNCapabilitiesX2"]
    [::std::mem::align_of::<ADLODNCapabilitiesX2>() - 4usize];
  ["Offset of field: ADLODNCapabilitiesX2::iMaximumNumberOfPerformanceLevels"][::std::mem::offset_of!(
    ADLODNCapabilitiesX2,
    iMaximumNumberOfPerformanceLevels
  )
    - 0usize];
  ["Offset of field: ADLODNCapabilitiesX2::iFlags"]
    [::std::mem::offset_of!(ADLODNCapabilitiesX2, iFlags) - 4usize];
  ["Offset of field: ADLODNCapabilitiesX2::sEngineClockRange"]
    [::std::mem::offset_of!(ADLODNCapabilitiesX2, sEngineClockRange) - 8usize];
  ["Offset of field: ADLODNCapabilitiesX2::sMemoryClockRange"]
    [::std::mem::offset_of!(ADLODNCapabilitiesX2, sMemoryClockRange) - 28usize];
  ["Offset of field: ADLODNCapabilitiesX2::svddcRange"]
    [::std::mem::offset_of!(ADLODNCapabilitiesX2, svddcRange) - 48usize];
  ["Offset of field: ADLODNCapabilitiesX2::power"]
    [::std::mem::offset_of!(ADLODNCapabilitiesX2, power) - 68usize];
  ["Offset of field: ADLODNCapabilitiesX2::powerTuneTemperature"]
    [::std::mem::offset_of!(ADLODNCapabilitiesX2, powerTuneTemperature) - 88usize];
  ["Offset of field: ADLODNCapabilitiesX2::fanTemperature"]
    [::std::mem::offset_of!(ADLODNCapabilitiesX2, fanTemperature) - 108usize];
  ["Offset of field: ADLODNCapabilitiesX2::fanSpeed"]
    [::std::mem::offset_of!(ADLODNCapabilitiesX2, fanSpeed) - 128usize];
  ["Offset of field: ADLODNCapabilitiesX2::minimumPerformanceClock"]
    [::std::mem::offset_of!(ADLODNCapabilitiesX2, minimumPerformanceClock) - 148usize];
  ["Offset of field: ADLODNCapabilitiesX2::throttleNotificaion"]
    [::std::mem::offset_of!(ADLODNCapabilitiesX2, throttleNotificaion) - 168usize];
  ["Offset of field: ADLODNCapabilitiesX2::autoSystemClock"]
    [::std::mem::offset_of!(ADLODNCapabilitiesX2, autoSystemClock) - 188usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive level.\n\n This structure is used to store information about Overdrive level.\n This structure is used by ADLODPerformanceLevels.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLODNPerformanceLevel {
  #[doc = " clock."]
  pub iClock: ::std::os::raw::c_int,
  #[doc = " VDCC."]
  pub iVddc: ::std::os::raw::c_int,
  #[doc = " enabled"]
  pub iEnabled: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLODNPerformanceLevel"]
    [::std::mem::size_of::<ADLODNPerformanceLevel>() - 12usize];
  ["Alignment of ADLODNPerformanceLevel"]
    [::std::mem::align_of::<ADLODNPerformanceLevel>() - 4usize];
  ["Offset of field: ADLODNPerformanceLevel::iClock"]
    [::std::mem::offset_of!(ADLODNPerformanceLevel, iClock) - 0usize];
  ["Offset of field: ADLODNPerformanceLevel::iVddc"]
    [::std::mem::offset_of!(ADLODNPerformanceLevel, iVddc) - 4usize];
  ["Offset of field: ADLODNPerformanceLevel::iEnabled"]
    [::std::mem::offset_of!(ADLODNPerformanceLevel, iEnabled) - 8usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive N performance levels.\n\n This structure is used to store information about Overdrive performance levels.\n This structure is used by the ADL_OverdriveN_ODPerformanceLevels_Get() and ADL_OverdriveN_ODPerformanceLevels_Set() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLODNPerformanceLevels {
  pub iSize: ::std::os::raw::c_int,
  pub iMode: ::std::os::raw::c_int,
  #[doc = " Must be set to sizeof( \\ref ADLODPerformanceLevels ) + sizeof( \\ref ADLODPerformanceLevel ) * (ADLODParameters.iNumberOfPerformanceLevels - 1)"]
  pub iNumberOfPerformanceLevels: ::std::os::raw::c_int,
  #[doc = " Array of performance state descriptors. Must have ADLODParameters.iNumberOfPerformanceLevels elements."]
  pub aLevels: [ADLODNPerformanceLevel; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLODNPerformanceLevels"]
    [::std::mem::size_of::<ADLODNPerformanceLevels>() - 24usize];
  ["Alignment of ADLODNPerformanceLevels"]
    [::std::mem::align_of::<ADLODNPerformanceLevels>() - 4usize];
  ["Offset of field: ADLODNPerformanceLevels::iSize"]
    [::std::mem::offset_of!(ADLODNPerformanceLevels, iSize) - 0usize];
  ["Offset of field: ADLODNPerformanceLevels::iMode"]
    [::std::mem::offset_of!(ADLODNPerformanceLevels, iMode) - 4usize];
  ["Offset of field: ADLODNPerformanceLevels::iNumberOfPerformanceLevels"][::std::mem::offset_of!(
    ADLODNPerformanceLevels,
    iNumberOfPerformanceLevels
  ) - 8usize];
  ["Offset of field: ADLODNPerformanceLevels::aLevels"]
    [::std::mem::offset_of!(ADLODNPerformanceLevels, aLevels) - 12usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive N Fan Speed.\n\n This structure is used to store information about Overdrive Fan control .\n This structure is used by the ADL_OverdriveN_ODPerformanceLevels_Get() and ADL_OverdriveN_ODPerformanceLevels_Set() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLODNFanControl {
  pub iMode: ::std::os::raw::c_int,
  pub iFanControlMode: ::std::os::raw::c_int,
  pub iCurrentFanSpeedMode: ::std::os::raw::c_int,
  pub iCurrentFanSpeed: ::std::os::raw::c_int,
  pub iTargetFanSpeed: ::std::os::raw::c_int,
  pub iTargetTemperature: ::std::os::raw::c_int,
  pub iMinPerformanceClock: ::std::os::raw::c_int,
  pub iMinFanLimit: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLODNFanControl"][::std::mem::size_of::<ADLODNFanControl>() - 32usize];
  ["Alignment of ADLODNFanControl"][::std::mem::align_of::<ADLODNFanControl>() - 4usize];
  ["Offset of field: ADLODNFanControl::iMode"]
    [::std::mem::offset_of!(ADLODNFanControl, iMode) - 0usize];
  ["Offset of field: ADLODNFanControl::iFanControlMode"]
    [::std::mem::offset_of!(ADLODNFanControl, iFanControlMode) - 4usize];
  ["Offset of field: ADLODNFanControl::iCurrentFanSpeedMode"]
    [::std::mem::offset_of!(ADLODNFanControl, iCurrentFanSpeedMode) - 8usize];
  ["Offset of field: ADLODNFanControl::iCurrentFanSpeed"]
    [::std::mem::offset_of!(ADLODNFanControl, iCurrentFanSpeed) - 12usize];
  ["Offset of field: ADLODNFanControl::iTargetFanSpeed"]
    [::std::mem::offset_of!(ADLODNFanControl, iTargetFanSpeed) - 16usize];
  ["Offset of field: ADLODNFanControl::iTargetTemperature"]
    [::std::mem::offset_of!(ADLODNFanControl, iTargetTemperature) - 20usize];
  ["Offset of field: ADLODNFanControl::iMinPerformanceClock"]
    [::std::mem::offset_of!(ADLODNFanControl, iMinPerformanceClock) - 24usize];
  ["Offset of field: ADLODNFanControl::iMinFanLimit"]
    [::std::mem::offset_of!(ADLODNFanControl, iMinFanLimit) - 28usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive N power limit.\n\n This structure is used to store information about Overdrive power limit.\n This structure is used by the ADL_OverdriveN_ODPerformanceLevels_Get() and ADL_OverdriveN_ODPerformanceLevels_Set() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLODNPowerLimitSetting {
  pub iMode: ::std::os::raw::c_int,
  pub iTDPLimit: ::std::os::raw::c_int,
  pub iMaxOperatingTemperature: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLODNPowerLimitSetting"]
    [::std::mem::size_of::<ADLODNPowerLimitSetting>() - 12usize];
  ["Alignment of ADLODNPowerLimitSetting"]
    [::std::mem::align_of::<ADLODNPowerLimitSetting>() - 4usize];
  ["Offset of field: ADLODNPowerLimitSetting::iMode"]
    [::std::mem::offset_of!(ADLODNPowerLimitSetting, iMode) - 0usize];
  ["Offset of field: ADLODNPowerLimitSetting::iTDPLimit"]
    [::std::mem::offset_of!(ADLODNPowerLimitSetting, iTDPLimit) - 4usize];
  ["Offset of field: ADLODNPowerLimitSetting::iMaxOperatingTemperature"]
    [::std::mem::offset_of!(ADLODNPowerLimitSetting, iMaxOperatingTemperature) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLODNPerformanceStatus {
  pub iCoreClock: ::std::os::raw::c_int,
  pub iMemoryClock: ::std::os::raw::c_int,
  pub iDCEFClock: ::std::os::raw::c_int,
  pub iGFXClock: ::std::os::raw::c_int,
  pub iUVDClock: ::std::os::raw::c_int,
  pub iVCEClock: ::std::os::raw::c_int,
  pub iGPUActivityPercent: ::std::os::raw::c_int,
  pub iCurrentCorePerformanceLevel: ::std::os::raw::c_int,
  pub iCurrentMemoryPerformanceLevel: ::std::os::raw::c_int,
  pub iCurrentDCEFPerformanceLevel: ::std::os::raw::c_int,
  pub iCurrentGFXPerformanceLevel: ::std::os::raw::c_int,
  pub iUVDPerformanceLevel: ::std::os::raw::c_int,
  pub iVCEPerformanceLevel: ::std::os::raw::c_int,
  pub iCurrentBusSpeed: ::std::os::raw::c_int,
  pub iCurrentBusLanes: ::std::os::raw::c_int,
  pub iMaximumBusLanes: ::std::os::raw::c_int,
  pub iVDDC: ::std::os::raw::c_int,
  pub iVDDCI: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLODNPerformanceStatus"]
    [::std::mem::size_of::<ADLODNPerformanceStatus>() - 72usize];
  ["Alignment of ADLODNPerformanceStatus"]
    [::std::mem::align_of::<ADLODNPerformanceStatus>() - 4usize];
  ["Offset of field: ADLODNPerformanceStatus::iCoreClock"]
    [::std::mem::offset_of!(ADLODNPerformanceStatus, iCoreClock) - 0usize];
  ["Offset of field: ADLODNPerformanceStatus::iMemoryClock"]
    [::std::mem::offset_of!(ADLODNPerformanceStatus, iMemoryClock) - 4usize];
  ["Offset of field: ADLODNPerformanceStatus::iDCEFClock"]
    [::std::mem::offset_of!(ADLODNPerformanceStatus, iDCEFClock) - 8usize];
  ["Offset of field: ADLODNPerformanceStatus::iGFXClock"]
    [::std::mem::offset_of!(ADLODNPerformanceStatus, iGFXClock) - 12usize];
  ["Offset of field: ADLODNPerformanceStatus::iUVDClock"]
    [::std::mem::offset_of!(ADLODNPerformanceStatus, iUVDClock) - 16usize];
  ["Offset of field: ADLODNPerformanceStatus::iVCEClock"]
    [::std::mem::offset_of!(ADLODNPerformanceStatus, iVCEClock) - 20usize];
  ["Offset of field: ADLODNPerformanceStatus::iGPUActivityPercent"]
    [::std::mem::offset_of!(ADLODNPerformanceStatus, iGPUActivityPercent) - 24usize];
  ["Offset of field: ADLODNPerformanceStatus::iCurrentCorePerformanceLevel"][::std::mem::offset_of!(
    ADLODNPerformanceStatus,
    iCurrentCorePerformanceLevel
  ) - 28usize];
  ["Offset of field: ADLODNPerformanceStatus::iCurrentMemoryPerformanceLevel"][::std::mem::offset_of!(
    ADLODNPerformanceStatus,
    iCurrentMemoryPerformanceLevel
  )
    - 32usize];
  ["Offset of field: ADLODNPerformanceStatus::iCurrentDCEFPerformanceLevel"][::std::mem::offset_of!(
    ADLODNPerformanceStatus,
    iCurrentDCEFPerformanceLevel
  ) - 36usize];
  ["Offset of field: ADLODNPerformanceStatus::iCurrentGFXPerformanceLevel"][::std::mem::offset_of!(
    ADLODNPerformanceStatus,
    iCurrentGFXPerformanceLevel
  ) - 40usize];
  ["Offset of field: ADLODNPerformanceStatus::iUVDPerformanceLevel"]
    [::std::mem::offset_of!(ADLODNPerformanceStatus, iUVDPerformanceLevel) - 44usize];
  ["Offset of field: ADLODNPerformanceStatus::iVCEPerformanceLevel"]
    [::std::mem::offset_of!(ADLODNPerformanceStatus, iVCEPerformanceLevel) - 48usize];
  ["Offset of field: ADLODNPerformanceStatus::iCurrentBusSpeed"]
    [::std::mem::offset_of!(ADLODNPerformanceStatus, iCurrentBusSpeed) - 52usize];
  ["Offset of field: ADLODNPerformanceStatus::iCurrentBusLanes"]
    [::std::mem::offset_of!(ADLODNPerformanceStatus, iCurrentBusLanes) - 56usize];
  ["Offset of field: ADLODNPerformanceStatus::iMaximumBusLanes"]
    [::std::mem::offset_of!(ADLODNPerformanceStatus, iMaximumBusLanes) - 60usize];
  ["Offset of field: ADLODNPerformanceStatus::iVDDC"]
    [::std::mem::offset_of!(ADLODNPerformanceStatus, iVDDC) - 64usize];
  ["Offset of field: ADLODNPerformanceStatus::iVDDCI"]
    [::std::mem::offset_of!(ADLODNPerformanceStatus, iVDDCI) - 68usize];
};
#[doc = "\\brief Structure containing information about Overdrive level.\n\n This structure is used to store information about Overdrive level.\n This structure is used by ADLODPerformanceLevels.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLODNPerformanceLevelX2 {
  #[doc = " clock."]
  pub iClock: ::std::os::raw::c_int,
  #[doc = " VDCC."]
  pub iVddc: ::std::os::raw::c_int,
  #[doc = " enabled"]
  pub iEnabled: ::std::os::raw::c_int,
  #[doc = " MASK"]
  pub iControl: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLODNPerformanceLevelX2"]
    [::std::mem::size_of::<ADLODNPerformanceLevelX2>() - 16usize];
  ["Alignment of ADLODNPerformanceLevelX2"]
    [::std::mem::align_of::<ADLODNPerformanceLevelX2>() - 4usize];
  ["Offset of field: ADLODNPerformanceLevelX2::iClock"]
    [::std::mem::offset_of!(ADLODNPerformanceLevelX2, iClock) - 0usize];
  ["Offset of field: ADLODNPerformanceLevelX2::iVddc"]
    [::std::mem::offset_of!(ADLODNPerformanceLevelX2, iVddc) - 4usize];
  ["Offset of field: ADLODNPerformanceLevelX2::iEnabled"]
    [::std::mem::offset_of!(ADLODNPerformanceLevelX2, iEnabled) - 8usize];
  ["Offset of field: ADLODNPerformanceLevelX2::iControl"]
    [::std::mem::offset_of!(ADLODNPerformanceLevelX2, iControl) - 12usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive N performance levels.\n\n This structure is used to store information about Overdrive performance levels.\n This structure is used by the ADL_OverdriveN_ODPerformanceLevels_Get() and ADL_OverdriveN_ODPerformanceLevels_Set() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLODNPerformanceLevelsX2 {
  pub iSize: ::std::os::raw::c_int,
  pub iMode: ::std::os::raw::c_int,
  #[doc = " Must be set to sizeof( \\ref ADLODPerformanceLevels ) + sizeof( \\ref ADLODPerformanceLevel ) * (ADLODParameters.iNumberOfPerformanceLevels - 1)"]
  pub iNumberOfPerformanceLevels: ::std::os::raw::c_int,
  #[doc = " Array of performance state descriptors. Must have ADLODParameters.iNumberOfPerformanceLevels elements."]
  pub aLevels: [ADLODNPerformanceLevelX2; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLODNPerformanceLevelsX2"]
    [::std::mem::size_of::<ADLODNPerformanceLevelsX2>() - 28usize];
  ["Alignment of ADLODNPerformanceLevelsX2"]
    [::std::mem::align_of::<ADLODNPerformanceLevelsX2>() - 4usize];
  ["Offset of field: ADLODNPerformanceLevelsX2::iSize"]
    [::std::mem::offset_of!(ADLODNPerformanceLevelsX2, iSize) - 0usize];
  ["Offset of field: ADLODNPerformanceLevelsX2::iMode"]
    [::std::mem::offset_of!(ADLODNPerformanceLevelsX2, iMode) - 4usize];
  ["Offset of field: ADLODNPerformanceLevelsX2::iNumberOfPerformanceLevels"][::std::mem::offset_of!(
    ADLODNPerformanceLevelsX2,
    iNumberOfPerformanceLevels
  ) - 8usize];
  ["Offset of field: ADLODNPerformanceLevelsX2::aLevels"]
    [::std::mem::offset_of!(ADLODNPerformanceLevelsX2, aLevels) - 12usize];
};
pub const ADLODNCurrentPowerType_ODN_GPU_TOTAL_POWER: ADLODNCurrentPowerType = 0;
pub const ADLODNCurrentPowerType_ODN_GPU_PPT_POWER: ADLODNCurrentPowerType = 1;
pub const ADLODNCurrentPowerType_ODN_GPU_SOCKET_POWER: ADLODNCurrentPowerType = 2;
pub const ADLODNCurrentPowerType_ODN_GPU_CHIP_POWER: ADLODNCurrentPowerType = 3;
pub type ADLODNCurrentPowerType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLODNCurrentPowerParameters {
  pub size: ::std::os::raw::c_int,
  pub powerType: ADLODNCurrentPowerType,
  pub currentPower: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLODNCurrentPowerParameters"]
    [::std::mem::size_of::<ADLODNCurrentPowerParameters>() - 12usize];
  ["Alignment of ADLODNCurrentPowerParameters"]
    [::std::mem::align_of::<ADLODNCurrentPowerParameters>() - 4usize];
  ["Offset of field: ADLODNCurrentPowerParameters::size"]
    [::std::mem::offset_of!(ADLODNCurrentPowerParameters, size) - 0usize];
  ["Offset of field: ADLODNCurrentPowerParameters::powerType"]
    [::std::mem::offset_of!(ADLODNCurrentPowerParameters, powerType) - 4usize];
  ["Offset of field: ADLODNCurrentPowerParameters::currentPower"]
    [::std::mem::offset_of!(ADLODNCurrentPowerParameters, currentPower) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLODNExtSingleInitSetting {
  pub mode: ::std::os::raw::c_int,
  pub minValue: ::std::os::raw::c_int,
  pub maxValue: ::std::os::raw::c_int,
  pub step: ::std::os::raw::c_int,
  pub defaultValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLODNExtSingleInitSetting"]
    [::std::mem::size_of::<ADLODNExtSingleInitSetting>() - 20usize];
  ["Alignment of ADLODNExtSingleInitSetting"]
    [::std::mem::align_of::<ADLODNExtSingleInitSetting>() - 4usize];
  ["Offset of field: ADLODNExtSingleInitSetting::mode"]
    [::std::mem::offset_of!(ADLODNExtSingleInitSetting, mode) - 0usize];
  ["Offset of field: ADLODNExtSingleInitSetting::minValue"]
    [::std::mem::offset_of!(ADLODNExtSingleInitSetting, minValue) - 4usize];
  ["Offset of field: ADLODNExtSingleInitSetting::maxValue"]
    [::std::mem::offset_of!(ADLODNExtSingleInitSetting, maxValue) - 8usize];
  ["Offset of field: ADLODNExtSingleInitSetting::step"]
    [::std::mem::offset_of!(ADLODNExtSingleInitSetting, step) - 12usize];
  ["Offset of field: ADLODNExtSingleInitSetting::defaultValue"]
    [::std::mem::offset_of!(ADLODNExtSingleInitSetting, defaultValue) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLOD8SingleInitSetting {
  pub featureID: ::std::os::raw::c_int,
  pub minValue: ::std::os::raw::c_int,
  pub maxValue: ::std::os::raw::c_int,
  pub defaultValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLOD8SingleInitSetting"]
    [::std::mem::size_of::<ADLOD8SingleInitSetting>() - 16usize];
  ["Alignment of ADLOD8SingleInitSetting"]
    [::std::mem::align_of::<ADLOD8SingleInitSetting>() - 4usize];
  ["Offset of field: ADLOD8SingleInitSetting::featureID"]
    [::std::mem::offset_of!(ADLOD8SingleInitSetting, featureID) - 0usize];
  ["Offset of field: ADLOD8SingleInitSetting::minValue"]
    [::std::mem::offset_of!(ADLOD8SingleInitSetting, minValue) - 4usize];
  ["Offset of field: ADLOD8SingleInitSetting::maxValue"]
    [::std::mem::offset_of!(ADLOD8SingleInitSetting, maxValue) - 8usize];
  ["Offset of field: ADLOD8SingleInitSetting::defaultValue"]
    [::std::mem::offset_of!(ADLOD8SingleInitSetting, defaultValue) - 12usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive8 initial setting\n\n This structure is used to store information about Overdrive8 initial setting\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLOD8InitSetting {
  pub count: ::std::os::raw::c_int,
  pub overdrive8Capabilities: ::std::os::raw::c_int,
  pub od8SettingTable: [ADLOD8SingleInitSetting; 77usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLOD8InitSetting"][::std::mem::size_of::<ADLOD8InitSetting>() - 1240usize];
  ["Alignment of ADLOD8InitSetting"]
    [::std::mem::align_of::<ADLOD8InitSetting>() - 4usize];
  ["Offset of field: ADLOD8InitSetting::count"]
    [::std::mem::offset_of!(ADLOD8InitSetting, count) - 0usize];
  ["Offset of field: ADLOD8InitSetting::overdrive8Capabilities"]
    [::std::mem::offset_of!(ADLOD8InitSetting, overdrive8Capabilities) - 4usize];
  ["Offset of field: ADLOD8InitSetting::od8SettingTable"]
    [::std::mem::offset_of!(ADLOD8InitSetting, od8SettingTable) - 8usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive8 current setting\n\n This structure is used to store information about Overdrive8 current setting\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLOD8CurrentSetting {
  pub count: ::std::os::raw::c_int,
  pub Od8SettingTable: [::std::os::raw::c_int; 77usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLOD8CurrentSetting"]
    [::std::mem::size_of::<ADLOD8CurrentSetting>() - 312usize];
  ["Alignment of ADLOD8CurrentSetting"]
    [::std::mem::align_of::<ADLOD8CurrentSetting>() - 4usize];
  ["Offset of field: ADLOD8CurrentSetting::count"]
    [::std::mem::offset_of!(ADLOD8CurrentSetting, count) - 0usize];
  ["Offset of field: ADLOD8CurrentSetting::Od8SettingTable"]
    [::std::mem::offset_of!(ADLOD8CurrentSetting, Od8SettingTable) - 4usize];
};
#[doc = "\n\\brief Structure containing information about Overdrive8 set setting\n\n This structure is used to store information about Overdrive8 set setting\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLOD8SingleSetSetting {
  pub value: ::std::os::raw::c_int,
  pub requested: ::std::os::raw::c_int,
  pub reset: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLOD8SingleSetSetting"]
    [::std::mem::size_of::<ADLOD8SingleSetSetting>() - 12usize];
  ["Alignment of ADLOD8SingleSetSetting"]
    [::std::mem::align_of::<ADLOD8SingleSetSetting>() - 4usize];
  ["Offset of field: ADLOD8SingleSetSetting::value"]
    [::std::mem::offset_of!(ADLOD8SingleSetSetting, value) - 0usize];
  ["Offset of field: ADLOD8SingleSetSetting::requested"]
    [::std::mem::offset_of!(ADLOD8SingleSetSetting, requested) - 4usize];
  ["Offset of field: ADLOD8SingleSetSetting::reset"]
    [::std::mem::offset_of!(ADLOD8SingleSetSetting, reset) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLOD8SetSetting {
  pub count: ::std::os::raw::c_int,
  pub od8SettingTable: [ADLOD8SingleSetSetting; 77usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLOD8SetSetting"][::std::mem::size_of::<ADLOD8SetSetting>() - 928usize];
  ["Alignment of ADLOD8SetSetting"][::std::mem::align_of::<ADLOD8SetSetting>() - 4usize];
  ["Offset of field: ADLOD8SetSetting::count"]
    [::std::mem::offset_of!(ADLOD8SetSetting, count) - 0usize];
  ["Offset of field: ADLOD8SetSetting::od8SettingTable"]
    [::std::mem::offset_of!(ADLOD8SetSetting, od8SettingTable) - 4usize];
};
#[doc = "\n\\brief Structure containing information about Performance Metrics data\n\n This structure is used to store information about Performance Metrics data output\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLSingleSensorData {
  pub supported: ::std::os::raw::c_int,
  pub value: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLSingleSensorData"][::std::mem::size_of::<ADLSingleSensorData>() - 8usize];
  ["Alignment of ADLSingleSensorData"]
    [::std::mem::align_of::<ADLSingleSensorData>() - 4usize];
  ["Offset of field: ADLSingleSensorData::supported"]
    [::std::mem::offset_of!(ADLSingleSensorData, supported) - 0usize];
  ["Offset of field: ADLSingleSensorData::value"]
    [::std::mem::offset_of!(ADLSingleSensorData, value) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLPMLogDataOutput {
  pub size: ::std::os::raw::c_int,
  pub sensors: [ADLSingleSensorData; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLPMLogDataOutput"][::std::mem::size_of::<ADLPMLogDataOutput>() - 2052usize];
  ["Alignment of ADLPMLogDataOutput"]
    [::std::mem::align_of::<ADLPMLogDataOutput>() - 4usize];
  ["Offset of field: ADLPMLogDataOutput::size"]
    [::std::mem::offset_of!(ADLPMLogDataOutput, size) - 0usize];
  ["Offset of field: ADLPMLogDataOutput::sensors"]
    [::std::mem::offset_of!(ADLPMLogDataOutput, sensors) - 4usize];
};
#[doc = "\n\\brief Structure containing information about PPLog settings.\n\n This structure is used to store information about PPLog settings.\n This structure is used by the ADL2_PPLogSettings_Set() and ADL2_PPLogSettings_Get() functions.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLPPLogSettings {
  pub BreakOnAssert: ::std::os::raw::c_int,
  pub BreakOnWarn: ::std::os::raw::c_int,
  pub LogEnabled: ::std::os::raw::c_int,
  pub LogFieldMask: ::std::os::raw::c_int,
  pub LogDestinations: ::std::os::raw::c_int,
  pub LogSeverityEnabled: ::std::os::raw::c_int,
  pub LogSourceMask: ::std::os::raw::c_int,
  pub PowerProfilingEnabled: ::std::os::raw::c_int,
  pub PowerProfilingTimeInterval: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLPPLogSettings"][::std::mem::size_of::<ADLPPLogSettings>() - 36usize];
  ["Alignment of ADLPPLogSettings"][::std::mem::align_of::<ADLPPLogSettings>() - 4usize];
  ["Offset of field: ADLPPLogSettings::BreakOnAssert"]
    [::std::mem::offset_of!(ADLPPLogSettings, BreakOnAssert) - 0usize];
  ["Offset of field: ADLPPLogSettings::BreakOnWarn"]
    [::std::mem::offset_of!(ADLPPLogSettings, BreakOnWarn) - 4usize];
  ["Offset of field: ADLPPLogSettings::LogEnabled"]
    [::std::mem::offset_of!(ADLPPLogSettings, LogEnabled) - 8usize];
  ["Offset of field: ADLPPLogSettings::LogFieldMask"]
    [::std::mem::offset_of!(ADLPPLogSettings, LogFieldMask) - 12usize];
  ["Offset of field: ADLPPLogSettings::LogDestinations"]
    [::std::mem::offset_of!(ADLPPLogSettings, LogDestinations) - 16usize];
  ["Offset of field: ADLPPLogSettings::LogSeverityEnabled"]
    [::std::mem::offset_of!(ADLPPLogSettings, LogSeverityEnabled) - 20usize];
  ["Offset of field: ADLPPLogSettings::LogSourceMask"]
    [::std::mem::offset_of!(ADLPPLogSettings, LogSourceMask) - 24usize];
  ["Offset of field: ADLPPLogSettings::PowerProfilingEnabled"]
    [::std::mem::offset_of!(ADLPPLogSettings, PowerProfilingEnabled) - 28usize];
  ["Offset of field: ADLPPLogSettings::PowerProfilingTimeInterval"]
    [::std::mem::offset_of!(ADLPPLogSettings, PowerProfilingTimeInterval) - 32usize];
};
#[doc = "\n\\brief Structure containing information related Frames Per Second for AC and DC.\n\n This structure is used to store information related AC and DC Frames Per Second settings\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLFPSSettingsOutput {
  #[doc = " size"]
  pub ulSize: ::std::os::raw::c_int,
  #[doc = " FPS Monitor is enabled in the AC state if 1"]
  pub bACFPSEnabled: ::std::os::raw::c_int,
  #[doc = " FPS Monitor is enabled in the DC state if 1"]
  pub bDCFPSEnabled: ::std::os::raw::c_int,
  #[doc = " Current Value of FPS Monitor in AC state"]
  pub ulACFPSCurrent: ::std::os::raw::c_int,
  #[doc = " Current Value of FPS Monitor in DC state"]
  pub ulDCFPSCurrent: ::std::os::raw::c_int,
  #[doc = " Maximum FPS Threshold allowed in PPLib for AC"]
  pub ulACFPSMaximum: ::std::os::raw::c_int,
  #[doc = " Minimum FPS Threshold allowed in PPLib for AC"]
  pub ulACFPSMinimum: ::std::os::raw::c_int,
  #[doc = " Maximum FPS Threshold allowed in PPLib for DC"]
  pub ulDCFPSMaximum: ::std::os::raw::c_int,
  #[doc = " Minimum FPS Threshold allowed in PPLib for DC"]
  pub ulDCFPSMinimum: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLFPSSettingsOutput"]
    [::std::mem::size_of::<ADLFPSSettingsOutput>() - 36usize];
  ["Alignment of ADLFPSSettingsOutput"]
    [::std::mem::align_of::<ADLFPSSettingsOutput>() - 4usize];
  ["Offset of field: ADLFPSSettingsOutput::ulSize"]
    [::std::mem::offset_of!(ADLFPSSettingsOutput, ulSize) - 0usize];
  ["Offset of field: ADLFPSSettingsOutput::bACFPSEnabled"]
    [::std::mem::offset_of!(ADLFPSSettingsOutput, bACFPSEnabled) - 4usize];
  ["Offset of field: ADLFPSSettingsOutput::bDCFPSEnabled"]
    [::std::mem::offset_of!(ADLFPSSettingsOutput, bDCFPSEnabled) - 8usize];
  ["Offset of field: ADLFPSSettingsOutput::ulACFPSCurrent"]
    [::std::mem::offset_of!(ADLFPSSettingsOutput, ulACFPSCurrent) - 12usize];
  ["Offset of field: ADLFPSSettingsOutput::ulDCFPSCurrent"]
    [::std::mem::offset_of!(ADLFPSSettingsOutput, ulDCFPSCurrent) - 16usize];
  ["Offset of field: ADLFPSSettingsOutput::ulACFPSMaximum"]
    [::std::mem::offset_of!(ADLFPSSettingsOutput, ulACFPSMaximum) - 20usize];
  ["Offset of field: ADLFPSSettingsOutput::ulACFPSMinimum"]
    [::std::mem::offset_of!(ADLFPSSettingsOutput, ulACFPSMinimum) - 24usize];
  ["Offset of field: ADLFPSSettingsOutput::ulDCFPSMaximum"]
    [::std::mem::offset_of!(ADLFPSSettingsOutput, ulDCFPSMaximum) - 28usize];
  ["Offset of field: ADLFPSSettingsOutput::ulDCFPSMinimum"]
    [::std::mem::offset_of!(ADLFPSSettingsOutput, ulDCFPSMinimum) - 32usize];
};
#[doc = "\n\\brief Structure containing information related Frames Per Second for AC and DC.\n\n This structure is used to store information related AC and DC Frames Per Second settings\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLFPSSettingsInput {
  #[doc = " size"]
  pub ulSize: ::std::os::raw::c_int,
  #[doc = " Settings are for Global FPS (used by CCC)"]
  pub bGlobalSettings: ::std::os::raw::c_int,
  #[doc = " Current Value of FPS Monitor in AC state"]
  pub ulACFPSCurrent: ::std::os::raw::c_int,
  #[doc = " Current Value of FPS Monitor in DC state"]
  pub ulDCFPSCurrent: ::std::os::raw::c_int,
  #[doc = " Reserved"]
  pub ulReserved: [::std::os::raw::c_int; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLFPSSettingsInput"][::std::mem::size_of::<ADLFPSSettingsInput>() - 40usize];
  ["Alignment of ADLFPSSettingsInput"]
    [::std::mem::align_of::<ADLFPSSettingsInput>() - 4usize];
  ["Offset of field: ADLFPSSettingsInput::ulSize"]
    [::std::mem::offset_of!(ADLFPSSettingsInput, ulSize) - 0usize];
  ["Offset of field: ADLFPSSettingsInput::bGlobalSettings"]
    [::std::mem::offset_of!(ADLFPSSettingsInput, bGlobalSettings) - 4usize];
  ["Offset of field: ADLFPSSettingsInput::ulACFPSCurrent"]
    [::std::mem::offset_of!(ADLFPSSettingsInput, ulACFPSCurrent) - 8usize];
  ["Offset of field: ADLFPSSettingsInput::ulDCFPSCurrent"]
    [::std::mem::offset_of!(ADLFPSSettingsInput, ulDCFPSCurrent) - 12usize];
  ["Offset of field: ADLFPSSettingsInput::ulReserved"]
    [::std::mem::offset_of!(ADLFPSSettingsInput, ulReserved) - 16usize];
};
pub const ADL_PMLOG_MAX_SUPPORTED_SENSORS: _bindgen_ty_1 = 256;
#[doc = "\n\\brief Structure containing information related power management logging.\n\n This structure is used to store support information for power management logging.\n \\nosubgrouping\n"]
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLPMLogSupportInfo {
  #[doc = " list of sensors defined by ADL_PMLOG_SENSORS"]
  pub usSensors: [::std::os::raw::c_ushort; 256usize],
  #[doc = " Reserved"]
  pub ulReserved: [::std::os::raw::c_int; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLPMLogSupportInfo"]
    [::std::mem::size_of::<ADLPMLogSupportInfo>() - 576usize];
  ["Alignment of ADLPMLogSupportInfo"]
    [::std::mem::align_of::<ADLPMLogSupportInfo>() - 4usize];
  ["Offset of field: ADLPMLogSupportInfo::usSensors"]
    [::std::mem::offset_of!(ADLPMLogSupportInfo, usSensors) - 0usize];
  ["Offset of field: ADLPMLogSupportInfo::ulReserved"]
    [::std::mem::offset_of!(ADLPMLogSupportInfo, ulReserved) - 512usize];
};
#[doc = "\n\\brief Structure containing information to start power management logging.\n\n This structure is used as input to ADL2_Adapter_PMLog_Start\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLPMLogStartInput {
  #[doc = " list of sensors defined by ADL_PMLOG_SENSORS"]
  pub usSensors: [::std::os::raw::c_ushort; 256usize],
  #[doc = " Sample rate in milliseconds"]
  pub ulSampleRate: ::std::os::raw::c_ulong,
  #[doc = " Reserved"]
  pub ulReserved: [::std::os::raw::c_int; 15usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLPMLogStartInput"][::std::mem::size_of::<ADLPMLogStartInput>() - 576usize];
  ["Alignment of ADLPMLogStartInput"]
    [::std::mem::align_of::<ADLPMLogStartInput>() - 4usize];
  ["Offset of field: ADLPMLogStartInput::usSensors"]
    [::std::mem::offset_of!(ADLPMLogStartInput, usSensors) - 0usize];
  ["Offset of field: ADLPMLogStartInput::ulSampleRate"]
    [::std::mem::offset_of!(ADLPMLogStartInput, ulSampleRate) - 512usize];
  ["Offset of field: ADLPMLogStartInput::ulReserved"]
    [::std::mem::offset_of!(ADLPMLogStartInput, ulReserved) - 516usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLPMLogData {
  #[doc = " Structure version"]
  pub ulVersion: ::std::os::raw::c_uint,
  #[doc = " Current driver sample rate"]
  pub ulActiveSampleRate: ::std::os::raw::c_uint,
  #[doc = " Timestamp of last update"]
  pub ulLastUpdated: ::std::os::raw::c_ulonglong,
  #[doc = " 2D array of senesor and values"]
  pub ulValues: [[::std::os::raw::c_uint; 2usize]; 256usize],
  #[doc = " Reserved"]
  pub ulReserved: [::std::os::raw::c_uint; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLPMLogData"][::std::mem::size_of::<ADLPMLogData>() - 3088usize];
  ["Alignment of ADLPMLogData"][::std::mem::align_of::<ADLPMLogData>() - 8usize];
  ["Offset of field: ADLPMLogData::ulVersion"]
    [::std::mem::offset_of!(ADLPMLogData, ulVersion) - 0usize];
  ["Offset of field: ADLPMLogData::ulActiveSampleRate"]
    [::std::mem::offset_of!(ADLPMLogData, ulActiveSampleRate) - 4usize];
  ["Offset of field: ADLPMLogData::ulLastUpdated"]
    [::std::mem::offset_of!(ADLPMLogData, ulLastUpdated) - 8usize];
  ["Offset of field: ADLPMLogData::ulValues"]
    [::std::mem::offset_of!(ADLPMLogData, ulValues) - 16usize];
  ["Offset of field: ADLPMLogData::ulReserved"]
    [::std::mem::offset_of!(ADLPMLogData, ulReserved) - 2064usize];
};
#[doc = "\n\\brief Structure containing information to start power management logging.\n\n This structure is returned as output from ADL2_Adapter_PMLog_Start\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADLPMLogStartOutput {
  pub __bindgen_anon_1: ADLPMLogStartOutput__bindgen_ty_1,
  #[doc = " Reserved"]
  pub ulReserved: [::std::os::raw::c_int; 14usize],
}
#[doc = " Pointer to memory address containing logging data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADLPMLogStartOutput__bindgen_ty_1 {
  pub pLoggingAddress: *mut ::std::os::raw::c_void,
  pub ptr_LoggingAddress: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLPMLogStartOutput__bindgen_ty_1"]
    [::std::mem::size_of::<ADLPMLogStartOutput__bindgen_ty_1>() - 8usize];
  ["Alignment of ADLPMLogStartOutput__bindgen_ty_1"]
    [::std::mem::align_of::<ADLPMLogStartOutput__bindgen_ty_1>() - 8usize];
  ["Offset of field: ADLPMLogStartOutput__bindgen_ty_1::pLoggingAddress"]
    [::std::mem::offset_of!(ADLPMLogStartOutput__bindgen_ty_1, pLoggingAddress) - 0usize];
  ["Offset of field: ADLPMLogStartOutput__bindgen_ty_1::ptr_LoggingAddress"][::std::mem::offset_of!(
    ADLPMLogStartOutput__bindgen_ty_1,
    ptr_LoggingAddress
  ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLPMLogStartOutput"][::std::mem::size_of::<ADLPMLogStartOutput>() - 64usize];
  ["Alignment of ADLPMLogStartOutput"]
    [::std::mem::align_of::<ADLPMLogStartOutput>() - 8usize];
  ["Offset of field: ADLPMLogStartOutput::ulReserved"]
    [::std::mem::offset_of!(ADLPMLogStartOutput, ulReserved) - 8usize];
};
#[doc = "\n\\brief Structure containing information to query limts of power management logging.\n\n This structure is returned as output from ADL2_Adapter_PMLog_SensorLimits_Get\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLPMLogSensorLimits {
  pub SensorLimits: [[::std::os::raw::c_int; 2usize]; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLPMLogSensorLimits"]
    [::std::mem::size_of::<ADLPMLogSensorLimits>() - 2048usize];
  ["Alignment of ADLPMLogSensorLimits"]
    [::std::mem::align_of::<ADLPMLogSensorLimits>() - 4usize];
  ["Offset of field: ADLPMLogSensorLimits::SensorLimits"]
    [::std::mem::offset_of!(ADLPMLogSensorLimits, SensorLimits) - 0usize];
};
#[doc = "\n\\brief Structure containing information related RAS Get Error Counts Information\n\n This structure is used to store RAS Error Counts Get Input Information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLRASGetErrorCountsInput {
  pub Reserved: [::std::os::raw::c_uint; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLRASGetErrorCountsInput"]
    [::std::mem::size_of::<ADLRASGetErrorCountsInput>() - 64usize];
  ["Alignment of ADLRASGetErrorCountsInput"]
    [::std::mem::align_of::<ADLRASGetErrorCountsInput>() - 4usize];
  ["Offset of field: ADLRASGetErrorCountsInput::Reserved"]
    [::std::mem::offset_of!(ADLRASGetErrorCountsInput, Reserved) - 0usize];
};
#[doc = "\n\\brief Structure containing information related RAS Get Error Counts Information\n\n This structure is used to store RAS Error Counts Get Output Information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLRASGetErrorCountsOutput {
  pub CorrectedErrors: ::std::os::raw::c_uint,
  pub UnCorrectedErrors: ::std::os::raw::c_uint,
  pub Reserved: [::std::os::raw::c_uint; 14usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLRASGetErrorCountsOutput"]
    [::std::mem::size_of::<ADLRASGetErrorCountsOutput>() - 64usize];
  ["Alignment of ADLRASGetErrorCountsOutput"]
    [::std::mem::align_of::<ADLRASGetErrorCountsOutput>() - 4usize];
  ["Offset of field: ADLRASGetErrorCountsOutput::CorrectedErrors"]
    [::std::mem::offset_of!(ADLRASGetErrorCountsOutput, CorrectedErrors) - 0usize];
  ["Offset of field: ADLRASGetErrorCountsOutput::UnCorrectedErrors"]
    [::std::mem::offset_of!(ADLRASGetErrorCountsOutput, UnCorrectedErrors) - 4usize];
  ["Offset of field: ADLRASGetErrorCountsOutput::Reserved"]
    [::std::mem::offset_of!(ADLRASGetErrorCountsOutput, Reserved) - 8usize];
};
#[doc = "\n\\brief Structure containing information related RAS Get Error Counts Information\n\n This structure is used to store RAS Error Counts Get Information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLRASGetErrorCounts {
  pub InputSize: ::std::os::raw::c_uint,
  pub Input: ADLRASGetErrorCountsInput,
  pub OutputSize: ::std::os::raw::c_uint,
  pub Output: ADLRASGetErrorCountsOutput,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLRASGetErrorCounts"]
    [::std::mem::size_of::<ADLRASGetErrorCounts>() - 136usize];
  ["Alignment of ADLRASGetErrorCounts"]
    [::std::mem::align_of::<ADLRASGetErrorCounts>() - 4usize];
  ["Offset of field: ADLRASGetErrorCounts::InputSize"]
    [::std::mem::offset_of!(ADLRASGetErrorCounts, InputSize) - 0usize];
  ["Offset of field: ADLRASGetErrorCounts::Input"]
    [::std::mem::offset_of!(ADLRASGetErrorCounts, Input) - 4usize];
  ["Offset of field: ADLRASGetErrorCounts::OutputSize"]
    [::std::mem::offset_of!(ADLRASGetErrorCounts, OutputSize) - 68usize];
  ["Offset of field: ADLRASGetErrorCounts::Output"]
    [::std::mem::offset_of!(ADLRASGetErrorCounts, Output) - 72usize];
};
#[doc = "\n\\brief Structure containing information related RAS Error Counts Reset Information\n\n This structure is used to store RAS Error Counts Reset Input Information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLRASResetErrorCountsInput {
  pub Reserved: [::std::os::raw::c_uint; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLRASResetErrorCountsInput"]
    [::std::mem::size_of::<ADLRASResetErrorCountsInput>() - 32usize];
  ["Alignment of ADLRASResetErrorCountsInput"]
    [::std::mem::align_of::<ADLRASResetErrorCountsInput>() - 4usize];
  ["Offset of field: ADLRASResetErrorCountsInput::Reserved"]
    [::std::mem::offset_of!(ADLRASResetErrorCountsInput, Reserved) - 0usize];
};
#[doc = "\n\\brief Structure containing information related RAS Error Counts Reset Information\n\n This structure is used to store RAS Error Counts Reset Output Information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLRASResetErrorCountsOutput {
  pub Reserved: [::std::os::raw::c_uint; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLRASResetErrorCountsOutput"]
    [::std::mem::size_of::<ADLRASResetErrorCountsOutput>() - 32usize];
  ["Alignment of ADLRASResetErrorCountsOutput"]
    [::std::mem::align_of::<ADLRASResetErrorCountsOutput>() - 4usize];
  ["Offset of field: ADLRASResetErrorCountsOutput::Reserved"]
    [::std::mem::offset_of!(ADLRASResetErrorCountsOutput, Reserved) - 0usize];
};
#[doc = "\n\\brief Structure containing information related RAS Error Counts Reset Information\n\n This structure is used to store RAS Error Counts Reset Information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLRASResetErrorCounts {
  pub InputSize: ::std::os::raw::c_uint,
  pub Input: ADLRASResetErrorCountsInput,
  pub OutputSize: ::std::os::raw::c_uint,
  pub Output: ADLRASResetErrorCountsOutput,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLRASResetErrorCounts"]
    [::std::mem::size_of::<ADLRASResetErrorCounts>() - 72usize];
  ["Alignment of ADLRASResetErrorCounts"]
    [::std::mem::align_of::<ADLRASResetErrorCounts>() - 4usize];
  ["Offset of field: ADLRASResetErrorCounts::InputSize"]
    [::std::mem::offset_of!(ADLRASResetErrorCounts, InputSize) - 0usize];
  ["Offset of field: ADLRASResetErrorCounts::Input"]
    [::std::mem::offset_of!(ADLRASResetErrorCounts, Input) - 4usize];
  ["Offset of field: ADLRASResetErrorCounts::OutputSize"]
    [::std::mem::offset_of!(ADLRASResetErrorCounts, OutputSize) - 36usize];
  ["Offset of field: ADLRASResetErrorCounts::Output"]
    [::std::mem::offset_of!(ADLRASResetErrorCounts, Output) - 40usize];
};
#[doc = "\n\\brief Structure containing information related RAS Error Injection information\n\n This structure is used to store RAS Error Injection input information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLRASErrorInjectonInput {
  pub Address: ::std::os::raw::c_ulonglong,
  pub Value: ADL_RAS_INJECTION_METHOD,
  pub BlockId: ADL_RAS_BLOCK_ID,
  pub InjectErrorType: ADL_RAS_ERROR_TYPE,
  pub SubBlockIndex: ADL_MEM_SUB_BLOCK_ID,
  pub padding: [::std::os::raw::c_uint; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLRASErrorInjectonInput"]
    [::std::mem::size_of::<ADLRASErrorInjectonInput>() - 64usize];
  ["Alignment of ADLRASErrorInjectonInput"]
    [::std::mem::align_of::<ADLRASErrorInjectonInput>() - 8usize];
  ["Offset of field: ADLRASErrorInjectonInput::Address"]
    [::std::mem::offset_of!(ADLRASErrorInjectonInput, Address) - 0usize];
  ["Offset of field: ADLRASErrorInjectonInput::Value"]
    [::std::mem::offset_of!(ADLRASErrorInjectonInput, Value) - 8usize];
  ["Offset of field: ADLRASErrorInjectonInput::BlockId"]
    [::std::mem::offset_of!(ADLRASErrorInjectonInput, BlockId) - 12usize];
  ["Offset of field: ADLRASErrorInjectonInput::InjectErrorType"]
    [::std::mem::offset_of!(ADLRASErrorInjectonInput, InjectErrorType) - 16usize];
  ["Offset of field: ADLRASErrorInjectonInput::SubBlockIndex"]
    [::std::mem::offset_of!(ADLRASErrorInjectonInput, SubBlockIndex) - 20usize];
  ["Offset of field: ADLRASErrorInjectonInput::padding"]
    [::std::mem::offset_of!(ADLRASErrorInjectonInput, padding) - 24usize];
};
#[doc = "\n\\brief Structure containing information related RAS Error Injection information\n\n This structure is used to store RAS Error Injection output information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLRASErrorInjectionOutput {
  pub ErrorInjectionStatus: ::std::os::raw::c_uint,
  pub padding: [::std::os::raw::c_uint; 15usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLRASErrorInjectionOutput"]
    [::std::mem::size_of::<ADLRASErrorInjectionOutput>() - 64usize];
  ["Alignment of ADLRASErrorInjectionOutput"]
    [::std::mem::align_of::<ADLRASErrorInjectionOutput>() - 4usize];
  ["Offset of field: ADLRASErrorInjectionOutput::ErrorInjectionStatus"]
    [::std::mem::offset_of!(ADLRASErrorInjectionOutput, ErrorInjectionStatus) - 0usize];
  ["Offset of field: ADLRASErrorInjectionOutput::padding"]
    [::std::mem::offset_of!(ADLRASErrorInjectionOutput, padding) - 4usize];
};
#[doc = "\n\\brief Structure containing information related RAS Error Injection information\n\n This structure is used to store RAS Error Injection information\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLRASErrorInjection {
  pub InputSize: ::std::os::raw::c_uint,
  pub Input: ADLRASErrorInjectonInput,
  pub OutputSize: ::std::os::raw::c_uint,
  pub Output: ADLRASErrorInjectionOutput,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLRASErrorInjection"]
    [::std::mem::size_of::<ADLRASErrorInjection>() - 144usize];
  ["Alignment of ADLRASErrorInjection"]
    [::std::mem::align_of::<ADLRASErrorInjection>() - 8usize];
  ["Offset of field: ADLRASErrorInjection::InputSize"]
    [::std::mem::offset_of!(ADLRASErrorInjection, InputSize) - 0usize];
  ["Offset of field: ADLRASErrorInjection::Input"]
    [::std::mem::offset_of!(ADLRASErrorInjection, Input) - 8usize];
  ["Offset of field: ADLRASErrorInjection::OutputSize"]
    [::std::mem::offset_of!(ADLRASErrorInjection, OutputSize) - 72usize];
  ["Offset of field: ADLRASErrorInjection::Output"]
    [::std::mem::offset_of!(ADLRASErrorInjection, Output) - 76usize];
};
#[doc = "\n\\brief Structure containing information about an application\n\n This structure is used to store basic information of a recently ran or currently running application\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLSGApplicationInfo {
  #[doc = " Application file name"]
  pub strFileName: [wchar_t; 256usize],
  #[doc = " Application file path"]
  pub strFilePath: [wchar_t; 256usize],
  #[doc = " Application version"]
  pub strVersion: [wchar_t; 256usize],
  #[doc = " Timestamp at which application has run"]
  pub timeStamp: ::std::os::raw::c_longlong,
  #[doc = " Holds whether the applicaition profile exists or not"]
  pub iProfileExists: ::std::os::raw::c_uint,
  #[doc = " The GPU on which application runs"]
  pub iGPUAffinity: ::std::os::raw::c_uint,
  #[doc = " The BDF of the GPU on which application runs"]
  pub GPUBdf: ADLBdf,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLSGApplicationInfo"]
    [::std::mem::size_of::<ADLSGApplicationInfo>() - 1568usize];
  ["Alignment of ADLSGApplicationInfo"]
    [::std::mem::align_of::<ADLSGApplicationInfo>() - 8usize];
  ["Offset of field: ADLSGApplicationInfo::strFileName"]
    [::std::mem::offset_of!(ADLSGApplicationInfo, strFileName) - 0usize];
  ["Offset of field: ADLSGApplicationInfo::strFilePath"]
    [::std::mem::offset_of!(ADLSGApplicationInfo, strFilePath) - 512usize];
  ["Offset of field: ADLSGApplicationInfo::strVersion"]
    [::std::mem::offset_of!(ADLSGApplicationInfo, strVersion) - 1024usize];
  ["Offset of field: ADLSGApplicationInfo::timeStamp"]
    [::std::mem::offset_of!(ADLSGApplicationInfo, timeStamp) - 1536usize];
  ["Offset of field: ADLSGApplicationInfo::iProfileExists"]
    [::std::mem::offset_of!(ADLSGApplicationInfo, iProfileExists) - 1544usize];
  ["Offset of field: ADLSGApplicationInfo::iGPUAffinity"]
    [::std::mem::offset_of!(ADLSGApplicationInfo, iGPUAffinity) - 1548usize];
  ["Offset of field: ADLSGApplicationInfo::GPUBdf"]
    [::std::mem::offset_of!(ADLSGApplicationInfo, GPUBdf) - 1552usize];
};
pub const ADLPreFlipPostProcessingInfoInvalidLUTIndex: _bindgen_ty_2 = -1;
#[doc = "\n\\brief Structure containing information related Frames Per Second for AC and DC.\n\n This structure is used to store information related AC and DC Frames Per Second settings\n \\nosubgrouping\n"]
pub type _bindgen_ty_2 = ::std::os::raw::c_int;
pub const ADLPreFlipPostProcessingLUTAlgorithm_ADLPreFlipPostProcessingLUTAlgorithm_Default : ADLPreFlipPostProcessingLUTAlgorithm = 0 ;
pub const ADLPreFlipPostProcessingLUTAlgorithm_ADLPreFlipPostProcessingLUTAlgorithm_Full : ADLPreFlipPostProcessingLUTAlgorithm = 1 ;
pub const ADLPreFlipPostProcessingLUTAlgorithm_ADLPreFlipPostProcessingLUTAlgorithm_Approximation : ADLPreFlipPostProcessingLUTAlgorithm = 2 ;
pub type ADLPreFlipPostProcessingLUTAlgorithm = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLPreFlipPostProcessingInfo {
  #[doc = " size"]
  pub ulSize: ::std::os::raw::c_int,
  #[doc = " Current active state"]
  pub bEnabled: ::std::os::raw::c_int,
  #[doc = " Current selected LUT index.  0xFFFFFFF returned if nothing selected."]
  pub ulSelectedLUTIndex: ::std::os::raw::c_int,
  #[doc = " Current selected LUT Algorithm"]
  pub ulSelectedLUTAlgorithm: ::std::os::raw::c_int,
  #[doc = " Reserved"]
  pub ulReserved: [::std::os::raw::c_int; 12usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLPreFlipPostProcessingInfo"]
    [::std::mem::size_of::<ADLPreFlipPostProcessingInfo>() - 64usize];
  ["Alignment of ADLPreFlipPostProcessingInfo"]
    [::std::mem::align_of::<ADLPreFlipPostProcessingInfo>() - 4usize];
  ["Offset of field: ADLPreFlipPostProcessingInfo::ulSize"]
    [::std::mem::offset_of!(ADLPreFlipPostProcessingInfo, ulSize) - 0usize];
  ["Offset of field: ADLPreFlipPostProcessingInfo::bEnabled"]
    [::std::mem::offset_of!(ADLPreFlipPostProcessingInfo, bEnabled) - 4usize];
  ["Offset of field: ADLPreFlipPostProcessingInfo::ulSelectedLUTIndex"]
    [::std::mem::offset_of!(ADLPreFlipPostProcessingInfo, ulSelectedLUTIndex) - 8usize];
  ["Offset of field: ADLPreFlipPostProcessingInfo::ulSelectedLUTAlgorithm"][::std::mem::offset_of!(
    ADLPreFlipPostProcessingInfo,
    ulSelectedLUTAlgorithm
  ) - 12usize];
  ["Offset of field: ADLPreFlipPostProcessingInfo::ulReserved"]
    [::std::mem::offset_of!(ADLPreFlipPostProcessingInfo, ulReserved) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_ERROR_REASON {
  pub boost: ::std::os::raw::c_int,
  pub delag: ::std::os::raw::c_int,
  pub chill: ::std::os::raw::c_int,
  pub proVsr: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_ERROR_REASON"][::std::mem::size_of::<ADL_ERROR_REASON>() - 16usize];
  ["Alignment of ADL_ERROR_REASON"][::std::mem::align_of::<ADL_ERROR_REASON>() - 4usize];
  ["Offset of field: ADL_ERROR_REASON::boost"]
    [::std::mem::offset_of!(ADL_ERROR_REASON, boost) - 0usize];
  ["Offset of field: ADL_ERROR_REASON::delag"]
    [::std::mem::offset_of!(ADL_ERROR_REASON, delag) - 4usize];
  ["Offset of field: ADL_ERROR_REASON::chill"]
    [::std::mem::offset_of!(ADL_ERROR_REASON, chill) - 8usize];
  ["Offset of field: ADL_ERROR_REASON::proVsr"]
    [::std::mem::offset_of!(ADL_ERROR_REASON, proVsr) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_ERROR_REASON2 {
  pub boost: ::std::os::raw::c_int,
  pub delag: ::std::os::raw::c_int,
  pub chill: ::std::os::raw::c_int,
  pub proVsr: ::std::os::raw::c_int,
  pub upscale: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_ERROR_REASON2"][::std::mem::size_of::<ADL_ERROR_REASON2>() - 20usize];
  ["Alignment of ADL_ERROR_REASON2"]
    [::std::mem::align_of::<ADL_ERROR_REASON2>() - 4usize];
  ["Offset of field: ADL_ERROR_REASON2::boost"]
    [::std::mem::offset_of!(ADL_ERROR_REASON2, boost) - 0usize];
  ["Offset of field: ADL_ERROR_REASON2::delag"]
    [::std::mem::offset_of!(ADL_ERROR_REASON2, delag) - 4usize];
  ["Offset of field: ADL_ERROR_REASON2::chill"]
    [::std::mem::offset_of!(ADL_ERROR_REASON2, chill) - 8usize];
  ["Offset of field: ADL_ERROR_REASON2::proVsr"]
    [::std::mem::offset_of!(ADL_ERROR_REASON2, proVsr) - 12usize];
  ["Offset of field: ADL_ERROR_REASON2::upscale"]
    [::std::mem::offset_of!(ADL_ERROR_REASON2, upscale) - 16usize];
};
#[doc = "\n\\brief Structure containing information about DELAG Settings change reason\n\n  Elements of DELAG settings changed reason.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_DELAG_NOTFICATION_REASON {
  pub HotkeyChanged: ::std::os::raw::c_int,
  pub GlobalEnableChanged: ::std::os::raw::c_int,
  pub GlobalLimitFPSChanged: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_DELAG_NOTFICATION_REASON"]
    [::std::mem::size_of::<ADL_DELAG_NOTFICATION_REASON>() - 12usize];
  ["Alignment of ADL_DELAG_NOTFICATION_REASON"]
    [::std::mem::align_of::<ADL_DELAG_NOTFICATION_REASON>() - 4usize];
  ["Offset of field: ADL_DELAG_NOTFICATION_REASON::HotkeyChanged"]
    [::std::mem::offset_of!(ADL_DELAG_NOTFICATION_REASON, HotkeyChanged) - 0usize];
  ["Offset of field: ADL_DELAG_NOTFICATION_REASON::GlobalEnableChanged"]
    [::std::mem::offset_of!(ADL_DELAG_NOTFICATION_REASON, GlobalEnableChanged) - 4usize];
  ["Offset of field: ADL_DELAG_NOTFICATION_REASON::GlobalLimitFPSChanged"][::std::mem::offset_of!(
    ADL_DELAG_NOTFICATION_REASON,
    GlobalLimitFPSChanged
  ) - 8usize];
};
#[doc = "\n\\brief Structure containing information about DELAG Settings\n\n  Elements of DELAG settings.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_DELAG_SETTINGS {
  pub Hotkey: ::std::os::raw::c_int,
  pub GlobalEnable: ::std::os::raw::c_int,
  pub GlobalLimitFPS: ::std::os::raw::c_int,
  pub GlobalLimitFPS_MinLimit: ::std::os::raw::c_int,
  pub GlobalLimitFPS_MaxLimit: ::std::os::raw::c_int,
  pub GlobalLimitFPS_Step: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_DELAG_SETTINGS"][::std::mem::size_of::<ADL_DELAG_SETTINGS>() - 24usize];
  ["Alignment of ADL_DELAG_SETTINGS"]
    [::std::mem::align_of::<ADL_DELAG_SETTINGS>() - 4usize];
  ["Offset of field: ADL_DELAG_SETTINGS::Hotkey"]
    [::std::mem::offset_of!(ADL_DELAG_SETTINGS, Hotkey) - 0usize];
  ["Offset of field: ADL_DELAG_SETTINGS::GlobalEnable"]
    [::std::mem::offset_of!(ADL_DELAG_SETTINGS, GlobalEnable) - 4usize];
  ["Offset of field: ADL_DELAG_SETTINGS::GlobalLimitFPS"]
    [::std::mem::offset_of!(ADL_DELAG_SETTINGS, GlobalLimitFPS) - 8usize];
  ["Offset of field: ADL_DELAG_SETTINGS::GlobalLimitFPS_MinLimit"]
    [::std::mem::offset_of!(ADL_DELAG_SETTINGS, GlobalLimitFPS_MinLimit) - 12usize];
  ["Offset of field: ADL_DELAG_SETTINGS::GlobalLimitFPS_MaxLimit"]
    [::std::mem::offset_of!(ADL_DELAG_SETTINGS, GlobalLimitFPS_MaxLimit) - 16usize];
  ["Offset of field: ADL_DELAG_SETTINGS::GlobalLimitFPS_Step"]
    [::std::mem::offset_of!(ADL_DELAG_SETTINGS, GlobalLimitFPS_Step) - 20usize];
};
#[doc = "\n\\brief Structure containing information about BOOST Settings change reason\n\n  Elements of BOOST settings changed reason.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_BOOST_NOTFICATION_REASON {
  pub HotkeyChanged: ::std::os::raw::c_int,
  pub GlobalEnableChanged: ::std::os::raw::c_int,
  pub GlobalMinResChanged: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_BOOST_NOTFICATION_REASON"]
    [::std::mem::size_of::<ADL_BOOST_NOTFICATION_REASON>() - 12usize];
  ["Alignment of ADL_BOOST_NOTFICATION_REASON"]
    [::std::mem::align_of::<ADL_BOOST_NOTFICATION_REASON>() - 4usize];
  ["Offset of field: ADL_BOOST_NOTFICATION_REASON::HotkeyChanged"]
    [::std::mem::offset_of!(ADL_BOOST_NOTFICATION_REASON, HotkeyChanged) - 0usize];
  ["Offset of field: ADL_BOOST_NOTFICATION_REASON::GlobalEnableChanged"]
    [::std::mem::offset_of!(ADL_BOOST_NOTFICATION_REASON, GlobalEnableChanged) - 4usize];
  ["Offset of field: ADL_BOOST_NOTFICATION_REASON::GlobalMinResChanged"]
    [::std::mem::offset_of!(ADL_BOOST_NOTFICATION_REASON, GlobalMinResChanged) - 8usize];
};
#[doc = "\n\\brief Structure containing information about BOOST Settings\n\n  Elements of BOOST settings.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_BOOST_SETTINGS {
  pub Hotkey: ::std::os::raw::c_int,
  pub GlobalEnable: ::std::os::raw::c_int,
  pub GlobalMinRes: ::std::os::raw::c_int,
  pub GlobalMinRes_MinLimit: ::std::os::raw::c_int,
  pub GlobalMinRes_MaxLimit: ::std::os::raw::c_int,
  pub GlobalMinRes_Step: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_BOOST_SETTINGS"][::std::mem::size_of::<ADL_BOOST_SETTINGS>() - 24usize];
  ["Alignment of ADL_BOOST_SETTINGS"]
    [::std::mem::align_of::<ADL_BOOST_SETTINGS>() - 4usize];
  ["Offset of field: ADL_BOOST_SETTINGS::Hotkey"]
    [::std::mem::offset_of!(ADL_BOOST_SETTINGS, Hotkey) - 0usize];
  ["Offset of field: ADL_BOOST_SETTINGS::GlobalEnable"]
    [::std::mem::offset_of!(ADL_BOOST_SETTINGS, GlobalEnable) - 4usize];
  ["Offset of field: ADL_BOOST_SETTINGS::GlobalMinRes"]
    [::std::mem::offset_of!(ADL_BOOST_SETTINGS, GlobalMinRes) - 8usize];
  ["Offset of field: ADL_BOOST_SETTINGS::GlobalMinRes_MinLimit"]
    [::std::mem::offset_of!(ADL_BOOST_SETTINGS, GlobalMinRes_MinLimit) - 12usize];
  ["Offset of field: ADL_BOOST_SETTINGS::GlobalMinRes_MaxLimit"]
    [::std::mem::offset_of!(ADL_BOOST_SETTINGS, GlobalMinRes_MaxLimit) - 16usize];
  ["Offset of field: ADL_BOOST_SETTINGS::GlobalMinRes_Step"]
    [::std::mem::offset_of!(ADL_BOOST_SETTINGS, GlobalMinRes_Step) - 20usize];
};
#[doc = "\n\\brief Structure containing information about BOOST Settings\n\n  Elements of BOOST settings.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_BOOST_SETTINGSX2 {
  pub Hotkey: ::std::os::raw::c_int,
  pub GlobalEnable: ::std::os::raw::c_int,
  pub GlobalMinRes: ::std::os::raw::c_int,
  pub GlobalMinRes_MinLimit: ::std::os::raw::c_int,
  pub GlobalMinRes_MaxLimit: ::std::os::raw::c_int,
  pub GlobalMinRes_Step: ::std::os::raw::c_int,
  pub VsrSupported: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_BOOST_SETTINGSX2"]
    [::std::mem::size_of::<ADL_BOOST_SETTINGSX2>() - 28usize];
  ["Alignment of ADL_BOOST_SETTINGSX2"]
    [::std::mem::align_of::<ADL_BOOST_SETTINGSX2>() - 4usize];
  ["Offset of field: ADL_BOOST_SETTINGSX2::Hotkey"]
    [::std::mem::offset_of!(ADL_BOOST_SETTINGSX2, Hotkey) - 0usize];
  ["Offset of field: ADL_BOOST_SETTINGSX2::GlobalEnable"]
    [::std::mem::offset_of!(ADL_BOOST_SETTINGSX2, GlobalEnable) - 4usize];
  ["Offset of field: ADL_BOOST_SETTINGSX2::GlobalMinRes"]
    [::std::mem::offset_of!(ADL_BOOST_SETTINGSX2, GlobalMinRes) - 8usize];
  ["Offset of field: ADL_BOOST_SETTINGSX2::GlobalMinRes_MinLimit"]
    [::std::mem::offset_of!(ADL_BOOST_SETTINGSX2, GlobalMinRes_MinLimit) - 12usize];
  ["Offset of field: ADL_BOOST_SETTINGSX2::GlobalMinRes_MaxLimit"]
    [::std::mem::offset_of!(ADL_BOOST_SETTINGSX2, GlobalMinRes_MaxLimit) - 16usize];
  ["Offset of field: ADL_BOOST_SETTINGSX2::GlobalMinRes_Step"]
    [::std::mem::offset_of!(ADL_BOOST_SETTINGSX2, GlobalMinRes_Step) - 20usize];
  ["Offset of field: ADL_BOOST_SETTINGSX2::VsrSupported"]
    [::std::mem::offset_of!(ADL_BOOST_SETTINGSX2, VsrSupported) - 24usize];
};
#[doc = "\n\\brief Structure containing information about ProVSR Settings change reason\n\n  Elements of ProVSR settings changed reason.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_PROVSR_NOTFICATION_REASON {
  pub HotkeyChanged: ::std::os::raw::c_int,
  pub GlobalEnableChanged: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_PROVSR_NOTFICATION_REASON"]
    [::std::mem::size_of::<ADL_PROVSR_NOTFICATION_REASON>() - 8usize];
  ["Alignment of ADL_PROVSR_NOTFICATION_REASON"]
    [::std::mem::align_of::<ADL_PROVSR_NOTFICATION_REASON>() - 4usize];
  ["Offset of field: ADL_PROVSR_NOTFICATION_REASON::HotkeyChanged"]
    [::std::mem::offset_of!(ADL_PROVSR_NOTFICATION_REASON, HotkeyChanged) - 0usize];
  ["Offset of field: ADL_PROVSR_NOTFICATION_REASON::GlobalEnableChanged"]
    [::std::mem::offset_of!(ADL_PROVSR_NOTFICATION_REASON, GlobalEnableChanged) - 4usize];
};
#[doc = "\n\\brief Structure containing information about Pro VSR Settings\n\n  Elements of ProVSR settings.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_PROVSR_SETTINGS {
  pub Hotkey: ::std::os::raw::c_int,
  pub GlobalEnable: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_PROVSR_SETTINGS"][::std::mem::size_of::<ADL_PROVSR_SETTINGS>() - 8usize];
  ["Alignment of ADL_PROVSR_SETTINGS"]
    [::std::mem::align_of::<ADL_PROVSR_SETTINGS>() - 4usize];
  ["Offset of field: ADL_PROVSR_SETTINGS::Hotkey"]
    [::std::mem::offset_of!(ADL_PROVSR_SETTINGS, Hotkey) - 0usize];
  ["Offset of field: ADL_PROVSR_SETTINGS::GlobalEnable"]
    [::std::mem::offset_of!(ADL_PROVSR_SETTINGS, GlobalEnable) - 4usize];
};
#[doc = "\n\\brief Structure containing information about Image Boost(OGL) Settings change reason\n\n  Elements of Image Boost settings changed reason.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_IMAGE_BOOST_NOTFICATION_REASON {
  pub HotkeyChanged: ::std::os::raw::c_int,
  pub GlobalEnableChanged: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_IMAGE_BOOST_NOTFICATION_REASON"]
    [::std::mem::size_of::<ADL_IMAGE_BOOST_NOTFICATION_REASON>() - 8usize];
  ["Alignment of ADL_IMAGE_BOOST_NOTFICATION_REASON"]
    [::std::mem::align_of::<ADL_IMAGE_BOOST_NOTFICATION_REASON>() - 4usize];
  ["Offset of field: ADL_IMAGE_BOOST_NOTFICATION_REASON::HotkeyChanged"]
    [::std::mem::offset_of!(ADL_IMAGE_BOOST_NOTFICATION_REASON, HotkeyChanged) - 0usize];
  ["Offset of field: ADL_IMAGE_BOOST_NOTFICATION_REASON::GlobalEnableChanged"][::std::mem::offset_of!(
    ADL_IMAGE_BOOST_NOTFICATION_REASON,
    GlobalEnableChanged
  )
    - 4usize];
};
#[doc = "\n\\brief Structure containing information about OGL IMAGE BOOST Settings\n\n  Elements of OGL IMAGE BOOST settings.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_IMAGE_BOOST_SETTINGS {
  pub Hotkey: ::std::os::raw::c_int,
  pub GlobalEnable: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_IMAGE_BOOST_SETTINGS"]
    [::std::mem::size_of::<ADL_IMAGE_BOOST_SETTINGS>() - 8usize];
  ["Alignment of ADL_IMAGE_BOOST_SETTINGS"]
    [::std::mem::align_of::<ADL_IMAGE_BOOST_SETTINGS>() - 4usize];
  ["Offset of field: ADL_IMAGE_BOOST_SETTINGS::Hotkey"]
    [::std::mem::offset_of!(ADL_IMAGE_BOOST_SETTINGS, Hotkey) - 0usize];
  ["Offset of field: ADL_IMAGE_BOOST_SETTINGS::GlobalEnable"]
    [::std::mem::offset_of!(ADL_IMAGE_BOOST_SETTINGS, GlobalEnable) - 4usize];
};
#[doc = "\n\\brief Structure containing information about RIS Settings change reason\n\n  Elements of RIS settings changed reason.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_RIS_NOTFICATION_REASON {
  pub GlobalEnableChanged: ::std::os::raw::c_uint,
  pub GlobalSharpeningDegreeChanged: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_RIS_NOTFICATION_REASON"]
    [::std::mem::size_of::<ADL_RIS_NOTFICATION_REASON>() - 8usize];
  ["Alignment of ADL_RIS_NOTFICATION_REASON"]
    [::std::mem::align_of::<ADL_RIS_NOTFICATION_REASON>() - 4usize];
  ["Offset of field: ADL_RIS_NOTFICATION_REASON::GlobalEnableChanged"]
    [::std::mem::offset_of!(ADL_RIS_NOTFICATION_REASON, GlobalEnableChanged) - 0usize];
  ["Offset of field: ADL_RIS_NOTFICATION_REASON::GlobalSharpeningDegreeChanged"][::std::mem::offset_of!(
    ADL_RIS_NOTFICATION_REASON,
    GlobalSharpeningDegreeChanged
  )
    - 4usize];
};
#[doc = "\n\\brief Structure containing information about RIS Settings\n\n  Elements of RIS settings.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_RIS_SETTINGS {
  pub GlobalEnable: ::std::os::raw::c_int,
  pub GlobalSharpeningDegree: ::std::os::raw::c_int,
  pub GlobalSharpeningDegree_MinLimit: ::std::os::raw::c_int,
  pub GlobalSharpeningDegree_MaxLimit: ::std::os::raw::c_int,
  pub GlobalSharpeningDegree_Step: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_RIS_SETTINGS"][::std::mem::size_of::<ADL_RIS_SETTINGS>() - 20usize];
  ["Alignment of ADL_RIS_SETTINGS"][::std::mem::align_of::<ADL_RIS_SETTINGS>() - 4usize];
  ["Offset of field: ADL_RIS_SETTINGS::GlobalEnable"]
    [::std::mem::offset_of!(ADL_RIS_SETTINGS, GlobalEnable) - 0usize];
  ["Offset of field: ADL_RIS_SETTINGS::GlobalSharpeningDegree"]
    [::std::mem::offset_of!(ADL_RIS_SETTINGS, GlobalSharpeningDegree) - 4usize];
  ["Offset of field: ADL_RIS_SETTINGS::GlobalSharpeningDegree_MinLimit"]
    [::std::mem::offset_of!(ADL_RIS_SETTINGS, GlobalSharpeningDegree_MinLimit) - 8usize];
  ["Offset of field: ADL_RIS_SETTINGS::GlobalSharpeningDegree_MaxLimit"]
    [::std::mem::offset_of!(ADL_RIS_SETTINGS, GlobalSharpeningDegree_MaxLimit) - 12usize];
  ["Offset of field: ADL_RIS_SETTINGS::GlobalSharpeningDegree_Step"]
    [::std::mem::offset_of!(ADL_RIS_SETTINGS, GlobalSharpeningDegree_Step) - 16usize];
};
#[doc = "\n\\brief Structure containing information about CHILL Settings change reason\n\n  Elements of Chiil settings changed reason.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_CHILL_NOTFICATION_REASON {
  pub HotkeyChanged: ::std::os::raw::c_int,
  pub GlobalEnableChanged: ::std::os::raw::c_int,
  pub GlobalMinFPSChanged: ::std::os::raw::c_int,
  pub GlobalMaxFPSChanged: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_CHILL_NOTFICATION_REASON"]
    [::std::mem::size_of::<ADL_CHILL_NOTFICATION_REASON>() - 16usize];
  ["Alignment of ADL_CHILL_NOTFICATION_REASON"]
    [::std::mem::align_of::<ADL_CHILL_NOTFICATION_REASON>() - 4usize];
  ["Offset of field: ADL_CHILL_NOTFICATION_REASON::HotkeyChanged"]
    [::std::mem::offset_of!(ADL_CHILL_NOTFICATION_REASON, HotkeyChanged) - 0usize];
  ["Offset of field: ADL_CHILL_NOTFICATION_REASON::GlobalEnableChanged"]
    [::std::mem::offset_of!(ADL_CHILL_NOTFICATION_REASON, GlobalEnableChanged) - 4usize];
  ["Offset of field: ADL_CHILL_NOTFICATION_REASON::GlobalMinFPSChanged"]
    [::std::mem::offset_of!(ADL_CHILL_NOTFICATION_REASON, GlobalMinFPSChanged) - 8usize];
  ["Offset of field: ADL_CHILL_NOTFICATION_REASON::GlobalMaxFPSChanged"]
    [::std::mem::offset_of!(ADL_CHILL_NOTFICATION_REASON, GlobalMaxFPSChanged) - 12usize];
};
#[doc = "\n\\brief Structure containing information about CHILL Settings\n\n  Elements of Chill settings.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_CHILL_SETTINGS {
  pub Hotkey: ::std::os::raw::c_int,
  pub GlobalEnable: ::std::os::raw::c_int,
  pub GlobalMinFPS: ::std::os::raw::c_int,
  pub GlobalMaxFPS: ::std::os::raw::c_int,
  pub GlobalFPS_MinLimit: ::std::os::raw::c_int,
  pub GlobalFPS_MaxLimit: ::std::os::raw::c_int,
  pub GlobalFPS_Step: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_CHILL_SETTINGS"][::std::mem::size_of::<ADL_CHILL_SETTINGS>() - 28usize];
  ["Alignment of ADL_CHILL_SETTINGS"]
    [::std::mem::align_of::<ADL_CHILL_SETTINGS>() - 4usize];
  ["Offset of field: ADL_CHILL_SETTINGS::Hotkey"]
    [::std::mem::offset_of!(ADL_CHILL_SETTINGS, Hotkey) - 0usize];
  ["Offset of field: ADL_CHILL_SETTINGS::GlobalEnable"]
    [::std::mem::offset_of!(ADL_CHILL_SETTINGS, GlobalEnable) - 4usize];
  ["Offset of field: ADL_CHILL_SETTINGS::GlobalMinFPS"]
    [::std::mem::offset_of!(ADL_CHILL_SETTINGS, GlobalMinFPS) - 8usize];
  ["Offset of field: ADL_CHILL_SETTINGS::GlobalMaxFPS"]
    [::std::mem::offset_of!(ADL_CHILL_SETTINGS, GlobalMaxFPS) - 12usize];
  ["Offset of field: ADL_CHILL_SETTINGS::GlobalFPS_MinLimit"]
    [::std::mem::offset_of!(ADL_CHILL_SETTINGS, GlobalFPS_MinLimit) - 16usize];
  ["Offset of field: ADL_CHILL_SETTINGS::GlobalFPS_MaxLimit"]
    [::std::mem::offset_of!(ADL_CHILL_SETTINGS, GlobalFPS_MaxLimit) - 20usize];
  ["Offset of field: ADL_CHILL_SETTINGS::GlobalFPS_Step"]
    [::std::mem::offset_of!(ADL_CHILL_SETTINGS, GlobalFPS_Step) - 24usize];
};
#[doc = "\n\\brief Structure containing information about DRIVERUPSCALE Settings change reason\n\n  Elements of DRIVERUPSCALE settings changed reason.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_DRIVERUPSCALE_NOTFICATION_REASON {
  pub ModeOverrideEnabledChanged: ::std::os::raw::c_int,
  pub GlobalEnabledChanged: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_DRIVERUPSCALE_NOTFICATION_REASON"]
    [::std::mem::size_of::<ADL_DRIVERUPSCALE_NOTFICATION_REASON>() - 8usize];
  ["Alignment of ADL_DRIVERUPSCALE_NOTFICATION_REASON"]
    [::std::mem::align_of::<ADL_DRIVERUPSCALE_NOTFICATION_REASON>() - 4usize];
  ["Offset of field: ADL_DRIVERUPSCALE_NOTFICATION_REASON::ModeOverrideEnabledChanged"][::std::mem::offset_of!(
    ADL_DRIVERUPSCALE_NOTFICATION_REASON,
    ModeOverrideEnabledChanged
  )
    - 0usize];
  ["Offset of field: ADL_DRIVERUPSCALE_NOTFICATION_REASON::GlobalEnabledChanged"][::std::mem::offset_of!(
    ADL_DRIVERUPSCALE_NOTFICATION_REASON,
    GlobalEnabledChanged
  )
    - 4usize];
};
#[doc = "\n\\brief Structure containing information about DRIVERUPSCALE Settings\n\n  Elements of DRIVERUPSCALE settings.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_DRIVERUPSCALE_SETTINGS {
  pub ModeOverrideEnabled: ::std::os::raw::c_int,
  pub GlobalEnabled: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_DRIVERUPSCALE_SETTINGS"]
    [::std::mem::size_of::<ADL_DRIVERUPSCALE_SETTINGS>() - 8usize];
  ["Alignment of ADL_DRIVERUPSCALE_SETTINGS"]
    [::std::mem::align_of::<ADL_DRIVERUPSCALE_SETTINGS>() - 4usize];
  ["Offset of field: ADL_DRIVERUPSCALE_SETTINGS::ModeOverrideEnabled"]
    [::std::mem::offset_of!(ADL_DRIVERUPSCALE_SETTINGS, ModeOverrideEnabled) - 0usize];
  ["Offset of field: ADL_DRIVERUPSCALE_SETTINGS::GlobalEnabled"]
    [::std::mem::offset_of!(ADL_DRIVERUPSCALE_SETTINGS, GlobalEnabled) - 4usize];
};
#[doc = "\n\\brief  Structure Containing R G B values for Radeon USB LED Bar\n\n Elements of RGB Values.\n \\nosubgrouping\n"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ADL_RADEON_LED_COLOR_CONFIG {
  pub _bitfield_align_1: [u8; 0],
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
  pub __bindgen_padding_0: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_RADEON_LED_COLOR_CONFIG"]
    [::std::mem::size_of::<ADL_RADEON_LED_COLOR_CONFIG>() - 4usize];
  ["Alignment of ADL_RADEON_LED_COLOR_CONFIG"]
    [::std::mem::align_of::<ADL_RADEON_LED_COLOR_CONFIG>() - 2usize];
};
impl ADL_RADEON_LED_COLOR_CONFIG {
  #[inline]
  pub fn R(&self) -> ::std::os::raw::c_ushort {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
  }
  #[inline]
  pub fn set_R(&mut self, val: ::std::os::raw::c_ushort) {
    unsafe {
      let val: u16 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 8u8, val as u64)
    }
  }
  #[inline]
  pub unsafe fn R_raw(this: *const Self) -> ::std::os::raw::c_ushort {
    unsafe {
      ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
        ::std::ptr::addr_of!((*this)._bitfield_1),
        0usize,
        8u8,
      ) as u16)
    }
  }
  #[inline]
  pub unsafe fn set_R_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
    unsafe {
      let val: u16 = ::std::mem::transmute(val);
      <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
        0usize,
        8u8,
        val as u64,
      )
    }
  }
  #[inline]
  pub fn G(&self) -> ::std::os::raw::c_ushort {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
  }
  #[inline]
  pub fn set_G(&mut self, val: ::std::os::raw::c_ushort) {
    unsafe {
      let val: u16 = ::std::mem::transmute(val);
      self._bitfield_1.set(8usize, 8u8, val as u64)
    }
  }
  #[inline]
  pub unsafe fn G_raw(this: *const Self) -> ::std::os::raw::c_ushort {
    unsafe {
      ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
        ::std::ptr::addr_of!((*this)._bitfield_1),
        8usize,
        8u8,
      ) as u16)
    }
  }
  #[inline]
  pub unsafe fn set_G_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
    unsafe {
      let val: u16 = ::std::mem::transmute(val);
      <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
        8usize,
        8u8,
        val as u64,
      )
    }
  }
  #[inline]
  pub fn B(&self) -> ::std::os::raw::c_ushort {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u16) }
  }
  #[inline]
  pub fn set_B(&mut self, val: ::std::os::raw::c_ushort) {
    unsafe {
      let val: u16 = ::std::mem::transmute(val);
      self._bitfield_1.set(16usize, 8u8, val as u64)
    }
  }
  #[inline]
  pub unsafe fn B_raw(this: *const Self) -> ::std::os::raw::c_ushort {
    unsafe {
      ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
        ::std::ptr::addr_of!((*this)._bitfield_1),
        16usize,
        8u8,
      ) as u16)
    }
  }
  #[inline]
  pub unsafe fn set_B_raw(this: *mut Self, val: ::std::os::raw::c_ushort) {
    unsafe {
      let val: u16 = ::std::mem::transmute(val);
      <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
        16usize,
        8u8,
        val as u64,
      )
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    R: ::std::os::raw::c_ushort,
    G: ::std::os::raw::c_ushort,
    B: ::std::os::raw::c_ushort,
  ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> =
      Default::default();
    __bindgen_bitfield_unit.set(0usize, 8u8, {
      let R: u16 = unsafe { ::std::mem::transmute(R) };
      R as u64
    });
    __bindgen_bitfield_unit.set(8usize, 8u8, {
      let G: u16 = unsafe { ::std::mem::transmute(G) };
      G as u64
    });
    __bindgen_bitfield_unit.set(16usize, 8u8, {
      let B: u16 = unsafe { ::std::mem::transmute(B) };
      B as u64
    });
    __bindgen_bitfield_unit
  }
}
#[doc = "\n\\brief Structure Containing All Generic LED configuration for user requested LED pattern. The driver will apply the confgiuration as requested\n\n  Elements of Radeon USB LED configuration.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_RADEON_LED_PATTERN_CONFIG_GENERIC {
  pub _bitfield_align_1: [u8; 0],
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
  pub directionCounterClockWise: ::std::os::raw::c_int,
  pub colorConfig: ADL_RADEON_LED_COLOR_CONFIG,
  pub morseCodeText: [::std::os::raw::c_char; 260usize],
  pub morseCodeTextOutPut: [::std::os::raw::c_char; 260usize],
  pub morseCodeTextOutPutLen: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_RADEON_LED_PATTERN_CONFIG_GENERIC"]
    [::std::mem::size_of::<ADL_RADEON_LED_PATTERN_CONFIG_GENERIC>() - 536usize];
  ["Alignment of ADL_RADEON_LED_PATTERN_CONFIG_GENERIC"]
    [::std::mem::align_of::<ADL_RADEON_LED_PATTERN_CONFIG_GENERIC>() - 4usize];
  ["Offset of field: ADL_RADEON_LED_PATTERN_CONFIG_GENERIC::directionCounterClockWise"][::std::mem::offset_of!(
    ADL_RADEON_LED_PATTERN_CONFIG_GENERIC,
    directionCounterClockWise
  )
    - 4usize];
  ["Offset of field: ADL_RADEON_LED_PATTERN_CONFIG_GENERIC::colorConfig"]
    [::std::mem::offset_of!(ADL_RADEON_LED_PATTERN_CONFIG_GENERIC, colorConfig) - 8usize];
  ["Offset of field: ADL_RADEON_LED_PATTERN_CONFIG_GENERIC::morseCodeText"][::std::mem::offset_of!(
    ADL_RADEON_LED_PATTERN_CONFIG_GENERIC,
    morseCodeText
  ) - 12usize];
  ["Offset of field: ADL_RADEON_LED_PATTERN_CONFIG_GENERIC::morseCodeTextOutPut"][::std::mem::offset_of!(
    ADL_RADEON_LED_PATTERN_CONFIG_GENERIC,
    morseCodeTextOutPut
  )
    - 272usize];
  ["Offset of field: ADL_RADEON_LED_PATTERN_CONFIG_GENERIC::morseCodeTextOutPutLen"][::std::mem::offset_of!(
    ADL_RADEON_LED_PATTERN_CONFIG_GENERIC,
    morseCodeTextOutPutLen
  )
    - 532usize];
};
impl ADL_RADEON_LED_PATTERN_CONFIG_GENERIC {
  #[inline]
  pub fn brightness(&self) -> ::std::os::raw::c_short {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
  }
  #[inline]
  pub fn set_brightness(&mut self, val: ::std::os::raw::c_short) {
    unsafe {
      let val: u16 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 8u8, val as u64)
    }
  }
  #[inline]
  pub unsafe fn brightness_raw(this: *const Self) -> ::std::os::raw::c_short {
    unsafe {
      ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
        ::std::ptr::addr_of!((*this)._bitfield_1),
        0usize,
        8u8,
      ) as u16)
    }
  }
  #[inline]
  pub unsafe fn set_brightness_raw(this: *mut Self, val: ::std::os::raw::c_short) {
    unsafe {
      let val: u16 = ::std::mem::transmute(val);
      <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
        0usize,
        8u8,
        val as u64,
      )
    }
  }
  #[inline]
  pub fn speed(&self) -> ::std::os::raw::c_short {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
  }
  #[inline]
  pub fn set_speed(&mut self, val: ::std::os::raw::c_short) {
    unsafe {
      let val: u16 = ::std::mem::transmute(val);
      self._bitfield_1.set(8usize, 8u8, val as u64)
    }
  }
  #[inline]
  pub unsafe fn speed_raw(this: *const Self) -> ::std::os::raw::c_short {
    unsafe {
      ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
        ::std::ptr::addr_of!((*this)._bitfield_1),
        8usize,
        8u8,
      ) as u16)
    }
  }
  #[inline]
  pub unsafe fn set_speed_raw(this: *mut Self, val: ::std::os::raw::c_short) {
    unsafe {
      let val: u16 = ::std::mem::transmute(val);
      <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
        8usize,
        8u8,
        val as u64,
      )
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    brightness: ::std::os::raw::c_short,
    speed: ::std::os::raw::c_short,
  ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> =
      Default::default();
    __bindgen_bitfield_unit.set(0usize, 8u8, {
      let brightness: u16 = unsafe { ::std::mem::transmute(brightness) };
      brightness as u64
    });
    __bindgen_bitfield_unit.set(8usize, 8u8, {
      let speed: u16 = unsafe { ::std::mem::transmute(speed) };
      speed as u64
    });
    __bindgen_bitfield_unit
  }
}
#[doc = "\n\\brief Structure Containing All custom grid pattern LED configuration for user requested LED grid pattern. The driver will apply the confgiuration as requested\n\n  Elements of Radeon USB LED custom grid configuration.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_RADEON_LED_CUSTOM_LED_CONFIG {
  pub _bitfield_align_1: [u8; 0],
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
  pub colorConfig: [[ADL_RADEON_LED_COLOR_CONFIG; 24usize]; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_RADEON_LED_CUSTOM_LED_CONFIG"]
    [::std::mem::size_of::<ADL_RADEON_LED_CUSTOM_LED_CONFIG>() - 674usize];
  ["Alignment of ADL_RADEON_LED_CUSTOM_LED_CONFIG"]
    [::std::mem::align_of::<ADL_RADEON_LED_CUSTOM_LED_CONFIG>() - 2usize];
  ["Offset of field: ADL_RADEON_LED_CUSTOM_LED_CONFIG::colorConfig"]
    [::std::mem::offset_of!(ADL_RADEON_LED_CUSTOM_LED_CONFIG, colorConfig) - 2usize];
};
impl ADL_RADEON_LED_CUSTOM_LED_CONFIG {
  #[inline]
  pub fn brightness(&self) -> ::std::os::raw::c_short {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
  }
  #[inline]
  pub fn set_brightness(&mut self, val: ::std::os::raw::c_short) {
    unsafe {
      let val: u16 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 8u8, val as u64)
    }
  }
  #[inline]
  pub unsafe fn brightness_raw(this: *const Self) -> ::std::os::raw::c_short {
    unsafe {
      ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
        ::std::ptr::addr_of!((*this)._bitfield_1),
        0usize,
        8u8,
      ) as u16)
    }
  }
  #[inline]
  pub unsafe fn set_brightness_raw(this: *mut Self, val: ::std::os::raw::c_short) {
    unsafe {
      let val: u16 = ::std::mem::transmute(val);
      <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
        0usize,
        8u8,
        val as u64,
      )
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    brightness: ::std::os::raw::c_short,
  ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
      Default::default();
    __bindgen_bitfield_unit.set(0usize, 8u8, {
      let brightness: u16 = unsafe { ::std::mem::transmute(brightness) };
      brightness as u64
    });
    __bindgen_bitfield_unit
  }
}
#[doc = "\n\\brief Structure Containing All custom grid pattern LED configuration for user requested LED grid pattern. The driver will apply the confgiuration as requested\n\n  Elements of Radeon USB LED custom grid configuration.\n \\nosubgrouping\n"]
pub type ADL_RADEON_LED_CUSTOM_GRID_LED_CONFIG = ADL_RADEON_LED_CUSTOM_LED_CONFIG;
#[doc = "\n\\brief Structure Containing All Radeon USB LED requests and controls.\n\n Elements of Radeon USB LED Controls.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ADL_RADEON_LED_PATTERN_CONFIG {
  pub control: ADL_RADEON_USB_LED_BAR_CONTROLS,
  pub __bindgen_anon_1: ADL_RADEON_LED_PATTERN_CONFIG__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADL_RADEON_LED_PATTERN_CONFIG__bindgen_ty_1 {
  pub genericPararmeters: ADL_RADEON_LED_PATTERN_CONFIG_GENERIC,
  pub customGridConfig: ADL_RADEON_LED_CUSTOM_GRID_LED_CONFIG,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_RADEON_LED_PATTERN_CONFIG__bindgen_ty_1"]
    [::std::mem::size_of::<ADL_RADEON_LED_PATTERN_CONFIG__bindgen_ty_1>() - 676usize];
  ["Alignment of ADL_RADEON_LED_PATTERN_CONFIG__bindgen_ty_1"]
    [::std::mem::align_of::<ADL_RADEON_LED_PATTERN_CONFIG__bindgen_ty_1>() - 4usize];
  ["Offset of field: ADL_RADEON_LED_PATTERN_CONFIG__bindgen_ty_1::genericPararmeters"][::std::mem::offset_of!(
    ADL_RADEON_LED_PATTERN_CONFIG__bindgen_ty_1,
    genericPararmeters
  )
    - 0usize];
  ["Offset of field: ADL_RADEON_LED_PATTERN_CONFIG__bindgen_ty_1::customGridConfig"][::std::mem::offset_of!(
    ADL_RADEON_LED_PATTERN_CONFIG__bindgen_ty_1,
    customGridConfig
  )
    - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_RADEON_LED_PATTERN_CONFIG"]
    [::std::mem::size_of::<ADL_RADEON_LED_PATTERN_CONFIG>() - 680usize];
  ["Alignment of ADL_RADEON_LED_PATTERN_CONFIG"]
    [::std::mem::align_of::<ADL_RADEON_LED_PATTERN_CONFIG>() - 4usize];
  ["Offset of field: ADL_RADEON_LED_PATTERN_CONFIG::control"]
    [::std::mem::offset_of!(ADL_RADEON_LED_PATTERN_CONFIG, control) - 0usize];
};
#[doc = "\n\\brief Structure containing information about the graphics adapter with extended caps\n\n This structure is used to store various information about the graphics adapter.  This\n information can be returned to the user. Alternatively, it can be used to access various driver calls to set\n or fetch various settings upon the user's request.\n This AdapterInfoX2 struct extends the AdapterInfo struct in adl_structures.h\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AdapterInfoX2 {
  #[doc = " Size of the structure."]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " The ADL index handle. One GPU may be associated with one or two index handles"]
  pub iAdapterIndex: ::std::os::raw::c_int,
  #[doc = " The unique device ID associated with this adapter."]
  pub strUDID: [::std::os::raw::c_char; 256usize],
  #[doc = " The BUS number associated with this adapter."]
  pub iBusNumber: ::std::os::raw::c_int,
  #[doc = " The driver number associated with this adapter."]
  pub iDeviceNumber: ::std::os::raw::c_int,
  #[doc = " The function number."]
  pub iFunctionNumber: ::std::os::raw::c_int,
  #[doc = " The vendor ID associated with this adapter."]
  pub iVendorID: ::std::os::raw::c_int,
  #[doc = " Adapter name."]
  pub strAdapterName: [::std::os::raw::c_char; 256usize],
  #[doc = " Display name. For example, \"\\\\\\\\Display0\""]
  pub strDisplayName: [::std::os::raw::c_char; 256usize],
  #[doc = " Present or not; 1 if present and 0 if not present.It the logical adapter is present, the display name such as \\\\\\\\.\\\\Display1 can be found from OS"]
  pub iPresent: ::std::os::raw::c_int,
  #[doc = " Exist or not; 1 is exist and 0 is not present."]
  pub iExist: ::std::os::raw::c_int,
  #[doc = " Driver registry path."]
  pub strDriverPath: [::std::os::raw::c_char; 256usize],
  #[doc = " Driver registry path Ext for."]
  pub strDriverPathExt: [::std::os::raw::c_char; 256usize],
  #[doc = " PNP string from Windows."]
  pub strPNPString: [::std::os::raw::c_char; 256usize],
  #[doc = " It is generated from EnumDisplayDevices."]
  pub iOSDisplayIndex: ::std::os::raw::c_int,
  #[doc = " The bit mask identifies the adapter info"]
  pub iInfoMask: ::std::os::raw::c_int,
  #[doc = " The bit identifies the adapter info \\ref define_adapter_info"]
  pub iInfoValue: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of AdapterInfoX2"][::std::mem::size_of::<AdapterInfoX2>() - 1580usize];
  ["Alignment of AdapterInfoX2"][::std::mem::align_of::<AdapterInfoX2>() - 4usize];
  ["Offset of field: AdapterInfoX2::iSize"]
    [::std::mem::offset_of!(AdapterInfoX2, iSize) - 0usize];
  ["Offset of field: AdapterInfoX2::iAdapterIndex"]
    [::std::mem::offset_of!(AdapterInfoX2, iAdapterIndex) - 4usize];
  ["Offset of field: AdapterInfoX2::strUDID"]
    [::std::mem::offset_of!(AdapterInfoX2, strUDID) - 8usize];
  ["Offset of field: AdapterInfoX2::iBusNumber"]
    [::std::mem::offset_of!(AdapterInfoX2, iBusNumber) - 264usize];
  ["Offset of field: AdapterInfoX2::iDeviceNumber"]
    [::std::mem::offset_of!(AdapterInfoX2, iDeviceNumber) - 268usize];
  ["Offset of field: AdapterInfoX2::iFunctionNumber"]
    [::std::mem::offset_of!(AdapterInfoX2, iFunctionNumber) - 272usize];
  ["Offset of field: AdapterInfoX2::iVendorID"]
    [::std::mem::offset_of!(AdapterInfoX2, iVendorID) - 276usize];
  ["Offset of field: AdapterInfoX2::strAdapterName"]
    [::std::mem::offset_of!(AdapterInfoX2, strAdapterName) - 280usize];
  ["Offset of field: AdapterInfoX2::strDisplayName"]
    [::std::mem::offset_of!(AdapterInfoX2, strDisplayName) - 536usize];
  ["Offset of field: AdapterInfoX2::iPresent"]
    [::std::mem::offset_of!(AdapterInfoX2, iPresent) - 792usize];
  ["Offset of field: AdapterInfoX2::iExist"]
    [::std::mem::offset_of!(AdapterInfoX2, iExist) - 796usize];
  ["Offset of field: AdapterInfoX2::strDriverPath"]
    [::std::mem::offset_of!(AdapterInfoX2, strDriverPath) - 800usize];
  ["Offset of field: AdapterInfoX2::strDriverPathExt"]
    [::std::mem::offset_of!(AdapterInfoX2, strDriverPathExt) - 1056usize];
  ["Offset of field: AdapterInfoX2::strPNPString"]
    [::std::mem::offset_of!(AdapterInfoX2, strPNPString) - 1312usize];
  ["Offset of field: AdapterInfoX2::iOSDisplayIndex"]
    [::std::mem::offset_of!(AdapterInfoX2, iOSDisplayIndex) - 1568usize];
  ["Offset of field: AdapterInfoX2::iInfoMask"]
    [::std::mem::offset_of!(AdapterInfoX2, iInfoMask) - 1572usize];
  ["Offset of field: AdapterInfoX2::iInfoValue"]
    [::std::mem::offset_of!(AdapterInfoX2, iInfoValue) - 1576usize];
};
#[doc = "\n\\brief Structure containing information about the graphics adapter with extended caps\n\n This structure is used to store various information about the graphics adapter.  This\n information can be returned to the user. Alternatively, it can be used to access various driver calls to set\n or fetch various settings upon the user's request.\n This AdapterInfoX2 struct extends the AdapterInfo struct in adl_structures.h\n \\nosubgrouping\n"]
pub type LPAdapterInfoX2 = *mut AdapterInfoX2;
#[doc = "\n\\brief Structure containing information about driver  gamut space , whether it is related to source or to destination, overlay or graphics\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLGamutReference {
  #[doc = " mask whether it is related to source or to destination, overlay or graphics"]
  pub iGamutRef: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLGamutReference"][::std::mem::size_of::<ADLGamutReference>() - 4usize];
  ["Alignment of ADLGamutReference"]
    [::std::mem::align_of::<ADLGamutReference>() - 4usize];
  ["Offset of field: ADLGamutReference::iGamutRef"]
    [::std::mem::offset_of!(ADLGamutReference, iGamutRef) - 0usize];
};
#[doc = "\n\\brief Structure containing information about driver supported gamut spaces , capability method\n\n This structure is used to get driver all supported gamut spaces\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLGamutInfo {
  #[doc = "Any combination of following ADL_GAMUT_SPACE_CCIR_709 - ADL_GAMUT_SPACE_CUSTOM"]
  pub SupportedGamutSpace: ::std::os::raw::c_int,
  #[doc = "Any combination of following ADL_WHITE_POINT_5000K - ADL_WHITE_POINT_CUSTOM"]
  pub SupportedWhitePoint: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLGamutInfo"][::std::mem::size_of::<ADLGamutInfo>() - 8usize];
  ["Alignment of ADLGamutInfo"][::std::mem::align_of::<ADLGamutInfo>() - 4usize];
  ["Offset of field: ADLGamutInfo::SupportedGamutSpace"]
    [::std::mem::offset_of!(ADLGamutInfo, SupportedGamutSpace) - 0usize];
  ["Offset of field: ADLGamutInfo::SupportedWhitePoint"]
    [::std::mem::offset_of!(ADLGamutInfo, SupportedWhitePoint) - 4usize];
};
#[doc = "\n\\brief Structure containing information about driver point coordinates\n\n This structure is used to store the driver point coodinates for gamut and white point\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLPoint {
  #[doc = " x coordinate"]
  pub iX: ::std::os::raw::c_int,
  #[doc = " y coordinate"]
  pub iY: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLPoint"][::std::mem::size_of::<ADLPoint>() - 8usize];
  ["Alignment of ADLPoint"][::std::mem::align_of::<ADLPoint>() - 4usize];
  ["Offset of field: ADLPoint::iX"][::std::mem::offset_of!(ADLPoint, iX) - 0usize];
  ["Offset of field: ADLPoint::iY"][::std::mem::offset_of!(ADLPoint, iY) - 4usize];
};
#[doc = "\n\\brief Structure containing information about driver supported gamut coordinates\n\n This structure is used to store the driver supported supported gamut coordinates\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLGamutCoordinates {
  #[doc = " red channel chromasity coordinate"]
  pub Red: ADLPoint,
  #[doc = " green channel chromasity coordinate"]
  pub Green: ADLPoint,
  #[doc = " blue channel chromasity coordinate"]
  pub Blue: ADLPoint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLGamutCoordinates"][::std::mem::size_of::<ADLGamutCoordinates>() - 24usize];
  ["Alignment of ADLGamutCoordinates"]
    [::std::mem::align_of::<ADLGamutCoordinates>() - 4usize];
  ["Offset of field: ADLGamutCoordinates::Red"]
    [::std::mem::offset_of!(ADLGamutCoordinates, Red) - 0usize];
  ["Offset of field: ADLGamutCoordinates::Green"]
    [::std::mem::offset_of!(ADLGamutCoordinates, Green) - 8usize];
  ["Offset of field: ADLGamutCoordinates::Blue"]
    [::std::mem::offset_of!(ADLGamutCoordinates, Blue) - 16usize];
};
#[doc = "\n\\brief Structure containing information about driver current gamut space , parent struct for ADLGamutCoordinates and ADLWhitePoint\n This structure is used to get/set driver supported gamut space\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLGamutData {
  #[doc = "used as mask and could be 4 options\nBIT_0 If flag ADL_GAMUT_REFERENCE_SOURCE is asserted set operation is related to gamut source ,\nif not gamut destination\nBIT_1 If flag ADL_GAMUT_GAMUT_VIDEO_CONTENT is asserted\nBIT_2,BIT_3 used as mask and could be 4 options custom (2) + predefined (2)\n0.  Gamut predefined,        white point predefined -> 0                | 0\n1.  Gamut predefined,        white point custom     -> 0                | ADL_CUSTOM_WHITE_POINT\n2.  White point predefined,  gamut custom           -> 0                | ADL_CUSTOM_GAMUT\n3.  White point custom,      gamut custom           -> ADL_CUSTOM_GAMUT | ADL_CUSTOM_WHITE_POINT"]
  pub iFeature: ::std::os::raw::c_int,
  #[doc = "one of ADL_GAMUT_SPACE_CCIR_709 - ADL_GAMUT_SPACE_CIE_RGB"]
  pub iPredefinedGamut: ::std::os::raw::c_int,
  #[doc = "one of ADL_WHITE_POINT_5000K - ADL_WHITE_POINT_9300K"]
  pub iPredefinedWhitePoint: ::std::os::raw::c_int,
  #[doc = "valid when in mask avails ADL_CUSTOM_WHITE_POINT"]
  pub CustomWhitePoint: ADLPoint,
  #[doc = "valid when in mask avails ADL_CUSTOM_GAMUT"]
  pub CustomGamut: ADLGamutCoordinates,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLGamutData"][::std::mem::size_of::<ADLGamutData>() - 44usize];
  ["Alignment of ADLGamutData"][::std::mem::align_of::<ADLGamutData>() - 4usize];
  ["Offset of field: ADLGamutData::iFeature"]
    [::std::mem::offset_of!(ADLGamutData, iFeature) - 0usize];
  ["Offset of field: ADLGamutData::iPredefinedGamut"]
    [::std::mem::offset_of!(ADLGamutData, iPredefinedGamut) - 4usize];
  ["Offset of field: ADLGamutData::iPredefinedWhitePoint"]
    [::std::mem::offset_of!(ADLGamutData, iPredefinedWhitePoint) - 8usize];
  ["Offset of field: ADLGamutData::CustomWhitePoint"]
    [::std::mem::offset_of!(ADLGamutData, CustomWhitePoint) - 12usize];
  ["Offset of field: ADLGamutData::CustomGamut"]
    [::std::mem::offset_of!(ADLGamutData, CustomGamut) - 20usize];
};
#[doc = "\n\\brief Structure containing detailed timing parameters.\n\n This structure is used to store the detailed timing parameters.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDetailedTimingX2 {
  #[doc = " Size of the structure."]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " Timing flags. \\ref define_detailed_timing_flags"]
  pub sTimingFlags: ::std::os::raw::c_int,
  #[doc = " Total width (columns)."]
  pub sHTotal: ::std::os::raw::c_int,
  #[doc = " Displayed width."]
  pub sHDisplay: ::std::os::raw::c_int,
  #[doc = " Horizontal sync signal offset."]
  pub sHSyncStart: ::std::os::raw::c_int,
  #[doc = " Horizontal sync signal width."]
  pub sHSyncWidth: ::std::os::raw::c_int,
  #[doc = " Total height (rows)."]
  pub sVTotal: ::std::os::raw::c_int,
  #[doc = " Displayed height."]
  pub sVDisplay: ::std::os::raw::c_int,
  #[doc = " Vertical sync signal offset."]
  pub sVSyncStart: ::std::os::raw::c_int,
  #[doc = " Vertical sync signal width."]
  pub sVSyncWidth: ::std::os::raw::c_int,
  #[doc = " Pixel clock value."]
  pub sPixelClock: ::std::os::raw::c_int,
  #[doc = " Overscan right."]
  pub sHOverscanRight: ::std::os::raw::c_short,
  #[doc = " Overscan left."]
  pub sHOverscanLeft: ::std::os::raw::c_short,
  #[doc = " Overscan bottom."]
  pub sVOverscanBottom: ::std::os::raw::c_short,
  #[doc = " Overscan top."]
  pub sVOverscanTop: ::std::os::raw::c_short,
  pub sOverscan8B: ::std::os::raw::c_short,
  pub sOverscanGR: ::std::os::raw::c_short,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDetailedTimingX2"][::std::mem::size_of::<ADLDetailedTimingX2>() - 56usize];
  ["Alignment of ADLDetailedTimingX2"]
    [::std::mem::align_of::<ADLDetailedTimingX2>() - 4usize];
  ["Offset of field: ADLDetailedTimingX2::iSize"]
    [::std::mem::offset_of!(ADLDetailedTimingX2, iSize) - 0usize];
  ["Offset of field: ADLDetailedTimingX2::sTimingFlags"]
    [::std::mem::offset_of!(ADLDetailedTimingX2, sTimingFlags) - 4usize];
  ["Offset of field: ADLDetailedTimingX2::sHTotal"]
    [::std::mem::offset_of!(ADLDetailedTimingX2, sHTotal) - 8usize];
  ["Offset of field: ADLDetailedTimingX2::sHDisplay"]
    [::std::mem::offset_of!(ADLDetailedTimingX2, sHDisplay) - 12usize];
  ["Offset of field: ADLDetailedTimingX2::sHSyncStart"]
    [::std::mem::offset_of!(ADLDetailedTimingX2, sHSyncStart) - 16usize];
  ["Offset of field: ADLDetailedTimingX2::sHSyncWidth"]
    [::std::mem::offset_of!(ADLDetailedTimingX2, sHSyncWidth) - 20usize];
  ["Offset of field: ADLDetailedTimingX2::sVTotal"]
    [::std::mem::offset_of!(ADLDetailedTimingX2, sVTotal) - 24usize];
  ["Offset of field: ADLDetailedTimingX2::sVDisplay"]
    [::std::mem::offset_of!(ADLDetailedTimingX2, sVDisplay) - 28usize];
  ["Offset of field: ADLDetailedTimingX2::sVSyncStart"]
    [::std::mem::offset_of!(ADLDetailedTimingX2, sVSyncStart) - 32usize];
  ["Offset of field: ADLDetailedTimingX2::sVSyncWidth"]
    [::std::mem::offset_of!(ADLDetailedTimingX2, sVSyncWidth) - 36usize];
  ["Offset of field: ADLDetailedTimingX2::sPixelClock"]
    [::std::mem::offset_of!(ADLDetailedTimingX2, sPixelClock) - 40usize];
  ["Offset of field: ADLDetailedTimingX2::sHOverscanRight"]
    [::std::mem::offset_of!(ADLDetailedTimingX2, sHOverscanRight) - 44usize];
  ["Offset of field: ADLDetailedTimingX2::sHOverscanLeft"]
    [::std::mem::offset_of!(ADLDetailedTimingX2, sHOverscanLeft) - 46usize];
  ["Offset of field: ADLDetailedTimingX2::sVOverscanBottom"]
    [::std::mem::offset_of!(ADLDetailedTimingX2, sVOverscanBottom) - 48usize];
  ["Offset of field: ADLDetailedTimingX2::sVOverscanTop"]
    [::std::mem::offset_of!(ADLDetailedTimingX2, sVOverscanTop) - 50usize];
  ["Offset of field: ADLDetailedTimingX2::sOverscan8B"]
    [::std::mem::offset_of!(ADLDetailedTimingX2, sOverscan8B) - 52usize];
  ["Offset of field: ADLDetailedTimingX2::sOverscanGR"]
    [::std::mem::offset_of!(ADLDetailedTimingX2, sOverscanGR) - 54usize];
};
#[doc = "\n\\brief Structure containing display mode information.\n\n This structure is used to store the display mode information.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLDisplayModeInfoX2 {
  #[doc = " Timing standard of the current mode. \\ref define_modetiming_standard"]
  pub iTimingStandard: ::std::os::raw::c_int,
  #[doc = " Applicable timing standards for the current mode."]
  pub iPossibleStandard: ::std::os::raw::c_int,
  #[doc = " Refresh rate factor."]
  pub iRefreshRate: ::std::os::raw::c_int,
  #[doc = " Num of pixels in a row."]
  pub iPelsWidth: ::std::os::raw::c_int,
  #[doc = " Num of pixels in a column."]
  pub iPelsHeight: ::std::os::raw::c_int,
  #[doc = " Detailed timing parameters."]
  pub sDetailedTiming: ADLDetailedTimingX2,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLDisplayModeInfoX2"]
    [::std::mem::size_of::<ADLDisplayModeInfoX2>() - 76usize];
  ["Alignment of ADLDisplayModeInfoX2"]
    [::std::mem::align_of::<ADLDisplayModeInfoX2>() - 4usize];
  ["Offset of field: ADLDisplayModeInfoX2::iTimingStandard"]
    [::std::mem::offset_of!(ADLDisplayModeInfoX2, iTimingStandard) - 0usize];
  ["Offset of field: ADLDisplayModeInfoX2::iPossibleStandard"]
    [::std::mem::offset_of!(ADLDisplayModeInfoX2, iPossibleStandard) - 4usize];
  ["Offset of field: ADLDisplayModeInfoX2::iRefreshRate"]
    [::std::mem::offset_of!(ADLDisplayModeInfoX2, iRefreshRate) - 8usize];
  ["Offset of field: ADLDisplayModeInfoX2::iPelsWidth"]
    [::std::mem::offset_of!(ADLDisplayModeInfoX2, iPelsWidth) - 12usize];
  ["Offset of field: ADLDisplayModeInfoX2::iPelsHeight"]
    [::std::mem::offset_of!(ADLDisplayModeInfoX2, iPelsHeight) - 16usize];
  ["Offset of field: ADLDisplayModeInfoX2::sDetailedTiming"]
    [::std::mem::offset_of!(ADLDisplayModeInfoX2, sDetailedTiming) - 20usize];
};
#[doc = "\n\\brief Structure containing information about I2C.\n\n This structure is used to store the I2C information for the current adapter.\n This structure is used by \\ref ADL_Display_WriteAndReadI2CLargePayload\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLI2CLargePayload {
  #[doc = " Size of the structure"]
  pub iSize: ::std::os::raw::c_int,
  #[doc = " Numerical value representing hardware I2C."]
  pub iLine: ::std::os::raw::c_int,
  #[doc = " The 7-bit I2C slave device address."]
  pub iAddress: ::std::os::raw::c_int,
  #[doc = " The offset of the data from the address."]
  pub iOffset: ::std::os::raw::c_int,
  #[doc = " Read from or write to slave device. \\ref ADL_DL_I2C_ACTIONREAD or \\ref ADL_DL_I2C_ACTIONWRITE"]
  pub iAction: ::std::os::raw::c_int,
  #[doc = " I2C clock speed in KHz."]
  pub iSpeed: ::std::os::raw::c_int,
  #[doc = " I2C option flags.  \\ref define_ADLI2CLargePayload"]
  pub iFlags: ::std::os::raw::c_int,
  #[doc = " A numerical value representing the number of bytes to be sent or received on the I2C bus."]
  pub iDataSize: ::std::os::raw::c_int,
  #[doc = " Address of the characters which are to be sent or received on the I2C bus."]
  pub pcData: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLI2CLargePayload"][::std::mem::size_of::<ADLI2CLargePayload>() - 40usize];
  ["Alignment of ADLI2CLargePayload"]
    [::std::mem::align_of::<ADLI2CLargePayload>() - 8usize];
  ["Offset of field: ADLI2CLargePayload::iSize"]
    [::std::mem::offset_of!(ADLI2CLargePayload, iSize) - 0usize];
  ["Offset of field: ADLI2CLargePayload::iLine"]
    [::std::mem::offset_of!(ADLI2CLargePayload, iLine) - 4usize];
  ["Offset of field: ADLI2CLargePayload::iAddress"]
    [::std::mem::offset_of!(ADLI2CLargePayload, iAddress) - 8usize];
  ["Offset of field: ADLI2CLargePayload::iOffset"]
    [::std::mem::offset_of!(ADLI2CLargePayload, iOffset) - 12usize];
  ["Offset of field: ADLI2CLargePayload::iAction"]
    [::std::mem::offset_of!(ADLI2CLargePayload, iAction) - 16usize];
  ["Offset of field: ADLI2CLargePayload::iSpeed"]
    [::std::mem::offset_of!(ADLI2CLargePayload, iSpeed) - 20usize];
  ["Offset of field: ADLI2CLargePayload::iFlags"]
    [::std::mem::offset_of!(ADLI2CLargePayload, iFlags) - 24usize];
  ["Offset of field: ADLI2CLargePayload::iDataSize"]
    [::std::mem::offset_of!(ADLI2CLargePayload, iDataSize) - 28usize];
  ["Offset of field: ADLI2CLargePayload::pcData"]
    [::std::mem::offset_of!(ADLI2CLargePayload, pcData) - 32usize];
};
#[doc = "\n\\brief Structure containing the Multimedia Feature Name\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLFeatureName {
  #[doc = " The Feature Name"]
  pub FeatureName: [::std::os::raw::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLFeatureName"][::std::mem::size_of::<ADLFeatureName>() - 16usize];
  ["Alignment of ADLFeatureName"][::std::mem::align_of::<ADLFeatureName>() - 1usize];
  ["Offset of field: ADLFeatureName::FeatureName"]
    [::std::mem::offset_of!(ADLFeatureName, FeatureName) - 0usize];
};
#[doc = "\n\\brief Structure containing the Multimedia Feature Name\n\n"]
pub type LPADLFeatureName = *mut ADLFeatureName;
#[doc = "\n\\brief Structure containing information about MM Feature Capabilities.\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLFeatureCaps {
  #[doc = " The Feature Name"]
  pub Name: ADLFeatureName,
  #[doc = " Group ID. All Features in the same group are shown sequentially in the same UI Page."]
  pub iGroupID: ::std::os::raw::c_int,
  #[doc = " Visual ID. Places one or more features in a Group Box. If zero, no Group Box is added."]
  pub iVisualID: ::std::os::raw::c_int,
  #[doc = " Page ID. All Features with the same Page ID value are shown together on the same UI page."]
  pub iPageID: ::std::os::raw::c_int,
  #[doc = " Feature Property Mask. Indicates which are the valid bits for iFeatureProperties."]
  pub iFeatureMask: ::std::os::raw::c_int,
  #[doc = " Feature Property Values. See definitions for ADL_FEATURE_PROPERTIES_XXX"]
  pub iFeatureProperties: ::std::os::raw::c_int,
  #[doc = " Apperance of the User-Controlled Boolean."]
  pub iControlType: ::std::os::raw::c_int,
  #[doc = " Style of the User-Controlled Boolean."]
  pub iControlStyle: ::std::os::raw::c_int,
  #[doc = " Apperance of the Adjustment Controls."]
  pub iAdjustmentType: ::std::os::raw::c_int,
  #[doc = " Style of the Adjustment Controls."]
  pub iAdjustmentStyle: ::std::os::raw::c_int,
  #[doc = " Default user-controlled boolean value. Valid only if ADLFeatureCaps supports user-controlled boolean."]
  pub bDefault: ::std::os::raw::c_int,
  #[doc = " Minimum integer value. Valid only if ADLFeatureCaps indicates support for integers."]
  pub iMin: ::std::os::raw::c_int,
  #[doc = " Maximum integer value. Valid only if ADLFeatureCaps indicates support for integers."]
  pub iMax: ::std::os::raw::c_int,
  #[doc = " Step integer value. Valid only if ADLFeatureCaps indicates support for integers."]
  pub iStep: ::std::os::raw::c_int,
  #[doc = " Default integer value. Valid only if ADLFeatureCaps indicates support for integers."]
  pub iDefault: ::std::os::raw::c_int,
  #[doc = " Minimum float value. Valid only if ADLFeatureCaps indicates support for floats."]
  pub fMin: f32,
  #[doc = " Maximum float value. Valid only if ADLFeatureCaps indicates support for floats."]
  pub fMax: f32,
  #[doc = " Step float value. Valid only if ADLFeatureCaps indicates support for floats."]
  pub fStep: f32,
  #[doc = " Default float value. Valid only if ADLFeatureCaps indicates support for floats."]
  pub fDefault: f32,
  #[doc = " The Mask for available bits for enumerated values.(If ADLFeatureCaps supports ENUM values)"]
  pub EnumMask: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLFeatureCaps"][::std::mem::size_of::<ADLFeatureCaps>() - 92usize];
  ["Alignment of ADLFeatureCaps"][::std::mem::align_of::<ADLFeatureCaps>() - 4usize];
  ["Offset of field: ADLFeatureCaps::Name"]
    [::std::mem::offset_of!(ADLFeatureCaps, Name) - 0usize];
  ["Offset of field: ADLFeatureCaps::iGroupID"]
    [::std::mem::offset_of!(ADLFeatureCaps, iGroupID) - 16usize];
  ["Offset of field: ADLFeatureCaps::iVisualID"]
    [::std::mem::offset_of!(ADLFeatureCaps, iVisualID) - 20usize];
  ["Offset of field: ADLFeatureCaps::iPageID"]
    [::std::mem::offset_of!(ADLFeatureCaps, iPageID) - 24usize];
  ["Offset of field: ADLFeatureCaps::iFeatureMask"]
    [::std::mem::offset_of!(ADLFeatureCaps, iFeatureMask) - 28usize];
  ["Offset of field: ADLFeatureCaps::iFeatureProperties"]
    [::std::mem::offset_of!(ADLFeatureCaps, iFeatureProperties) - 32usize];
  ["Offset of field: ADLFeatureCaps::iControlType"]
    [::std::mem::offset_of!(ADLFeatureCaps, iControlType) - 36usize];
  ["Offset of field: ADLFeatureCaps::iControlStyle"]
    [::std::mem::offset_of!(ADLFeatureCaps, iControlStyle) - 40usize];
  ["Offset of field: ADLFeatureCaps::iAdjustmentType"]
    [::std::mem::offset_of!(ADLFeatureCaps, iAdjustmentType) - 44usize];
  ["Offset of field: ADLFeatureCaps::iAdjustmentStyle"]
    [::std::mem::offset_of!(ADLFeatureCaps, iAdjustmentStyle) - 48usize];
  ["Offset of field: ADLFeatureCaps::bDefault"]
    [::std::mem::offset_of!(ADLFeatureCaps, bDefault) - 52usize];
  ["Offset of field: ADLFeatureCaps::iMin"]
    [::std::mem::offset_of!(ADLFeatureCaps, iMin) - 56usize];
  ["Offset of field: ADLFeatureCaps::iMax"]
    [::std::mem::offset_of!(ADLFeatureCaps, iMax) - 60usize];
  ["Offset of field: ADLFeatureCaps::iStep"]
    [::std::mem::offset_of!(ADLFeatureCaps, iStep) - 64usize];
  ["Offset of field: ADLFeatureCaps::iDefault"]
    [::std::mem::offset_of!(ADLFeatureCaps, iDefault) - 68usize];
  ["Offset of field: ADLFeatureCaps::fMin"]
    [::std::mem::offset_of!(ADLFeatureCaps, fMin) - 72usize];
  ["Offset of field: ADLFeatureCaps::fMax"]
    [::std::mem::offset_of!(ADLFeatureCaps, fMax) - 76usize];
  ["Offset of field: ADLFeatureCaps::fStep"]
    [::std::mem::offset_of!(ADLFeatureCaps, fStep) - 80usize];
  ["Offset of field: ADLFeatureCaps::fDefault"]
    [::std::mem::offset_of!(ADLFeatureCaps, fDefault) - 84usize];
  ["Offset of field: ADLFeatureCaps::EnumMask"]
    [::std::mem::offset_of!(ADLFeatureCaps, EnumMask) - 88usize];
};
#[doc = "\n\\brief Structure containing information about MM Feature Capabilities.\n\n"]
pub type LPADLFeatureCaps = *mut ADLFeatureCaps;
#[doc = "\n\\brief Structure containing information about MM Feature Values.\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLFeatureValues {
  #[doc = " The Feature Name"]
  pub Name: ADLFeatureName,
  #[doc = " User controlled Boolean current value. Valid only if ADLFeatureCaps supports Boolean."]
  pub bCurrent: ::std::os::raw::c_int,
  #[doc = " Current integer value. Valid only if ADLFeatureCaps indicates support for integers."]
  pub iCurrent: ::std::os::raw::c_int,
  #[doc = " Current float value. Valid only if ADLFeatureCaps indicates support for floats."]
  pub fCurrent: f32,
  #[doc = " The States for the available bits for enumerated values."]
  pub EnumStates: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLFeatureValues"][::std::mem::size_of::<ADLFeatureValues>() - 32usize];
  ["Alignment of ADLFeatureValues"][::std::mem::align_of::<ADLFeatureValues>() - 4usize];
  ["Offset of field: ADLFeatureValues::Name"]
    [::std::mem::offset_of!(ADLFeatureValues, Name) - 0usize];
  ["Offset of field: ADLFeatureValues::bCurrent"]
    [::std::mem::offset_of!(ADLFeatureValues, bCurrent) - 16usize];
  ["Offset of field: ADLFeatureValues::iCurrent"]
    [::std::mem::offset_of!(ADLFeatureValues, iCurrent) - 20usize];
  ["Offset of field: ADLFeatureValues::fCurrent"]
    [::std::mem::offset_of!(ADLFeatureValues, fCurrent) - 24usize];
  ["Offset of field: ADLFeatureValues::EnumStates"]
    [::std::mem::offset_of!(ADLFeatureValues, EnumStates) - 28usize];
};
#[doc = "\n\\brief Structure containing information about MM Feature Values.\n\n"]
pub type LPADLFeatureValues = *mut ADLFeatureValues;
#[doc = "\n\\brief Structure containing HDCP Settings info\n\n This structure is used to store the HDCP settings of a\n display\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLHDCPSettings {
  pub iHDCPProtectionVersion: ::std::os::raw::c_int,
  pub iHDCPCaps: ::std::os::raw::c_int,
  pub iAllowAll: ::std::os::raw::c_int,
  pub iHDCPVale: ::std::os::raw::c_int,
  pub iHDCPMask: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLHDCPSettings"][::std::mem::size_of::<ADLHDCPSettings>() - 20usize];
  ["Alignment of ADLHDCPSettings"][::std::mem::align_of::<ADLHDCPSettings>() - 4usize];
  ["Offset of field: ADLHDCPSettings::iHDCPProtectionVersion"]
    [::std::mem::offset_of!(ADLHDCPSettings, iHDCPProtectionVersion) - 0usize];
  ["Offset of field: ADLHDCPSettings::iHDCPCaps"]
    [::std::mem::offset_of!(ADLHDCPSettings, iHDCPCaps) - 4usize];
  ["Offset of field: ADLHDCPSettings::iAllowAll"]
    [::std::mem::offset_of!(ADLHDCPSettings, iAllowAll) - 8usize];
  ["Offset of field: ADLHDCPSettings::iHDCPVale"]
    [::std::mem::offset_of!(ADLHDCPSettings, iHDCPVale) - 12usize];
  ["Offset of field: ADLHDCPSettings::iHDCPMask"]
    [::std::mem::offset_of!(ADLHDCPSettings, iHDCPMask) - 16usize];
};
#[doc = "\n\\brief Structure containing Mantle App  info\n\n This structure is used to store the Mantle Driver information\n \\nosubgrouping\n \\deprecated This structure has been deprecated.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLMantleAppInfo {
  #[doc = " mantle api version"]
  pub apiVersion: ::std::os::raw::c_int,
  #[doc = " mantle driver version"]
  pub driverVersion: ::std::os::raw::c_long,
  #[doc = " mantle vendroe id"]
  pub vendorId: ::std::os::raw::c_long,
  #[doc = " mantle device id"]
  pub deviceId: ::std::os::raw::c_long,
  #[doc = " mantle gpu type;"]
  pub gpuType: ::std::os::raw::c_int,
  #[doc = " gpu name"]
  pub gpuName: [::std::os::raw::c_char; 256usize],
  #[doc = " mem size"]
  pub maxMemRefsPerSubmission: ::std::os::raw::c_int,
  #[doc = " virtual mem size"]
  pub virtualMemPageSize: ::std::os::raw::c_longlong,
  #[doc = " mem update"]
  pub maxInlineMemoryUpdateSize: ::std::os::raw::c_longlong,
  #[doc = " bound descriptot"]
  pub maxBoundDescriptorSets: ::std::os::raw::c_long,
  #[doc = " thread group size"]
  pub maxThreadGroupSize: ::std::os::raw::c_long,
  #[doc = " time stamp frequency"]
  pub timestampFrequency: ::std::os::raw::c_longlong,
  #[doc = " color target"]
  pub multiColorTargetClears: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLMantleAppInfo"][::std::mem::size_of::<ADLMantleAppInfo>() - 320usize];
  ["Alignment of ADLMantleAppInfo"][::std::mem::align_of::<ADLMantleAppInfo>() - 8usize];
  ["Offset of field: ADLMantleAppInfo::apiVersion"]
    [::std::mem::offset_of!(ADLMantleAppInfo, apiVersion) - 0usize];
  ["Offset of field: ADLMantleAppInfo::driverVersion"]
    [::std::mem::offset_of!(ADLMantleAppInfo, driverVersion) - 4usize];
  ["Offset of field: ADLMantleAppInfo::vendorId"]
    [::std::mem::offset_of!(ADLMantleAppInfo, vendorId) - 8usize];
  ["Offset of field: ADLMantleAppInfo::deviceId"]
    [::std::mem::offset_of!(ADLMantleAppInfo, deviceId) - 12usize];
  ["Offset of field: ADLMantleAppInfo::gpuType"]
    [::std::mem::offset_of!(ADLMantleAppInfo, gpuType) - 16usize];
  ["Offset of field: ADLMantleAppInfo::gpuName"]
    [::std::mem::offset_of!(ADLMantleAppInfo, gpuName) - 20usize];
  ["Offset of field: ADLMantleAppInfo::maxMemRefsPerSubmission"]
    [::std::mem::offset_of!(ADLMantleAppInfo, maxMemRefsPerSubmission) - 276usize];
  ["Offset of field: ADLMantleAppInfo::virtualMemPageSize"]
    [::std::mem::offset_of!(ADLMantleAppInfo, virtualMemPageSize) - 280usize];
  ["Offset of field: ADLMantleAppInfo::maxInlineMemoryUpdateSize"]
    [::std::mem::offset_of!(ADLMantleAppInfo, maxInlineMemoryUpdateSize) - 288usize];
  ["Offset of field: ADLMantleAppInfo::maxBoundDescriptorSets"]
    [::std::mem::offset_of!(ADLMantleAppInfo, maxBoundDescriptorSets) - 296usize];
  ["Offset of field: ADLMantleAppInfo::maxThreadGroupSize"]
    [::std::mem::offset_of!(ADLMantleAppInfo, maxThreadGroupSize) - 300usize];
  ["Offset of field: ADLMantleAppInfo::timestampFrequency"]
    [::std::mem::offset_of!(ADLMantleAppInfo, timestampFrequency) - 304usize];
  ["Offset of field: ADLMantleAppInfo::multiColorTargetClears"]
    [::std::mem::offset_of!(ADLMantleAppInfo, multiColorTargetClears) - 312usize];
};
#[doc = "\n\\brief Structure containing Mantle App  info\n\n This structure is used to store the Mantle Driver information\n \\nosubgrouping\n \\deprecated This structure has been deprecated.\n"]
pub type LPADLMantleAppInfo = *mut ADLMantleAppInfo;
#[doc = "\n\\brief Structure containing information about SDIData\nThis structure is used to store information about the state of the SDI whether it is on\nor off and the current size of the segment or aperture size.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLSDIData {
  #[doc = " The SDI state, ADL_SDI_ON or ADL_SDI_OFF, for the current SDI mode"]
  pub iSDIState: ::std::os::raw::c_int,
  #[doc = " Size of the memory segment for SDI (in MB)."]
  pub iSizeofSDISegment: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLSDIData"][::std::mem::size_of::<ADLSDIData>() - 8usize];
  ["Alignment of ADLSDIData"][::std::mem::align_of::<ADLSDIData>() - 4usize];
  ["Offset of field: ADLSDIData::iSDIState"]
    [::std::mem::offset_of!(ADLSDIData, iSDIState) - 0usize];
  ["Offset of field: ADLSDIData::iSizeofSDISegment"]
    [::std::mem::offset_of!(ADLSDIData, iSizeofSDISegment) - 4usize];
};
#[doc = "\n\\brief Structure containing information about SDIData\nThis structure is used to store information about the state of the SDI whether it is on\nor off and the current size of the segment or aperture size.\n"]
pub type LPADLSDIData = *mut ADLSDIData;
#[doc = "\n\\brief Structure containing information about FRTCPRO Settings\n\n  Elements of FRTCPRO settings.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_FRTCPRO_Settings {
  pub DefaultState: ::std::os::raw::c_int,
  pub CurrentState: ::std::os::raw::c_int,
  pub DefaultValue: ::std::os::raw::c_uint,
  pub CurrentValue: ::std::os::raw::c_uint,
  pub maxSupportedFps: ::std::os::raw::c_uint,
  pub minSupportedFps: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_FRTCPRO_Settings"]
    [::std::mem::size_of::<ADL_FRTCPRO_Settings>() - 24usize];
  ["Alignment of ADL_FRTCPRO_Settings"]
    [::std::mem::align_of::<ADL_FRTCPRO_Settings>() - 4usize];
  ["Offset of field: ADL_FRTCPRO_Settings::DefaultState"]
    [::std::mem::offset_of!(ADL_FRTCPRO_Settings, DefaultState) - 0usize];
  ["Offset of field: ADL_FRTCPRO_Settings::CurrentState"]
    [::std::mem::offset_of!(ADL_FRTCPRO_Settings, CurrentState) - 4usize];
  ["Offset of field: ADL_FRTCPRO_Settings::DefaultValue"]
    [::std::mem::offset_of!(ADL_FRTCPRO_Settings, DefaultValue) - 8usize];
  ["Offset of field: ADL_FRTCPRO_Settings::CurrentValue"]
    [::std::mem::offset_of!(ADL_FRTCPRO_Settings, CurrentValue) - 12usize];
  ["Offset of field: ADL_FRTCPRO_Settings::maxSupportedFps"]
    [::std::mem::offset_of!(ADL_FRTCPRO_Settings, maxSupportedFps) - 16usize];
  ["Offset of field: ADL_FRTCPRO_Settings::minSupportedFps"]
    [::std::mem::offset_of!(ADL_FRTCPRO_Settings, minSupportedFps) - 20usize];
};
#[doc = "\n\\brief Structure containing information about FRTCPRO Settings\n\n  Elements of FRTCPRO settings.\n \\nosubgrouping\n"]
pub type LPADLFRTCProSettings = *mut ADL_FRTCPRO_Settings;
#[doc = "\n\\brief Structure containing information about FRTCPRO Settings changed reason\n\n  Reason of FRTCPRO changed.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_FRTCPRO_CHANGED_REASON {
  pub StateChanged: ::std::os::raw::c_int,
  pub ValueChanged: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_FRTCPRO_CHANGED_REASON"]
    [::std::mem::size_of::<ADL_FRTCPRO_CHANGED_REASON>() - 8usize];
  ["Alignment of ADL_FRTCPRO_CHANGED_REASON"]
    [::std::mem::align_of::<ADL_FRTCPRO_CHANGED_REASON>() - 4usize];
  ["Offset of field: ADL_FRTCPRO_CHANGED_REASON::StateChanged"]
    [::std::mem::offset_of!(ADL_FRTCPRO_CHANGED_REASON, StateChanged) - 0usize];
  ["Offset of field: ADL_FRTCPRO_CHANGED_REASON::ValueChanged"]
    [::std::mem::offset_of!(ADL_FRTCPRO_CHANGED_REASON, ValueChanged) - 4usize];
};
#[doc = "\n \\brief Structure containing the display mode definition used per controller.\n\n This structure is used to store the display mode definition used per controller.\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADL_DL_DISPLAY_MODE {
  pub iPelsHeight: ::std::os::raw::c_int,
  pub iPelsWidth: ::std::os::raw::c_int,
  pub iBitsPerPel: ::std::os::raw::c_int,
  pub iDisplayFrequency: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADL_DL_DISPLAY_MODE"][::std::mem::size_of::<ADL_DL_DISPLAY_MODE>() - 16usize];
  ["Alignment of ADL_DL_DISPLAY_MODE"]
    [::std::mem::align_of::<ADL_DL_DISPLAY_MODE>() - 4usize];
  ["Offset of field: ADL_DL_DISPLAY_MODE::iPelsHeight"]
    [::std::mem::offset_of!(ADL_DL_DISPLAY_MODE, iPelsHeight) - 0usize];
  ["Offset of field: ADL_DL_DISPLAY_MODE::iPelsWidth"]
    [::std::mem::offset_of!(ADL_DL_DISPLAY_MODE, iPelsWidth) - 4usize];
  ["Offset of field: ADL_DL_DISPLAY_MODE::iBitsPerPel"]
    [::std::mem::offset_of!(ADL_DL_DISPLAY_MODE, iBitsPerPel) - 8usize];
  ["Offset of field: ADL_DL_DISPLAY_MODE::iDisplayFrequency"]
    [::std::mem::offset_of!(ADL_DL_DISPLAY_MODE, iDisplayFrequency) - 12usize];
};
#[doc = "\n\\brief Structure containing information related DCE support\n\n This structure is used to store a bit vector of possible DCE support\n\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ADLDCESupport {
  pub bits: _ADLDCESupport__bindgen_ty_1,
  pub u32All: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ADLDCESupport__bindgen_ty_1 {
  pub _bitfield_align_1: [u32; 0],
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _ADLDCESupport__bindgen_ty_1"]
    [::std::mem::size_of::<_ADLDCESupport__bindgen_ty_1>() - 4usize];
  ["Alignment of _ADLDCESupport__bindgen_ty_1"]
    [::std::mem::align_of::<_ADLDCESupport__bindgen_ty_1>() - 4usize];
};
impl _ADLDCESupport__bindgen_ty_1 {
  #[inline]
  pub fn PrePhasis(&self) -> ::std::os::raw::c_uint {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_PrePhasis(&mut self, val: ::std::os::raw::c_uint) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub unsafe fn PrePhasis_raw(this: *const Self) -> ::std::os::raw::c_uint {
    unsafe {
      ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
        ::std::ptr::addr_of!((*this)._bitfield_1),
        0usize,
        1u8,
      ) as u32)
    }
  }
  #[inline]
  pub unsafe fn set_PrePhasis_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
        0usize,
        1u8,
        val as u64,
      )
    }
  }
  #[inline]
  pub fn voltageSwing(&self) -> ::std::os::raw::c_uint {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_voltageSwing(&mut self, val: ::std::os::raw::c_uint) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub unsafe fn voltageSwing_raw(this: *const Self) -> ::std::os::raw::c_uint {
    unsafe {
      ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
        ::std::ptr::addr_of!((*this)._bitfield_1),
        1usize,
        1u8,
      ) as u32)
    }
  }
  #[inline]
  pub unsafe fn set_voltageSwing_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
        1usize,
        1u8,
        val as u64,
      )
    }
  }
  #[inline]
  pub fn reserved(&self) -> ::std::os::raw::c_uint {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
  }
  #[inline]
  pub fn set_reserved(&mut self, val: ::std::os::raw::c_uint) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(2usize, 30u8, val as u64)
    }
  }
  #[inline]
  pub unsafe fn reserved_raw(this: *const Self) -> ::std::os::raw::c_uint {
    unsafe {
      ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
        ::std::ptr::addr_of!((*this)._bitfield_1),
        2usize,
        30u8,
      ) as u32)
    }
  }
  #[inline]
  pub unsafe fn set_reserved_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
        ::std::ptr::addr_of_mut!((*this)._bitfield_1),
        2usize,
        30u8,
        val as u64,
      )
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    PrePhasis: ::std::os::raw::c_uint,
    voltageSwing: ::std::os::raw::c_uint,
    reserved: ::std::os::raw::c_uint,
  ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
      Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let PrePhasis: u32 = unsafe { ::std::mem::transmute(PrePhasis) };
      PrePhasis as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let voltageSwing: u32 = unsafe { ::std::mem::transmute(voltageSwing) };
      voltageSwing as u64
    });
    __bindgen_bitfield_unit.set(2usize, 30u8, {
      let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
      reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _ADLDCESupport"][::std::mem::size_of::<_ADLDCESupport>() - 4usize];
  ["Alignment of _ADLDCESupport"][::std::mem::align_of::<_ADLDCESupport>() - 4usize];
  ["Offset of field: _ADLDCESupport::bits"]
    [::std::mem::offset_of!(_ADLDCESupport, bits) - 0usize];
  ["Offset of field: _ADLDCESupport::u32All"]
    [::std::mem::offset_of!(_ADLDCESupport, u32All) - 0usize];
};
#[doc = "\n\\brief Structure containing information related DCE support\n\n This structure is used to store a bit vector of possible DCE support\n\n \\nosubgrouping\n"]
pub type ADLDCESupport = _ADLDCESupport;
#[doc = "\n \\brief Structure for Smart shift 2.0 settings\n\n This structure is used to return the smart shift settings\n \\nosubgrouping\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADLSmartShiftSettings {
  pub iMinRange: ::std::os::raw::c_int,
  pub iMaxRange: ::std::os::raw::c_int,
  pub iDefaultMode: ::std::os::raw::c_int,
  pub iDefaultValue: ::std::os::raw::c_int,
  pub iCurrentMode: ::std::os::raw::c_int,
  pub iCurrentValue: ::std::os::raw::c_int,
  pub iFlags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ADLSmartShiftSettings"]
    [::std::mem::size_of::<ADLSmartShiftSettings>() - 28usize];
  ["Alignment of ADLSmartShiftSettings"]
    [::std::mem::align_of::<ADLSmartShiftSettings>() - 4usize];
  ["Offset of field: ADLSmartShiftSettings::iMinRange"]
    [::std::mem::offset_of!(ADLSmartShiftSettings, iMinRange) - 0usize];
  ["Offset of field: ADLSmartShiftSettings::iMaxRange"]
    [::std::mem::offset_of!(ADLSmartShiftSettings, iMaxRange) - 4usize];
  ["Offset of field: ADLSmartShiftSettings::iDefaultMode"]
    [::std::mem::offset_of!(ADLSmartShiftSettings, iDefaultMode) - 8usize];
  ["Offset of field: ADLSmartShiftSettings::iDefaultValue"]
    [::std::mem::offset_of!(ADLSmartShiftSettings, iDefaultValue) - 12usize];
  ["Offset of field: ADLSmartShiftSettings::iCurrentMode"]
    [::std::mem::offset_of!(ADLSmartShiftSettings, iCurrentMode) - 16usize];
  ["Offset of field: ADLSmartShiftSettings::iCurrentValue"]
    [::std::mem::offset_of!(ADLSmartShiftSettings, iCurrentValue) - 20usize];
  ["Offset of field: ADLSmartShiftSettings::iFlags"]
    [::std::mem::offset_of!(ADLSmartShiftSettings, iFlags) - 24usize];
};
#[doc = "\n \\brief Structure for Smart shift 2.0 settings\n\n This structure is used to return the smart shift settings\n \\nosubgrouping\n"]
pub type LPADLSmartShiftSettings = *mut ADLSmartShiftSettings;
#[doc = " Memory Allocation Call back"]
pub type ADL_MAIN_MALLOC_CALLBACK = ::std::option::Option<
  unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void,
>;

extern "C" {
  pub fn ADL2_Main_Control_Create(
    callback: Option<unsafe extern "C" fn(i32) -> *mut std::ffi::c_void>,
    enum_connected_adapters: i32,
    context: *mut *mut std::ffi::c_void, // ADL_CONTEXT_HANDLE 
  ) -> i32;
}
